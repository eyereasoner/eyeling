<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Mobile-friendly viewport + safe-area support -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

  <title>Eyeling N3 Playground</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.css">

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f7;
      color: #111827;

      /* Avoid weird auto-scaling on mobile */
      -webkit-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }

    .page {
      max-width: 1500px;
      margin: 0 auto;

      /* Safe areas (iPhone notch/home bar) */
      padding-top: calc(1.5rem + env(safe-area-inset-top));
      padding-right: calc(1rem + env(safe-area-inset-right));
      padding-bottom: calc(3rem + env(safe-area-inset-bottom));
      padding-left: calc(1rem + env(safe-area-inset-left));

      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 600;
    }

    header p {
      margin: 0.25rem 0 0;
      font-size: 0.9rem;
      color: #6b7280;
    }

    header a {
      color: #2563eb;
      text-decoration: none;
    }
    header a:hover { text-decoration: underline; }

    .meta {
      margin-top: 0.35rem;
      font-size: 0.85rem;
      color: #6b7280;
    }

    label {
      font-size: 0.9rem;
      font-weight: 500;
      color: #374151;
      margin-bottom: 0.35rem;
      display: inline-block;
    }

    textarea {
      width: 100%;
      border-radius: 0.75rem;
      border: 1px solid #d1d5db;
      padding: 1rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      resize: none;
      overflow: hidden; /* no scrollbars inside the editor */
      background: #ffffff;
    }

    textarea:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
    }

    .controls {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 0.75rem;
      margin-top: 0.25rem;
      flex-wrap: wrap;
    }

    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      font-size: 0.85rem;
      font-weight: 500;
      color: #374151;
      user-select: none;
      cursor: pointer;
    }

    .toggle input {
      width: 1rem;
      height: 1rem;
      accent-color: #2563eb;
      cursor: pointer;
      touch-action: manipulation;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.5rem 1.25rem;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      background: #2563eb;
      color: #ffffff;
      box-shadow: 0 10px 15px rgba(37, 99, 235, 0.25);
      transition: transform 0.05s ease-out, box-shadow 0.05s ease-out, opacity 0.1s;

      /* Better taps on mobile */
      min-height: 44px;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 14px 24px rgba(37, 99, 235, 0.32);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: 0 8px 12px rgba(37, 99, 235, 0.2);
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
    }

    .status {
      font-size: 0.8rem;
      color: #6b7280;
    }

    /* (fallback only; output is now CodeMirror) */
    pre#output {
      margin: 0.25rem 0 0;
      border-radius: 0.75rem;
      border: 1px solid #d1d5db;
      padding: 1rem;
      background: #ffffff;
      color: #111827;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 0.85rem;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
      overflow: hidden; /* no scrollbars inside the output box */
      min-height: 5rem;
    }

    .card {
      background: #ffffff;
      border-radius: 1rem;
      padding: 1rem 1.25rem 1.25rem;
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.08);
      border: 1px solid rgba(148, 163, 184, 0.25);
    }

    .section-title {
      font-size: 1rem;
      font-weight: 500;
      margin: 0 0 0.5rem;
      color: #111827;
    }

    .uri-row { margin-bottom: 0.75rem; }

    .uri-input-row {
      display: flex;
      flex-direction: row;
      gap: 0.5rem;
      align-items: center;
      margin-top: 0.25rem;
    }

    .uri-input-row input[type="text"] {
      flex: 1;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      padding: 0.45rem 0.75rem;
      font-size: 0.85rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f9fafb;
    }

    .uri-input-row input[type="text"]:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.25);
      background: #ffffff;
    }

    .hint {
      display: block;
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 0.15rem;
    }

    /* --- CodeMirror (syntax highlighted) editors --- */
    .CodeMirror {
      height: auto;
      border: 1px solid #d1d5db;
      border-radius: 0.75rem;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
        "Courier New", monospace;
      font-size: 0.9rem;
      line-height: 1.4;
      background: #ffffff;
    }

    .CodeMirror.CodeMirror-focused {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.35);
    }

    .CodeMirror-scroll {
      overflow: hidden !important; /* desktop: no scrollbars; we auto-size instead */
    }

    .CodeMirror-gutters {
      border-right: 1px solid #e5e7eb;
      background: #f9fafb;
    }

    .cm-output {
      font-size: 0.85rem;
      min-height: 5rem;
    }

    /* Highlight N3 syntax error line in the editor */
    .cm-error-line {
      background: rgba(239, 68, 68, 0.18);
    }

    /* ---------------------------
       MOBILE POLISH (key changes)
       --------------------------- */
    @media (max-width: 640px) {
      .page {
        gap: 0.85rem;
        padding-top: calc(1.1rem + env(safe-area-inset-top));
        padding-right: calc(0.85rem + env(safe-area-inset-right));
        padding-bottom: calc(2.5rem + env(safe-area-inset-bottom));
        padding-left: calc(0.85rem + env(safe-area-inset-left));
      }

      header h1 {
        font-size: 1.25rem;
      }

      header p {
        font-size: 0.95rem;
      }

      .card {
        padding: 0.95rem 1rem 1.05rem;
        border-radius: 1rem;
      }

      /* Stack URL input + button (no squishing) */
      .uri-input-row {
        flex-direction: column;
        align-items: stretch;
      }

      /* Prevent iOS "zoom on focus" (>=16px) */
      .uri-input-row input[type="text"] {
        font-size: 16px;
        padding: 0.65rem 0.9rem;
        width: 100%;
      }

      /* Make the load button full-width */
      #load-uri-btn {
        width: 100%;
        justify-content: center;
      }

      /* Controls become a sticky action area on mobile */
      .controls {
        position: sticky;
        bottom: calc(env(safe-area-inset-bottom) + 10px);
        padding: 0.75rem 0;
        margin-top: 0.75rem;
        background: rgba(245, 245, 247, 0.88);
        backdrop-filter: blur(10px);
        border-top: 1px solid rgba(148, 163, 184, 0.35);

        flex-direction: column;
        align-items: stretch;
        gap: 0.6rem;
      }

      /* Full-width run button, bigger type for easy taps */
      #run-btn {
        width: 100%;
        font-size: 16px;
      }

      /* Make toggles/status readable and line-wrap */
      .toggle {
        width: 100%;
        font-size: 0.95rem;
      }
      .status {
        font-size: 0.9rem;
      }

      /* On mobile we cap editor height and allow internal scrolling */
      .CodeMirror {
        font-size: 0.95rem;
      }
      .CodeMirror-scroll {
        overflow: auto !important;
        -webkit-overflow-scrolling: touch;
      }
    }

    /* Optional: Dark mode (keeps it pleasant on mobile) */
    @media (prefers-color-scheme: dark) {
      body { background: #0b0f14; color: #e7eaf0; }
      header p, .meta, .status { color: #a7b0bf; }
      label, .toggle { color: #cbd5e1; }
      .card { background: #0f1620; border-color: rgba(148,163,184,0.18); box-shadow: 0 18px 40px rgba(0,0,0,0.35); }
      .section-title { color: #e7eaf0; }

      .cm-error-line { background: rgba(239, 68, 68, 0.22); }

      textarea { background: #0f1620; border-color: #1f2a37; color: #e7eaf0; }
      .CodeMirror { background: #0f1620; border-color: #1f2a37; }
      .CodeMirror-gutters { background: #0b0f14; border-right-color: #1f2a37; }

      .uri-input-row input[type="text"] { background: #0b0f14; border-color: #1f2a37; color: #e7eaf0; }
      .uri-input-row input[type="text"]:focus { background: #0f1620; }

      @media (max-width: 640px) {
        .controls {
          background: rgba(11, 15, 20, 0.88);
          border-top-color: rgba(148, 163, 184, 0.18);
        }
      }
    }
  
    /* --- Tabs (Playground / Streaming demo) --- */
    .tabs {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
      margin-top: -0.25rem;
    }
    .tab-btn {
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.85);
      color: #111827;
      border-radius: 999px;
      padding: 0.45rem 0.95rem;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      min-height: 40px;
    }
    .tab-btn[aria-selected="true"] {
      background: #2563eb;
      border-color: #2563eb;
      color: #ffffff;
      box-shadow: 0 10px 15px rgba(37, 99, 235, 0.22);
    }
    .tab-content { display: none; }
    .tab-content.is-active { display: block; }

    .playground-inner {
      max-width: 960px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    /* --- Stream app (scoped) --- */
    #streamApp{
      --s-bg:#f6f7fb;
      --s-panel:#ffffff;
      --s-text:#1b2430;
      --s-muted:#5b6b7c;
      --s-line:#d6dee8;
      --s-btn:#2563eb;
      --s-btn2:#e7edf7;
      --s-codebg:#f3f5f9;
      background: var(--s-bg);
      border-radius: 1rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 18px 40px rgba(15, 23, 42, 0.06);
      overflow: hidden;
    }
    #streamApp .stream-topbar{
      padding:10px 12px; border-bottom:1px solid var(--s-line);
      display:flex; gap:10px; align-items:center; background:#fff;
      position:sticky; top:0; z-index:10;
    }
    #streamApp .stream-topbar input{
      background:#fff; border:1px solid var(--s-line); color:var(--s-text);
      padding:9px 10px; border-radius:10px; flex:1; min-width: 220px;
    }
    #streamApp .stream-topbar button{
      background:var(--s-btn); border:0; color:#fff; padding:9px 12px;
      border-radius:10px; cursor:pointer; font-weight:700; white-space:nowrap;
      min-height: 40px;
    }
    #streamApp .stream-topbar button.secondary{
      background:var(--s-btn2); color:var(--s-text); border:1px solid var(--s-line);
      font-weight:700;
    }
    #streamApp .stream-topbar button:disabled{ opacity:.55; cursor:not-allowed; }
    #streamApp .stream-layout{
      display:grid; grid-template-columns:1fr 1fr; gap:12px; padding:12px;
      box-sizing:border-box; max-width:1500px; margin:0 auto; align-items:start;
    }
    @media (max-width: 980px){ #streamApp .stream-layout{ grid-template-columns:1fr; } }
    #streamApp .stream-col{ display:flex; flex-direction:column; gap:12px; min-width:0; }

    #streamApp .stream-panel{
      background:var(--s-panel); border:1px solid var(--s-line); border-radius:14px;
      display:flex; flex-direction:column; overflow:hidden;
      box-shadow:0 4px 16px rgba(16,24,40,.06);
    }
    #streamApp .stream-panel h2{
      margin:0; padding:10px 12px; font-size:14px; font-weight:900;
      border-bottom:1px solid var(--s-line); color:var(--s-muted);
      letter-spacing:.2px;
    }
    #streamApp .stream-panel .content{ padding:12px; display:flex; flex-direction:column; gap:10px; }

    #streamApp .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #streamApp .row label{ font-size:12px; color:var(--s-muted); display:flex; gap:6px; align-items:center; }
    #streamApp .muted{ color:var(--s-muted); font-size:12px; }
    #streamApp .status{ font-size:12px; color:var(--s-muted); }
    #streamApp .badge{
      display:inline-block; padding:3px 8px; border-radius:999px; font-size:12px;
      border:1px solid var(--s-line); background:#fff; color:var(--s-muted);
    }

    #streamApp textarea{
      width:100%; background:var(--s-codebg); border:1px solid var(--s-line);
      color:var(--s-text); padding:10px; border-radius:12px; box-sizing:border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; line-height:1.35;
    }
    #streamApp textarea.preview{ height:220px; overflow:auto; resize:vertical; }
    #streamApp textarea.full{ height:100%; resize:none; overflow:auto; }
    #streamApp .list{ display:flex; flex-direction:column; gap:8px; max-height:240px; overflow:auto; padding-right:2px; }
    #streamApp .item{ padding:10px 12px; border:1px solid var(--s-line); border-radius:12px; background:#fff; cursor:pointer; user-select:none; }
    #streamApp .item:hover{ border-color:#9db6ee; box-shadow:0 2px 10px rgba(37,99,235,.10); }
    #streamApp .item.selected{ border-color:#2563eb; box-shadow:0 2px 12px rgba(37,99,235,.16); }
    #streamApp .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    #streamApp .out{
      white-space:pre-wrap; word-break:break-word; background:var(--s-codebg);
      border:1px solid var(--s-line); border-radius:12px; padding:10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; line-height:1.35;
      max-height:min(52vh, 560px); overflow:auto;
    }

    #streamApp .modalBackdrop{
      position:fixed; inset:0; background:rgba(12,18,28,.55); display:none;
      align-items:center; justify-content:center; padding:18px; z-index:1000;
    }
    #streamApp .modal{
      width:min(1100px, 96vw); height:min(86vh, 900px); background:#fff;
      border-radius:16px; border:1px solid var(--s-line);
      box-shadow:0 20px 80px rgba(0,0,0,.25);
      display:flex; flex-direction:column; overflow:hidden;
    }
    #streamApp .modalHeader{
      padding:10px 12px; border-bottom:1px solid var(--s-line);
      display:flex; align-items:center; justify-content:space-between; gap:10px; background:#fff;
    }
    #streamApp .modalHeader .title{ font-weight:900; color:var(--s-muted); font-size:14px; }
    #streamApp .modalBody{ padding:12px; display:flex; flex-direction:column; gap:10px; height:100%; }

  </style>

  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/lib/codemirror.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/turtle/turtle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/codemirror@5.65.16/mode/sparql/sparql.min.js"></script>
</head>

<body>
  <div class="page">
    <header>
      <h1>Eyeling N3 Playground</h1>
      <p>
        Edit the N3 program below, load it from a URL, or share this page with the program encoded in the fragment.
      </p>
      <p class="meta">
        Powered by
        <a href="https://eyereasoner.github.io/eyeling/" target="_blank" rel="noopener noreferrer">Eyeling</a>
        — running version <strong>v<span id="eyeling-version">…</span></strong>.
      </p>
    </header>


    <nav class="tabs" role="tablist" aria-label="Eyeling demos">
      <button class="tab-btn" type="button" role="tab" data-tab="playground" aria-controls="tab-playground" aria-selected="true">Playground</button>
      <button class="tab-btn" type="button" role="tab" data-tab="stream" aria-controls="tab-stream" aria-selected="false">Streaming demo</button>
    </nav>

    <div id="tab-playground" class="tab-content is-active" role="tabpanel" aria-label="Playground">
      <div class="playground-inner">
    <section class="card">
      <h2 class="section-title">Input N3</h2>

      <div class="uri-row">
        <label for="n3-uri">Load N3 from URL</label>
        <div class="uri-input-row">
          <input
            id="n3-uri"
            type="text"
            value="https://raw.githubusercontent.com/eyereasoner/eyeling/refs/heads/main/examples/witch.n3"
          />
          <button id="load-uri-btn" type="button">Load from URL</button>
        </div>
        <span class="hint">
          Enter any N3 file URL (raw GitHub URLs work well) and click “Load from URL”.
        </span>
      </div>

      <label for="n3-editor">Editable N3 program</label>
      <textarea id="n3-editor" spellcheck="false"></textarea>

      <div class="controls">
        <button id="run-btn">Run reasoning</button>

        <label class="toggle" title="Runs Eyeling with -p (proof comments)">
          <input id="proof-comments" type="checkbox" />
          Turn proof comments on (-p)
        </label>
        <label class="toggle" title="Rewrite http:// IRIs to https:// for log dereferencing builtins (mixed-content safe)">
          <input id="enforce-https" type="checkbox" checked />
          Enforce HTTPS for dereferencing (--enforce-https)
        </label>


        <span class="status" id="status">Idle.</span>
      </div>
    </section>

    <section class="card">
      <h2 class="section-title">Output</h2>
      <textarea id="output-editor" spellcheck="false" readonly>(no output yet)</textarea>
    </section>

      </div>
    </div>

    <div id="tab-stream" class="tab-content" role="tabpanel" aria-label="Streaming demo">
      <section class="card" style="padding: 0; overflow: hidden;">
        <div id="streamApp">
          <div class="stream-topbar">
            <input id="stream-searchBox" placeholder="Search Wikidata (e.g., René Magritte, Q7836)..." />
            <button id="stream-searchBtn">Search</button>
            <button id="stream-loadBtn" class="secondary" disabled>Load selection</button>
            <button id="stream-toyBtn" class="secondary">Load toy example</button>
            <button id="stream-clearBtn" class="secondary">Clear output</button>

            <label class="muted" style="display:flex;align-items:center;gap:6px;margin-left:4px;">
              <input type="checkbox" id="stream-clearOnRun" />clear on run
            </label>

            <label class="muted" title="Rewrite http:// IRIs to https:// for log dereferencing builtins (mixed-content safe)" style="display:flex;align-items:center;gap:6px;margin-left:4px;">
              <input type="checkbox" id="stream-enforceHttps" checked />enforce https
            </label>

            <span id="stream-eyelingVersion" class="badge" style="margin-left:auto">Eyeling</span>
            <button id="stream-reasonBtn" disabled>Reason (stream)</button>
          </div>

          <div class="stream-layout">
            <div class="stream-col">
              <section class="stream-panel">
                <h2>Wikidata browser + dataset</h2>
                <div class="content">
                  <div class="row">
                    <label title="Uses Wikidata API (origin=*) instead of EntityData .ttl, so it works under CORS">
                      <input type="checkbox" id="stream-minimalOnly" checked />
                      minimal dataset (entity-value claims + sitelinks)
                    </label>
                    <label title="If derived triples request wikiquote, fetch extract via it.wikiquote API (origin=*)">
                      <input type="checkbox" id="stream-autoFetchWikiquote" checked />
                      auto-fetch it.wikiquote extract when requested
                    </label>
                    <span class="badge" title="Default: René Magritte (Q7836)">default: Magritte</span>
                  </div>

                  <div class="muted">
                    Selected: <span id="stream-selId" class="mono">—</span>
                    <span id="stream-selLabel"></span>
                    <span id="stream-dsInfo" class="badge" style="display:none"></span>
                  </div>

                  <div class="list" id="stream-results"></div>

                  <div class="row">
                    <div class="muted" style="flex:1">Dataset preview. Full dataset opens in a pop-up.</div>
                    <button id="stream-openDatasetBtn" class="secondary" disabled>Open full dataset</button>
                  </div>
                  <textarea id="stream-dataPreview" class="preview" spellcheck="false" readonly></textarea>
                </div>
              </section>
            </div>

            <div class="stream-col">
              <section class="stream-panel">
                <h2>Streaming deductive closure</h2>
                <div class="content">
                  <div class="row">
                    <span class="status" id="stream-runStatus">Idle.</span>
                    <span class="status">Derived: <span id="stream-derivedCount">0</span></span>
                    <span class="status">Fetched facts: <span id="stream-fetchedCount">0</span></span>
                  </div>
                  <div class="out" id="stream-outBox"></div>
                </div>
              </section>

              <section class="stream-panel">
                <h2>N3 logic rules</h2>
                <div class="content">
                  <div class="muted">
                    This version avoids Wikidata TTL fetches (CORS issues) by using the Wikidata API + a small N3 conversion.
                    It also demonstrates “dynamic fetch” by turning a derived request into new facts (wikiquote extract).
                  </div>
                  <textarea id="stream-rulesBox" spellcheck="false"></textarea>
                </div>
              </section>
            </div>
          </div>

          <div class="modalBackdrop" id="stream-modalBackdrop" aria-hidden="true">
            <div class="modal" role="dialog" aria-modal="true" aria-label="Full dataset">
              <div class="modalHeader">
                <div class="title">Full dataset (Turtle/N3)</div>
                <button id="stream-modalCloseBtn" class="secondary">Close</button>
              </div>
              <div class="modalBody">
                <div class="muted">This is the full Turtle/N3 that Eyeling reasons over.</div>
                <textarea id="stream-dataFull" class="full" spellcheck="false" readonly></textarea>
              </div>
            </div>
          </div>
        </div>
      </section>
    </div>

  </div>

  <script src="eyeling.js"></script>

  <script>
    (function () {
      const defaultN3 = `# ------------------
# Socrates inference
# ------------------

@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix : <http://example.org/socrates#>.

# facts
:Socrates a :Human.
:Human rdfs:subClassOf :Mortal.

# subclass rule
{
    ?S a ?A.
    ?A rdfs:subClassOf ?B.
} => {
    ?S a ?B.
}.`;

      const inputTextArea = document.getElementById("n3-editor");
      const outputTextArea = document.getElementById("output-editor");
      const runBtn = document.getElementById("run-btn");
      const statusEl = document.getElementById("status");
      const uriInput = document.getElementById("n3-uri");
      const loadUriBtn = document.getElementById("load-uri-btn");
      const proofCheckbox = document.getElementById("proof-comments");
      const enforceHttpsCheckbox = document.getElementById("enforce-https");
      const versionEl = document.getElementById("eyeling-version");

// Persist "enforce https" toggle (default ON)
try {
  const saved = localStorage.getItem("eyeling.enforceHttps");
  if (saved !== null) enforceHttpsCheckbox.checked = saved === "1";
  enforceHttpsCheckbox.addEventListener("change", () => {
    localStorage.setItem(
      "eyeling.enforceHttps",
      enforceHttpsCheckbox.checked ? "1" : "0"
    );
  });
} catch (_) {}

      const EYELING_JS_URL =
        "https://raw.githubusercontent.com/eyereasoner/eyeling/refs/heads/main/eyeling.js";
      const EYELING_PKG_URL =
        "https://raw.githubusercontent.com/eyereasoner/eyeling/refs/heads/main/package.json";

      let eyelingVersion = "unknown";
      let versionPromise = null;

      function isSmallScreen() {
        return window.matchMedia && window.matchMedia("(max-width: 640px)").matches;
      }

      function currentMaxHeights() {
        // On mobile we cap editor/output height and allow internal scrolling
        if (!isSmallScreen()) return { editor: null, output: null };
        const h = window.innerHeight || 800;
        return {
          editor: Math.max(260, Math.floor(h * 0.55)),
          output: Math.max(160, Math.floor(h * 0.35)),
        };
      }

      function autoResizeCodeMirror(cm, minHeightPx, maxHeightPx) {
        // Ensure CodeMirror fits its *rendered* content (no internal scrollbars unless capped).
        // IMPORTANT: don't use the scroller's scrollHeight here — with overflow hidden
        // it can create a feedback loop where the editor grows a bit on every keystroke.
        cm.refresh();

        const wrapper = cm.getWrapperElement();
        const code = wrapper && wrapper.querySelector(".CodeMirror-code");
        const sizer = wrapper && wrapper.querySelector(".CodeMirror-sizer");
        const measureEl = code || sizer;

        const contentHeight = measureEl
          ? measureEl.getBoundingClientRect().height
          : cm.getScrollInfo().height;

        // Add a bit of breathing room so the last line isn't flush with the bottom.
        const padding = cm.defaultTextHeight();

        let target = Math.max(Math.ceil(contentHeight + padding), minHeightPx);
        if (typeof maxHeightPx === "number") target = Math.min(target, maxHeightPx);

        cm.setSize(null, target + "px");
      }

      function resizeAll() {
        const mh = currentMaxHeights();
        autoResizeCodeMirror(editor, 220, mh.editor);
        autoResizeCodeMirror(outputEl, 80, mh.output);
      }

      // --- INITIAL CONTENT FROM HASH OR DEFAULT ---
      function getProgramFromHash() {
        const hash = window.location.hash || "";
        if (!hash) return null;
        const raw = hash.startsWith("#") ? hash.slice(1) : hash;
        if (!raw) return null;
        try {
          return decodeURIComponent(raw);
        } catch (e) {
          return raw;
        }
      }

      // --- Prefill + auto-load "Load N3 from URL" via query string ---
      // Usage:
      //   demo?url=https://example.com/file.n3
      // Notes:
      //   - If a #fragment is present, it takes precedence (existing behavior).
      //   - When loading from ?url=..., we avoid rewriting the hash until the user edits,
      //     so you can keep sharing a clean ?url=... link.
      function getN3UriFromQuery() {
        try {
          const url = new URL(window.location.href);
          // support a few aliases, but "url" is the main one
          return (
            url.searchParams.get("url") ||
            url.searchParams.get("n3url") ||
            url.searchParams.get("n3") ||
            url.searchParams.get("load") ||
            null
          );
        } catch (e) {
          return null;
        }
      }

      const paramProgram = getProgramFromHash();
      const paramN3Uri = getN3UriFromQuery();

      if (paramN3Uri) {
        uriInput.value = paramN3Uri;
      }

      // In "URL-load mode" (no fragment, but ?url=...), don't start syncing to #hash
      // until the user actually edits the editor.
      let hashSyncEnabled = paramProgram !== null || !paramN3Uri;

      const initialN3 = paramProgram !== null ? paramProgram : defaultN3;

      // CodeMirror editors (syntax-highlighted)
      const editor = CodeMirror.fromTextArea(inputTextArea, {
        mode: { name: "sparql" },
        lineNumbers: true,
        lineWrapping: true,
        viewportMargin: Infinity,
      });

      const outputEl = CodeMirror.fromTextArea(outputTextArea, {
        mode: { name: "sparql" },
        lineNumbers: true,
        lineWrapping: true,
        readOnly: true,
        viewportMargin: Infinity,
      });

      // Slightly smaller font for output
      outputEl.getWrapperElement().classList.add("cm-output");

      // --- N3 SYNTAX ERROR HIGHLIGHTING ---
      let errorLineHandle = null;

      function clearErrorHighlight() {
        if (!errorLineHandle) return;
        editor.removeLineClass(errorLineHandle, "background", "cm-error-line");
        errorLineHandle = null;
      }

      function highlightErrorFromOutput(outputText) {
        if (!outputText) return;
        // Expected format (from eyeling.js):
        //   Syntax error in <file>:<line>:<col>: <message>
        // We parse the first line of the output to find line/col.
        const firstLine = String(outputText).split("\n", 1)[0] || "";
        let m = firstLine.match(/Syntax error in .*?:(\d+):(\d+):/);
        if (!m) m = firstLine.match(/Syntax error.*?:(\d+):(\d+)(?::|\b)/);
        if (!m) return;

        const line1 = parseInt(m[1], 10);
        const col1 = parseInt(m[2], 10);
        if (!Number.isFinite(line1) || line1 < 1) return;

        const line = line1 - 1;
        const ch = Number.isFinite(col1) && col1 > 0 ? col1 - 1 : 0;
        if (line < 0 || line >= editor.lineCount()) return;

        errorLineHandle = editor.getLineHandle(line);
        editor.addLineClass(errorLineHandle, "background", "cm-error-line");

        // Nudge the editor to the error location.
        editor.scrollIntoView({ line, ch }, 80);
        editor.setCursor({ line, ch });
      }

      editor.setValue(initialN3);
      resizeAll();

      // Recompute caps on orientation/resize
      window.addEventListener("resize", () => {
        resizeAll();
      }, { passive: true });

      // --- URL SHARING SUPPORT ---
      let shareUrlUpdateTimeout = null;

      function updateShareUrl() {
        try {
          const encoded = encodeURIComponent(editor.getValue());
          const url = new URL(window.location.href);
          url.hash = encoded;
          window.history.replaceState(null, "", url.toString());
        } catch (e) {
          console && console.warn && console.warn("Failed to update URL hash:", e);
        }
      }

      function scheduleUpdateShareUrl() {
        clearTimeout(shareUrlUpdateTimeout);
        shareUrlUpdateTimeout = setTimeout(updateShareUrl, 300);
      }

      editor.on("change", function (_cm, changeObj) {
        clearErrorHighlight();

        const mh = currentMaxHeights();
        autoResizeCodeMirror(editor, 220, mh.editor);

        if (!hashSyncEnabled) {
          // Only start syncing once the user actually edits (not programmatic setValue).
          if (changeObj && changeObj.origin && changeObj.origin !== "setValue") {
            hashSyncEnabled = true;
          } else {
            return;
          }
        }

        scheduleUpdateShareUrl();
      });

      // --- EYELING VERSION (UI + runner) ---
      function ensureEyelingVersion() {
        if (versionPromise) return versionPromise;

        versionPromise = (async () => {
          try {
            const resp = await fetch(EYELING_PKG_URL, { cache: "no-store" });
            if (!resp.ok) throw new Error("HTTP " + resp.status);
            const pkg = await resp.json();
            if (pkg && pkg.version) {
              eyelingVersion = String(pkg.version);
              versionEl.textContent = eyelingVersion;
            } else {
              eyelingVersion = "unknown";
              versionEl.textContent = "unknown";
            }
          } catch (e) {
            eyelingVersion = "unknown";
            versionEl.textContent = "unknown";
          }
        })();

        return versionPromise;
      }

      // start loading version ASAP
      ensureEyelingVersion();

      // --- EYELING RUNNER SETUP ---
      let runnerPromise = null;

      // --- EYELING WORKER SETUP (keeps UI responsive) ---
      let workerRunnerPromise = null;

      async function getEyelingWorkerRunner() {
        // Returns an object: { run(n3Text, {proof,enforceHttps}): Promise<{result,durationMs}> }
        // Falls back to null if Workers are unavailable.
        if (typeof Worker === "undefined") return null;
        if (workerRunnerPromise) return workerRunnerPromise;

        workerRunnerPromise = (async () => {
          // Ensure we have a version for the worker's ./package.json shim.
          await ensureEyelingVersion();

          const workerSource = `
            let cleanedSource = null;
            let baseVersion = "unknown";
            let initPromise = null;

            function cleanShebang(src) {
              // NOTE: This code lives inside a template literal on the main thread.
              // We need double escapes (\\n) here so the worker sees the backslash-n sequence.
              return String(src || "").replace(/^#![^\\n]*\\n/, "");
            }

            async function init(payload) {
              if (initPromise) return initPromise;
              initPromise = (async () => {
                baseVersion = payload && payload.version ? String(payload.version) : "unknown";
                const jsUrl = payload && payload.eyelingJsUrl ? String(payload.eyelingJsUrl) : "";
                if (!jsUrl) throw new Error("Missing eyelingJsUrl");

                const resp = await fetch(jsUrl);
                if (!resp.ok) throw new Error("Failed to load eyeling.js (" + resp.status + ")");
                const raw = await resp.text();
                cleanedSource = cleanShebang(raw);
              })();
              return initPromise;
            }

            function runOnce(n3Input, proof, enforceHttps, versionOverride) {
              const lines = [];

              const consoleShim = {
                log: (...args) => lines.push(args.join(" ")),
                error: (...args) => lines.push(args.join(" ")),
              };

              const fsShim = {
                readFileSync: () => n3Input,
              };

              const processShim = {
                argv: [
                  "node",
                  "eyeling.js",
                  ...(proof ? ["-p"] : []),
                  ...(enforceHttps ? ["--enforce-https"] : []),
                  "input.n3",
                ],
                exit: (code) => {
                  throw { __eyelingExit: true, code };
                },
              };

              const moduleShim = { exports: {} };

              function requireShim(id) {
                if (id === "./package.json") {
                  return { version: (versionOverride || baseVersion || "unknown") };
                }
                if (id === "fs") return fsShim;
                if (id === "crypto") {
                  return {
                    createHash: () => ({
                      update: () => {},
                      digest: () => "",
                    }),
                  };
                }
                return {};
              }

              // Make eyeling think this is the main module so main() runs.
              requireShim.main = moduleShim;

              try {
                const fn = new Function(
                  "require",
                  "module",
                  "exports",
                  "process",
                  "console",
                  cleanedSource
                );
                fn(requireShim, moduleShim, moduleShim.exports, processShim, consoleShim);
              } catch (e) {
                if (!e || !e.__eyelingExit) {
                  lines.push(
                    "JavaScript error: " + (e && e.message ? e.message : String(e))
                  );
                }
              }

              return lines.join("\\n");
            }

            const pending = new Map();

            function resolvePending(id, payload) {
              const p = pending.get(id);
              if (!p) return;
              pending.delete(id);
              p.resolve(payload);
            }

            function rejectPending(id, err) {
              const p = pending.get(id);
              if (!p) return;
              pending.delete(id);
              p.reject(err);
            }

            self.onmessage = async (ev) => {
              const msg = ev && ev.data ? ev.data : {};
              try {
                if (msg.type === "init") {
                  await init(msg);
                  self.postMessage({ type: "inited" });
                  return;
                }
                if (msg.type === "run") {
                  if (!initPromise) {
                    // If caller forgot init, try a best-effort init.
                    await init(msg);
                  } else {
                    await initPromise;
                  }

                  const t0 = self.performance && performance.now ? performance.now() : Date.now();
                  const result = runOnce(
                    msg.n3Input || "",
                    !!msg.proof,
                    !!msg.enforceHttps,
                    msg.version || baseVersion
                  );
                  const t1 = self.performance && performance.now ? performance.now() : Date.now();

                  self.postMessage({
                    type: "result",
                    id: msg.id,
                    result,
                    durationMs: Math.max(0, t1 - t0),
                  });
                  return;
                }
              } catch (e) {
                const errText = e && e.message ? e.message : String(e);

                if (msg && msg.type === "run" && msg.id != null) {
                  self.postMessage({
                    type: "result",
                    id: msg.id,
                    error: errText,
                    durationMs: 0,
                  });
                  return;
                }
                self.postMessage({ type: "initError", error: errText });
              }
            };
          `;

          const blob = new Blob([workerSource], { type: "text/javascript" });
          const url = URL.createObjectURL(blob);
          const worker = new Worker(url);

          let nextId = 1;
          const pending = new Map();

          function failAll(err) {
            for (const [id, p] of pending.entries()) {
              pending.delete(id);
              p.reject(err);
            }
          }

          worker.addEventListener("message", (ev) => {
            const msg = ev && ev.data ? ev.data : {};
            if (msg.type === "inited") {
              return;
            }
            if (msg.type === "initError") {
              failAll(new Error(msg.error || "Worker init failed"));
              return;
            }
            if (msg.type === "result") {
              const p = pending.get(msg.id);
              if (!p) return;
              pending.delete(msg.id);

              if (msg.error) {
                p.reject(new Error(msg.error));
              } else {
                p.resolve({
                  result: msg.result || "",
                  durationMs: typeof msg.durationMs === "number" ? msg.durationMs : 0,
                });
              }
            }
          });

          worker.addEventListener("error", (ev) => {
            const err = new Error(
              "Worker error: " + (ev && ev.message ? ev.message : "unknown")
            );
            failAll(err);
          });

          // Wait for init confirmation.
          const initAck = new Promise((resolve, reject) => {
            function onMessage(ev) {
              const msg = ev && ev.data ? ev.data : {};
              if (msg.type === "inited") {
                worker.removeEventListener("message", onMessage);
                worker.removeEventListener("message", onInitError);
                resolve();
              }
            }
            function onInitError(ev) {
              const msg = ev && ev.data ? ev.data : {};
              if (msg.type === "initError") {
                worker.removeEventListener("message", onMessage);
                worker.removeEventListener("message", onInitError);
                reject(new Error(msg.error || "Worker init failed"));
              }
            }
            worker.addEventListener("message", onMessage);
            worker.addEventListener("message", onInitError);
          });

          worker.postMessage({
            type: "init",
            eyelingJsUrl: EYELING_JS_URL,
            version: eyelingVersion || "unknown",
          });

          await initAck;

          // Now that the worker has loaded the Blob source, we can revoke the URL.
          URL.revokeObjectURL(url);

          return {
            run: (n3Input, opts) => {
              const id = nextId++;
              const proof = !!(opts && opts.proof);
              const enforceHttps = !!(opts && opts.enforceHttps);

              return new Promise((resolve, reject) => {
                pending.set(id, { resolve, reject });
                worker.postMessage({
                  type: "run",
                  id,
                  n3Input: String(n3Input || ""),
                  proof,
                  enforceHttps,
                  version: eyelingVersion || "unknown",
                });
              });
            },
          };
        })();

        return workerRunnerPromise;
      }

      async function getEyelingRunner() {
        if (runnerPromise) return runnerPromise;

        runnerPromise = (async () => {
          // Make sure version is known (so require("./package.json") can match UI)
          await ensureEyelingVersion();

          const resp = await fetch(EYELING_JS_URL);
          if (!resp.ok) {
            throw new Error("Failed to load eyeling.js (" + resp.status + ")");
          }

          const rawSource = await resp.text();
          const cleanedSource = rawSource.replace(/^#![^\n]*\n/, "");

          // Build a function that runs eyeling as a CLI once, given N3 text.
          function runOnce(n3Input) {
            const lines = [];

            const consoleShim = {
              log: (...args) => lines.push(args.join(" ")),
              error: (...args) => lines.push(args.join(" ")),
            };

            const fsShim = {
              readFileSync: () => n3Input,
            };

            const processShim = {
              // Simulate: node eyeling.js [-n] input.n3
              argv: [
                "node",
                "eyeling.js",
                ...(proofCheckbox.checked ? ["-p"] : []),
                ...(enforceHttpsCheckbox.checked ? ["--enforce-https"] : []),
                "input.n3",
              ],
              exit: (code) => {
                throw { __eyelingExit: true, code };
              },
            };

            const moduleShim = { exports: {} };

            function requireShim(id) {
              if (id === "./package.json") {
                return { version: eyelingVersion || "unknown" };
              }
              if (id === "fs") return fsShim;
              if (id === "crypto") {
                // Minimal stub – enough for examples that don't depend on crypto.
                return {
                  createHash: () => ({
                    update: () => {},
                    digest: () => "",
                  }),
                };
              }
              return {};
            }

            // Make eyeling think this is the main module so main() runs.
            requireShim.main = moduleShim;

            try {
              const fn = new Function(
                "require",
                "module",
                "exports",
                "process",
                "console",
                cleanedSource
              );
              fn(requireShim, moduleShim, moduleShim.exports, processShim, consoleShim);
            } catch (e) {
              if (!e || !e.__eyelingExit) {
                lines.push(
                  "JavaScript error: " + (e && e.message ? e.message : String(e))
                );
              }
            }

            return lines.join("\n");
          }

          return runOnce;
        })();

        return runnerPromise;
      }

      async function runReasoner() {
        runBtn.disabled = true;
        clearErrorHighlight();

        const startMs = performance.now();
        statusEl.textContent = "Running reasoning...";

        // Clear output immediately.
        const setThinking = () => {
          const mh = currentMaxHeights();
          outputEl.setValue(`Thinking ...`);
          autoResizeCodeMirror(outputEl, 80, mh.output);
        };

        setThinking();

        if (hashSyncEnabled) updateShareUrl();

        // Let the browser paint before we do anything potentially expensive.
        await new Promise(requestAnimationFrame);

        let thinkingInterval = setInterval(setThinking, 100);

        try {
          // Prefer Web Worker to avoid freezing the UI.
          // If the worker fails to initialize for any reason, fall back to the main-thread runner.
          let workerRunner = null;
          try {
            workerRunner = await getEyelingWorkerRunner();
          } catch (_e) {
            workerRunner = null;
          }

          // One more chance to paint before any heavy work begins.
          await new Promise(requestAnimationFrame);

          let result = "";
          let durationMs = null;

          if (workerRunner) {
            const out = await workerRunner.run(editor.getValue(), {
              proof: proofCheckbox.checked,
              enforceHttps: enforceHttpsCheckbox.checked,
            });
            result = out && typeof out.result === "string" ? out.result : "";
            durationMs = out && typeof out.durationMs === "number" ? out.durationMs : null;
          } else {
            // Fallback for environments without Workers.
            const runner = await getEyelingRunner();
            result = runner(editor.getValue());
          }

          clearInterval(thinkingInterval);
          thinkingInterval = null;

          {
            const mh = currentMaxHeights();
            outputEl.setValue(result || "(no output)");
            highlightErrorFromOutput(result);
            autoResizeCodeMirror(outputEl, 80, mh.output);
          }

          const totalSeconds = (performance.now() - startMs) / 1000;
          const workerSeconds = durationMs != null ? durationMs / 1000 : null;
          statusEl.textContent = workerSeconds != null
            ? `Done. (Worker time: ${workerSeconds.toFixed(2)}s, total: ${totalSeconds.toFixed(2)}s)`
            : `Done. (Thinking for ${totalSeconds.toFixed(2)} seconds)`;
        } catch (e) {
          if (thinkingInterval) {
            clearInterval(thinkingInterval);
            thinkingInterval = null;
          }

          {
            const mh = currentMaxHeights();
            outputEl.setValue(
              "Failed to run Eyeling: " + (e && e.message ? e.message : String(e))
            );
            autoResizeCodeMirror(outputEl, 80, mh.output);
          }

          statusEl.textContent = "Error.";
        } finally {
          if (thinkingInterval) {
            clearInterval(thinkingInterval);
            thinkingInterval = null;
          }
          runBtn.disabled = false;
        }
      }

      async function loadFromUri() {
        const uri = uriInput.value.trim();
        if (!uri) return;

        loadUriBtn.disabled = true;
        statusEl.textContent = "Loading N3 from URL...";
        try {
          const resp = await fetch(uri);
          if (!resp.ok) {
            throw new Error("HTTP " + resp.status + " when fetching " + uri);
          }
          const text = await resp.text();
          editor.setValue(text);
          clearErrorHighlight();

          {
            const mh = currentMaxHeights();
            autoResizeCodeMirror(editor, 220, mh.editor);
          }

          statusEl.textContent = "Loaded N3 from URL.";
          if (hashSyncEnabled) updateShareUrl();
        } catch (e) {
          statusEl.textContent = "Failed to load URL.";

          {
            const mh = currentMaxHeights();
            outputEl.setValue(
              "Error while loading N3 from URL:\n" +
              (e && e.message ? e.message : String(e))
            );
            autoResizeCodeMirror(outputEl, 80, mh.output);
          }
        } finally {
          loadUriBtn.disabled = false;
        }
      }

      runBtn.addEventListener("click", runReasoner);
      loadUriBtn.addEventListener("click", loadFromUri);

      // Initialize URL hash with whatever we started with (unless we're in URL-load mode)
      if (hashSyncEnabled) updateShareUrl();

      // If ?url=... is present (and there's no #fragment), auto-load it.
      if (paramN3Uri && paramProgram === null) {
        loadFromUri();
      }
    })();
  </script>

  <script>
    (function () {
      const TAB_KEY = "eyeling.demo.activeTab";
      const tabButtons = Array.from(document.querySelectorAll(".tab-btn"));
      const tabPlay = document.getElementById("tab-playground");
      const tabStream = document.getElementById("tab-stream");

      function setSelected(tabName) {
        const isStream = tabName === "stream";

        tabPlay.classList.toggle("is-active", !isStream);
        tabStream.classList.toggle("is-active", isStream);

        for (const btn of tabButtons) {
          const selected = btn.dataset.tab === tabName;
          btn.setAttribute("aria-selected", selected ? "true" : "false");
        }

        try { localStorage.setItem(TAB_KEY, tabName); } catch (_) {}

        if (isStream && !window.__eyelingStreamInited) {
          window.__eyelingStreamInited = true;
          initStreamApp();
        }
      }

      function initialTab() {
        try {
          const u = new URL(window.location.href);
          const q = (u.searchParams.get("tab") || "").toLowerCase();
          if (q === "stream") return "stream";
          if (q === "playground") return "playground";
        } catch (_) {}
        try {
          const saved = localStorage.getItem(TAB_KEY);
          if (saved === "stream" || saved === "playground") return saved;
        } catch (_) {}
        return "playground";
      }

      for (const btn of tabButtons) {
        btn.addEventListener("click", () => setSelected(btn.dataset.tab));
      }

      setSelected(initialTab());

      // ---------------------------
      // STREAM APP (lazy-initialized)
      // ---------------------------
      function initStreamApp() {
        const P = "stream-";
        const $ = (id) => document.getElementById(P + id);

        const DEFAULT_RULES = `# Eyeling rules (CORS-safe “dynamic fetch” demo)
@prefix wd: <http://www.wikidata.org/entity/> .
@prefix wdt: <http://www.wikidata.org/prop/direct/> .
@prefix wikibase: <http://wikiba.se/ontology#> .
@prefix schema: <http://schema.org/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix : <http://example.org/> .

# Basic typing lift
{ ?x wdt:P31 ?c } => { ?x a ?c } .
{ ?c wdt:P279 ?d } => { ?c rdfs:subClassOf ?d } .
{ ?a rdfs:subClassOf ?b . ?b rdfs:subClassOf ?c } => { ?a rdfs:subClassOf ?c } .
{ ?x a ?c . ?c rdfs:subClassOf ?d } => { ?x a ?d } .

# Find the Italian Wikiquote sitelink for an item and *request* a fetch.
# (This avoids log:content / web fetching inside N3.)
{ ?article a schema:Article ;
          schema:about ?item ;
          schema:isPartOf <https://it.wikiquote.org/> ;
          schema:name ?title .
} => { ?item :needsWikiquoteExtract ?title } .

# If we later inject :wikiquoteExtract facts, tag the item as having quotes.
{ ?item :wikiquoteExtract ?txt } => { ?item :hasWikiquote true } .
`;

        const TOY_DATA = `@prefix wd: <http://www.wikidata.org/entity/> .
@prefix wdt: <http://www.wikidata.org/prop/direct/> .
@prefix schema: <http://schema.org/> .
@prefix : <http://example.org/> .

wd:Q7836 wdt:P31 wd:Q5 .
<https://it.wikiquote.org/wiki/Ren%C3%A9_Magritte> a schema:Article ;
  schema:about wd:Q7836 ;
  schema:isPartOf <https://it.wikiquote.org/> ;
  schema:name "René Magritte" .
`;

        const MAGRITTE_LABEL = "René Magritte";
        const MAGRITTE_QID = "Q7836";
        const PREVIEW_LINES = 220;

        // CodeMirror (syntax highlighted) for the rules pane
        const rulesCM = CodeMirror.fromTextArea($("rulesBox"), {
          mode: { name: "sparql" },
          lineNumbers: true,
          lineWrapping: true,
          viewportMargin: Infinity,
        });
        rulesCM.setValue(DEFAULT_RULES);

        // Make it behave like a resizable textarea
        const wrap = rulesCM.getWrapperElement();
        wrap.style.height = "min(42vh, 420px)";
        wrap.style.minHeight = "240px";
        wrap.style.resize = "vertical";
        wrap.style.overflow = "hidden";

        // ---------- Shared enforce-https toggle ----------
        const demoEnforce = document.getElementById("enforce-https");
        const streamEnforce = $("enforceHttps");

        function readEnforceHttpsDefault() {
          let v = true;
          try {
            const saved = localStorage.getItem("eyeling.enforceHttps");
            if (saved !== null) v = saved === "1";
          } catch (_) {}
          return v;
        }

        function setAllEnforceHttps(val) {
          if (demoEnforce) demoEnforce.checked = !!val;
          if (streamEnforce) streamEnforce.checked = !!val;
          try { localStorage.setItem("eyeling.enforceHttps", val ? "1" : "0"); } catch (_) {}
        }

        setAllEnforceHttps(readEnforceHttpsDefault());
        if (streamEnforce) streamEnforce.addEventListener("change", () => setAllEnforceHttps(streamEnforce.checked));
        if (demoEnforce) demoEnforce.addEventListener("change", () => setAllEnforceHttps(demoEnforce.checked));

        async function showEyelingVersion() {
          const el = $("eyelingVersion");
          if (!el) return;

          const v = (window.eyeling && (window.eyeling.version || window.eyeling.VERSION)) || null;
          if (v) { el.textContent = `Eyeling v${v}`; return; }

          try {
            const res = await fetch("./package.json", { cache: "no-store" });
            if (res.ok) {
              const j = await res.json();
              if (j && j.version) { el.textContent = `Eyeling v${j.version}`; return; }
            }
          } catch (_) {}

          el.textContent = "Eyeling (version ?)";
        }

        let selected = null;
        let worker = null;
        let runId = 0;
        let isRunning = false;
        let lastSelectedDiv = null;
        let resultDivById = new Map();

        let datasetN3 = "";
        let fetchedFacts = new Set();
        let shownDerived = new Set();

        function updateButtons() {
          const hasSelection = !!selected;
          const hasData = !!datasetN3.trim();
          $("loadBtn").disabled = isRunning || !hasSelection;
          $("reasonBtn").disabled = isRunning || !hasData;
          $("openDatasetBtn").disabled = !hasData;
        }

        function setStatus(text) { $("runStatus").textContent = text; }
        function clearOutput() {
          $("outBox").textContent = `# Derived triples (streaming):\n`;
          $("derivedCount").textContent = "0";
          shownDerived.clear();
        }

        function addRunHeader(tag) {
          const stamp = new Date().toLocaleString();
          $("outBox").textContent += `\n# ---- ${tag} @ ${stamp} ----\n`;
        }

        function appendTriples(triples) {
          const out = [];
          for (const t of triples) {
            if (shownDerived.has(t)) continue;
            shownDerived.add(t);
            out.push(t);
          }
          if (!out.length) return;
          $("outBox").textContent += out.join("\n") + "\n";
          $("derivedCount").textContent = String(shownDerived.size);
        }

        function setDataset(text) {
          datasetN3 = text || "";
          const lines = datasetN3.split(/\r?\n/);
          const shown = lines.slice(0, PREVIEW_LINES).join("\n");
          const suffix = lines.length > PREVIEW_LINES
            ? `\n\n# … (${lines.length - PREVIEW_LINES} more lines hidden; click "Open full dataset")`
            : "";
          $("dataPreview").value = shown + suffix;
          $("dataFull").value = datasetN3;

          const bytes = new Blob([datasetN3]).size;
          const kb = Math.round(bytes / 1024);
          const info = `${lines.length.toLocaleString()} lines · ~${kb.toLocaleString()} KB`;
          const badge = $("dsInfo");
          badge.style.display = datasetN3 ? "inline-block" : "none";
          badge.textContent = info;

          $("fetchedCount").textContent = String(fetchedFacts.size);
          updateButtons();
        }

        function addFactN3(tripleLine) {
          const key = tripleLine.trim();
          if (!key) return false;
          if (fetchedFacts.has(key)) return false;
          fetchedFacts.add(key);
          datasetN3 += "\n" + key + "\n";
          setDataset(datasetN3);
          return true;
        }

        const WD_API = "https://www.wikidata.org/w/api.php";

        async function wdSearch(query) {
          const url = `${WD_API}?action=wbsearchentities&format=json&language=en&limit=10&origin=*&search=${encodeURIComponent(query)}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`Wikidata search failed: HTTP ${res.status}`);
          const json = await res.json();
          return (json.search || []).map(x => ({
            id: x.id,
            label: x.label || x.id,
            description: x.description || ""
          }));
        }

        async function wbGetEntities(ids) {
          const url = `${WD_API}?action=wbgetentities&format=json&origin=*&ids=${encodeURIComponent(ids.join("|"))}&props=claims|sitelinks|labels`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`wbgetentities failed: HTTP ${res.status}`);
          return await res.json();
        }

        function escLiteral(s) {
          const t = String(s).replace(/\\/g, "\\\\").replace(/"""/g, '\\"""');
          return '"""' + t + '"""';
        }

        function qidToIri(id) {
          if (/^Q\d+$/.test(id)) return `wd:${id}`;
          if (/^P\d+$/.test(id)) return `wd:${id}`;
          return null;
        }

        function siteToBaseUrl(site) {
          const mWq = site.match(/^([a-z-]+)wikiquote$/);
          if (mWq) return `https://${mWq[1]}.wikiquote.org/wiki/`;
          const mWp = site.match(/^([a-z-]+)wiki$/);
          if (mWp) return `https://${mWp[1]}.wikipedia.org/wiki/`;
          if (site === "commonswiki") return "https://commons.wikimedia.org/wiki/";
          return null;
        }

        function n3PfxHeader() {
          return [
            "@prefix wd: <http://www.wikidata.org/entity/> .",
            "@prefix wdt: <http://www.wikidata.org/prop/direct/> .",
            "@prefix wikibase: <http://wikiba.se/ontology#> .",
            "@prefix schema: <http://schema.org/> .",
            "@prefix : <http://example.org/> .",
            "",
          ].join("\n");
        }

        function entityJsonToMinimalN3(entity, minimalOnly) {
          const lines = [];
          const eid = entity.id;
          lines.push(`${qidToIri(eid)} a wikibase:${entity.type === "property" ? "Property" : "Item"} .`);

          const claims = entity.claims || {};
          for (const pid of Object.keys(claims)) {
            const stmts = claims[pid] || [];
            for (const st of stmts) {
              const mainsnak = st.mainsnak;
              if (!mainsnak || mainsnak.snaktype !== "value") continue;
              const dv = mainsnak.datavalue;
              if (!dv) continue;

              const subj = qidToIri(eid);
              const pred = `wdt:${pid}`;

              if (dv.type === "wikibase-entityid") {
                const valId = dv.value && dv.value.id;
                const obj = qidToIri(valId);
                if (!obj) continue;
                lines.push(`${subj} ${pred} ${obj} .`);
              } else if (!minimalOnly && dv.type === "string") {
                lines.push(`${subj} ${pred} ${escLiteral(dv.value)} .`);
              }
            }
          }

          const sitelinks = entity.sitelinks || {};
          for (const site of Object.keys(sitelinks)) {
            const base = siteToBaseUrl(site);
            if (!base) continue;
            const title = sitelinks[site].title;
            if (!title) continue;

            const urlTitle = encodeURIComponent(title.replace(/ /g, "_"));
            const articleUrl = `<${base}${urlTitle}>`;

            const isPartOf =
              site.endsWith("wikiquote") ? `<https://${site.replace("wikiquote", "")}.wikiquote.org/>` :
              site.endsWith("wiki") ? `<https://${site.replace("wiki", "")}.wikipedia.org/>` :
              null;

            lines.push(
              `${articleUrl} a schema:Article ; schema:about ${qidToIri(eid)} ;` +
              (isPartOf ? ` schema:isPartOf ${isPartOf} ;` : "") +
              ` schema:name ${escLiteral(title)} .`
            );
          }

          return lines.join("\n");
        }

        async function fetchItWikiquoteExtract(title) {
          const url = `https://it.wikiquote.org/w/api.php?action=query&prop=extracts&explaintext=1&exsectionformat=plain&format=json&origin=*&titles=${encodeURIComponent(title)}`;
          const res = await fetch(url);
          if (!res.ok) throw new Error(`wikiquote API failed: HTTP ${res.status}`);
          const j = await res.json();
          const pages = j && j.query && j.query.pages ? Object.values(j.query.pages) : [];
          const page = pages[0] || {};
          return page.extract || "";
        }

        function ensureWorker() {
          if (worker) worker.terminate();

          const workerSrc = `
            importScripts('eyeling.js');
            self.onmessage = (ev) => {
              const { runId, dataN3, rulesN3, enforceHttps } = ev.data;
              let buffer = [];
              const FLUSH_EVERY = 4;

              try {
                const program = rulesN3 + "\\n\\n" + dataN3;

                self.eyeling.reasonStream(program, {
                  enforceHttps: !!enforceHttps,
                  onDerived: ({ triple }) => {
                    buffer.push(triple);
                    if (buffer.length >= FLUSH_EVERY) {
                      self.postMessage({ runId, type: 'derived_batch', triples: buffer });
                      buffer = [];
                    }
                  }
                });

                if (buffer.length) self.postMessage({ runId, type: 'derived_batch', triples: buffer });
                self.postMessage({ runId, type: 'done' });
              } catch (e) {
                self.postMessage({ runId, type: 'error', message: (e && e.message) ? e.message : String(e) });
              }
            };
          `;

          const blob = new Blob([workerSrc], { type: "text/javascript" });
          worker = new Worker(URL.createObjectURL(blob));
          return worker;
        }

        function runReasoningMainThread(program) {
          if (!window.eyeling || !window.eyeling.reasonStream) {
            throw new Error("Eyeling not loaded. Ensure eyeling.js exposes window.eyeling.reasonStream.");
          }

          const triples = [];
          window.eyeling.reasonStream(program, {
            enforceHttps: !!streamEnforce?.checked,
            onDerived: ({ triple }) => triples.push(triple),
          });
          appendTriples(triples);
        }

        let rerunTimer = null;
        function scheduleRerun() {
          if (rerunTimer) return;
          rerunTimer = setTimeout(() => {
            rerunTimer = null;
            addRunHeader("Auto re-run (after fetch)");
            runReasoning();
          }, 250);
        }

        async function maybeHandleDynamicFetch(triples) {
          if (!$("autoFetchWikiquote").checked) return;

          for (const t of triples) {
            if (!t.includes("needsWikiquoteExtract")) continue;

            const m = t.match(/^(\S+)\s+(\S+)\s+(.+)\s*\.\s*$/);
            if (!m) continue;
            const subj = m[1], pred = m[2], obj = m[3];

            if (!pred.includes("needsWikiquoteExtract")) continue;
            if (!/^wd:Q\d+$/.test(subj)) continue;

            let title = null;
            const mLong = obj.match(/^"""\s*([\s\S]*?)\s*"""\s*$/);
            if (mLong) title = mLong[1];
            else {
              const mShort = obj.match(/^"([^"]*)"/);
              if (mShort) title = mShort[1];
            }
            if (!title) continue;

            try {
              setStatus(`Fetching it.wikiquote extract for ${subj}…`);
              const extract = await fetchItWikiquoteExtract(title);
              if (!extract) {
                setStatus(`No extract found on it.wikiquote for "${title}".`);
                continue;
              }
              const capped = extract.length > 2000 ? (extract.slice(0, 2000) + "…") : extract;
              const fact = `${subj} <http://example.org/wikiquoteExtract> ${escLiteral(capped)} .`;
              const added = addFactN3(fact);
              if (added) {
                $("fetchedCount").textContent = String(fetchedFacts.size);
                setStatus("Fetched wikiquote extract and added as fact; re-running reasoning…");
                scheduleRerun();
              }
            } catch (e) {
              setStatus(`Wikiquote fetch failed: ${e.message || e}`);
            }
          }
        }

        function runReasoning() {
          const rules = rulesCM.getValue();
          if (!datasetN3.trim() || !rules.trim()) return;

          isRunning = true;
          updateButtons();
          setStatus("Reasoning (streaming)…");

          const supportsWorker = (typeof Worker !== "undefined");

          if (supportsWorker) {
            const w = ensureWorker();
            const thisRun = ++runId;

            w.onmessage = async (ev) => {
              const msg = ev.data;
              if (msg.runId !== thisRun) return;

              if (msg.type === "derived_batch") {
                appendTriples(msg.triples);
                await maybeHandleDynamicFetch(msg.triples);
              } else if (msg.type === "done") {
                setStatus(`Done. (Run ${thisRun})`);
                isRunning = false;
                updateButtons();
              } else if (msg.type === "error") {
                setStatus(`Reasoning error: ${msg.message}`);
                isRunning = false;
                updateButtons();
              }
            };

            w.onerror = () => {
              try {
                setStatus("Worker error; falling back to main-thread run…");
                runReasoningMainThread(rules + "\n\n" + datasetN3);
                setStatus("Done (fallback).");
              } catch (err) {
                setStatus(`Reasoning error: ${err.message || err}`);
              } finally {
                isRunning = false;
                updateButtons();
              }
            };

            w.postMessage({ runId: thisRun, dataN3: datasetN3, rulesN3: rules, enforceHttps: !!streamEnforce?.checked });
            return;
          }

          try {
            runReasoningMainThread(rules + "\n\n" + datasetN3);
            setStatus("Done (no worker).");
          } catch (e) {
            setStatus(`Reasoning error: ${e.message || e}`);
          } finally {
            isRunning = false;
            updateButtons();
          }
        }

        function selectResult(r, div) {
          selected = r;
          $("selId").textContent = r.id;
          $("selLabel").textContent = ` — ${r.label}`;

          if (lastSelectedDiv) lastSelectedDiv.classList.remove("selected");
          if (div) { div.classList.add("selected"); lastSelectedDiv = div; }
          else { lastSelectedDiv = null; }

          updateButtons();
        }

        async function doSearch() {
          const q = $("searchBox").value.trim();
          if (!q) return [];

          $("results").innerHTML = "";
          resultDivById = new Map();
          selected = null;
          $("selId").textContent = "—";
          $("selLabel").textContent = "";
          lastSelectedDiv = null;
          setStatus("Searching…");
          updateButtons();

          try {
            const results = await wdSearch(q);
            setStatus(`Found ${results.length} result(s). Click one, then “Load selection”.`);

            for (const r of results) {
              const div = document.createElement("div");
              div.className = "item";
              div.innerHTML = `<div class="mono">${r.id}</div><div style="font-weight:800">${r.label}</div><div class="muted">${r.description}</div>`;
              div.onclick = () => selectResult(r, div);
              $("results").appendChild(div);
              resultDivById.set(r.id, div);
            }

            updateButtons();
            return results;
          } catch (e) {
            setStatus(`Search error: ${e.message || e}`);
            updateButtons();
            return [];
          }
        }

        async function loadSelection() {
          if (!selected) return;

          isRunning = true;
          updateButtons();
          setStatus(`Loading ${selected.id} (via Wikidata API)…`);

          try {
            fetchedFacts = new Set();
            $("fetchedCount").textContent = "0";

            const json = await wbGetEntities([selected.id]);
            const ent = json && json.entities && json.entities[selected.id];
            if (!ent) throw new Error(`No entity data returned for ${selected.id}`);

            const minimalOnly = $("minimalOnly").checked;
            const n3 = n3PfxHeader() + entityJsonToMinimalN3(ent, minimalOnly);

            setDataset(n3);
            setStatus(`Loaded ${selected.id}. Ready to reason.`);
          } catch (e) {
            setStatus(`Load error: ${e.message || e}`);
          } finally {
            isRunning = false;
            updateButtons();
          }
        }

        function loadToy() {
          selected = null;
          if (lastSelectedDiv) { lastSelectedDiv.classList.remove("selected"); lastSelectedDiv = null; }
          $("selId").textContent = "toy";
          $("selLabel").textContent = " — local demo data";
          fetchedFacts = new Set();
          $("fetchedCount").textContent = "0";
          setDataset(TOY_DATA);
          setStatus("Toy example loaded. Ready to reason.");
          updateButtons();
        }

        function openModal() {
          $("modalBackdrop").style.display = "flex";
          $("modalBackdrop").setAttribute("aria-hidden", "false");
        }
        function closeModal() {
          $("modalBackdrop").style.display = "none";
          $("modalBackdrop").setAttribute("aria-hidden", "true");
        }

        $("openDatasetBtn").onclick = openModal;
        $("modalCloseBtn").onclick = closeModal;
        $("modalBackdrop").addEventListener("click", (e) => { if (e.target === $("modalBackdrop")) closeModal(); });
        window.addEventListener("keydown", (e) => { if (e.key === "Escape") closeModal(); });

        $("searchBtn").onclick = doSearch;
        $("loadBtn").onclick = loadSelection;
        $("toyBtn").onclick = () => { loadToy(); setTimeout(() => { if ($("clearOnRun").checked) clearOutput(); addRunHeader("Toy run"); runReasoning(); }, 60); };
        $("clearBtn").onclick = () => { clearOutput(); setStatus("Cleared."); };
        $("reasonBtn").onclick = () => { if ($("clearOnRun").checked) clearOutput(); addRunHeader("Manual run"); runReasoning(); };

        $("searchBox").addEventListener("keydown", (e) => { if (e.key === "Enter") doSearch(); });

        async function loadDefaultMagritte() {
          $("searchBox").value = MAGRITTE_LABEL;
          const results = await doSearch();
          const target = results.find(r => r.id === MAGRITTE_QID) || results[0];
          if (!target) return;
          const div = resultDivById.get(target.id);
          selectResult(target, div);
          await loadSelection();
          setTimeout(() => { if ($("clearOnRun").checked) clearOutput(); addRunHeader("Auto run (default)"); runReasoning(); }, 80);
        }

        // Initial view
        clearOutput();
        showEyelingVersion()
          .then(loadDefaultMagritte)
          .catch((e) => {
            setStatus(`Default load failed (${e.message || e}). Loading toy example instead…`);
            loadToy();
            setTimeout(() => { if ($("clearOnRun").checked) clearOutput(); addRunHeader("Auto run (toy fallback)"); runReasoning(); }, 60);
          });

        setTimeout(() => { try { rulesCM.refresh(); } catch (_) {} }, 60);
      }
    })();
  </script>

</body>
</html>

