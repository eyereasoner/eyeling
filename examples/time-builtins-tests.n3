# time-builtins-tests.n3
#
# Tests for the W3C Notation3 time: builtins (ยง4.3)
# against the eyeling.js reasoner.
#
# Running:
#   node eyeling.js time-builtins-tests.n3
#
# Each rule adds a :TimeBuiltinTest instance with :status :pass
# iff the builtin behaves as in the 2023-07-03 W3C N3 builtins report
# for the given input.

@prefix :       <http://example.org/time-tests#> .
@prefix time:   <http://www.w3.org/2000/10/swap/time#> .
@prefix xsd:    <http://www.w3.org/2001/XMLSchema#> .
@prefix log:    <http://www.w3.org/2000/10/swap/log#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .

:TimeBuiltinTest a :TestKind .

################################################################
# Shared example dateTimes (from the W3C docs / similar style)
################################################################

# dt1: Example with Z timezone
:dt1-value
  :lexical "2023-04-01T18:06:04Z"^^xsd:dateTime .

# dt2: End-of-year example (also Z)
:dt2-value
  :lexical "1999-12-31T23:59:59Z"^^xsd:dateTime .

# dt3: Positive timezone offset
:dt3-value
  :lexical "2025-01-01T00:00:00+02:00"^^xsd:dateTime .

# dt4: Negative timezone offset with minutes
:dt4-value
  :lexical "2025-01-01T00:00:00-05:30"^^xsd:dateTime .

################################################################
# 4.3.1 time:day
################################################################

# time:day("2023-04-01T18:06:04Z") = 1
{
  :dt1-value :lexical ?dt .
  ?dt time:day ?d .
  ?d  math:equalTo "1"^^xsd:integer .
}
=>
{
  :t-time-day-01
    a :TimeBuiltinTest ;
    :builtin   time:day ;
    :input     ?dt ;
    :expected  "1"^^xsd:integer ;
    :actual    ?d ;
    :status    :pass .
} .

# time:day("1999-12-31T23:59:59Z") = 31
{
  :dt2-value :lexical ?dt .
  ?dt time:day ?d .
  ?d  math:equalTo "31"^^xsd:integer .
}
=>
{
  :t-time-day-02
    a :TimeBuiltinTest ;
    :builtin   time:day ;
    :input     ?dt ;
    :expected  "31"^^xsd:integer ;
    :actual    ?d ;
    :status    :pass .
} .

################################################################
# 4.3.2 time:month
################################################################

# time:month("2023-04-01T18:06:04Z") = 4
{
  :dt1-value :lexical ?dt .
  ?dt time:month ?m .
  ?m  math:equalTo "4"^^xsd:integer .
}
=>
{
  :t-time-month-01
    a :TimeBuiltinTest ;
    :builtin   time:month ;
    :input     ?dt ;
    :expected  "4"^^xsd:integer ;
    :actual    ?m ;
    :status    :pass .
} .

# time:month("1999-12-31T23:59:59Z") = 12
{
  :dt2-value :lexical ?dt .
  ?dt time:month ?m .
  ?m  math:equalTo "12"^^xsd:integer .
}
=>
{
  :t-time-month-02
    a :TimeBuiltinTest ;
    :builtin   time:month ;
    :input     ?dt ;
    :expected  "12"^^xsd:integer ;
    :actual    ?m ;
    :status    :pass .
} .

################################################################
# 4.3.3 time:year
################################################################

# time:year("2023-04-01T18:06:04Z") = 2023
{
  :dt1-value :lexical ?dt .
  ?dt time:year ?y .
  ?y  math:equalTo "2023"^^xsd:integer .
}
=>
{
  :t-time-year-01
    a :TimeBuiltinTest ;
    :builtin   time:year ;
    :input     ?dt ;
    :expected  "2023"^^xsd:integer ;
    :actual    ?y ;
    :status    :pass .
} .

# time:year("1999-12-31T23:59:59Z") = 1999
{
  :dt2-value :lexical ?dt .
  ?dt time:year ?y .
  ?y  math:equalTo "1999"^^xsd:integer .
}
=>
{
  :t-time-year-02
    a :TimeBuiltinTest ;
    :builtin   time:year ;
    :input     ?dt ;
    :expected  "1999"^^xsd:integer ;
    :actual    ?y ;
    :status    :pass .
} .

################################################################
# 4.3.4 time:minute
################################################################

# time:minute("2023-04-01T18:06:04Z") = 6
{
  :dt1-value :lexical ?dt .
  ?dt time:minute ?min .
  ?min math:equalTo "6"^^xsd:integer .
}
=>
{
  :t-time-minute-01
    a :TimeBuiltinTest ;
    :builtin   time:minute ;
    :input     ?dt ;
    :expected  "6"^^xsd:integer ;
    :actual    ?min ;
    :status    :pass .
} .

# time:minute("1999-12-31T23:59:59Z") = 59
{
  :dt2-value :lexical ?dt .
  ?dt time:minute ?min .
  ?min math:equalTo "59"^^xsd:integer .
}
=>
{
  :t-time-minute-02
    a :TimeBuiltinTest ;
    :builtin   time:minute ;
    :input     ?dt ;
    :expected  "59"^^xsd:integer ;
    :actual    ?min ;
    :status    :pass .
} .

################################################################
# 4.3.5 time:second
################################################################

# time:second("2023-04-01T18:06:04Z") = 4
{
  :dt1-value :lexical ?dt .
  ?dt time:second ?sec .
  ?sec math:equalTo "4"^^xsd:integer .
}
=>
{
  :t-time-second-01
    a :TimeBuiltinTest ;
    :builtin   time:second ;
    :input     ?dt ;
    :expected  "4"^^xsd:integer ;
    :actual    ?sec ;
    :status    :pass .
} .

# time:second("1999-12-31T23:59:59Z") = 59
{
  :dt2-value :lexical ?dt .
  ?dt time:second ?sec .
  ?sec math:equalTo "59"^^xsd:integer .
}
=>
{
  :t-time-second-02
    a :TimeBuiltinTest ;
    :builtin   time:second ;
    :input     ?dt ;
    :expected  "59"^^xsd:integer ;
    :actual    ?sec ;
    :status    :pass .
} .

################################################################
# 4.3.6 time:timeZone
#
# NOTE (spec vs current eyeling.js):
#   The W3C N3 builtins spec defines time:timeZone with range xsd:string,
#   returning the trailing timezone offset, e.g. "Z", "+02:00", "-05:30".
#   The current eyeling.js implementation returns an xsd:integer with
#   the offset in minutes east of UTC. These tests follow the SPEC
#   (string) behaviour, and will only pass once the implementation
#   is aligned.
################################################################

# time:timeZone("2023-04-01T18:06:04Z") = "Z"
{
  :dt1-value :lexical ?dt .
  ?dt time:timeZone ?tz .
  ?tz string:equalIgnoringCase "Z" .
}
=>
{
  :t-time-timeZone-01
    a :TimeBuiltinTest ;
    :builtin   time:timeZone ;
    :input     ?dt ;
    :expected  "Z" ;
    :actual    ?tz ;
    :status    :pass .
} .

# time:timeZone("2025-01-01T00:00:00+02:00") = "+02:00"
{
  :dt3-value :lexical ?dt .
  ?dt time:timeZone ?tz .
  ?tz string:equalIgnoringCase "+02:00" .
}
=>
{
  :t-time-timeZone-02
    a :TimeBuiltinTest ;
    :builtin   time:timeZone ;
    :input     ?dt ;
    :expected  "+02:00" ;
    :actual    ?tz ;
    :status    :pass .
} .

# time:timeZone("2025-01-01T00:00:00-05:30") = "-05:30"
{
  :dt4-value :lexical ?dt .
  ?dt time:timeZone ?tz .
  ?tz string:equalIgnoringCase "-05:30" .
}
=>
{
  :t-time-timeZone-03
    a :TimeBuiltinTest ;
    :builtin   time:timeZone ;
    :input     ?dt ;
    :expected  "-05:30" ;
    :actual    ?tz ;
    :status    :pass .
} .

