# =================================================
# Rconcile VAT JSON Pointer example
# See https://datatracker.ietf.org/doc/html/rfc6901
# =================================================

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .
@prefix list:   <http://www.w3.org/2000/10/swap/list#> .
@prefix math:   <http://www.w3.org/2000/10/swap/math#> .
@prefix log:    <http://www.w3.org/2000/10/swap/log#> .
@prefix owl:    <http://www.w3.org/2002/07/owl#> .
@prefix ex:     <http://example.org/> .

# ------------------------------------------------------------------
# Master data (canonical N3 graph)
# ------------------------------------------------------------------

ex:policy ex:euCountries ("BE" "NL" "DE" "FR" "LU") .

ex:Widget a ex:Product ;
  ex:sku "WID-001" ;
  ex:listPriceCents 999 ;
  ex:vatBps 2100 .

ex:Gadget a ex:Product ;
  ex:sku "GAD-002" ;
  ex:listPriceCents 1500 ;
  ex:vatBps 600 .

# Registry customer keyed by normalized VAT key (alnum only)
ex:RegistryNL
  ex:vatKey "NL999999999B01" ;
  ex:legalName "Example BV" .

# ------------------------------------------------------------------
# JSON feed (operational system)
# ------------------------------------------------------------------

ex:feed ex:json """{
  "meta~data": { "batch": "2025-12-18" },
  "orders": [
    {
      "orderId": "A100",
      "shipTo": { "country": "BE" },
      "customer": { "email": "Ada@Example.ORG", "vatId": null },
      "lines": [
        { "sku": "wid-001", "qty": 2, "unitCents": 999 },
        { "sku": "GAD-002", "qty": 1, "unitCents": 1500 }
      ],
      "declared": { "netCents": 3498, "vatCents": 509, "grossCents": 4007 }
    },
    {
      "orderId": "A200",
      "shipTo": { "country": "US" },
      "customer": { "email": "bob@example.org", "vatId": null },
      "lines": [
        { "sku": "WID-001", "qty": 2, "unitCents": 999 },
        { "sku": "GAD-002", "qty": 1, "unitCents": 1500 }
      ],
      "declared": { "netCents": 3498, "vatCents": 0, "grossCents": 3498 }
    },
    {
      "orderId": "A300",
      "shipTo": { "country": "NL" },
      "customer": { "email": "acct@company.nl", "vatId": "NL999999999B01" },
      "lines": [
        { "sku": "WID-001", "qty": 2, "unitCents": 999 },
        { "sku": "GAD-002", "qty": 1, "unitCents": 1500 }
      ],
      "declared": { "netCents": 3498, "vatCents": 0, "grossCents": 3498 }
    },
    {
      "orderId": "A301",
      "shipTo": { "country": "NL" },
      "customer": { "email": "billing@company.nl", "vatId": "NL999999999B01" },
      "lines": [
        { "sku": "WID-001", "qty": 2, "unitCents": 999 },
        { "sku": "GAD-002", "qty": 1, "unitCents": 1500 }
      ],
      "declared": { "netCents": 3498, "vatCents": 0, "grossCents": 3498 }
    },
    {
      "orderId": "A400",
      "shipTo": { "country": "BE" },
      "customer": { "email": "ada@other.example", "vatId": null },
      "lines": [
        { "sku": "WID-001", "qty": 2, "unitCents": 999 },
        { "sku": "GAD-002", "qty": 1, "unitCents": 1500 }
      ],
      "declared": { "netCents": 3498, "vatCents": 508, "grossCents": 4006 }
    }
  ]
}"""^^rdf:JSON .

# ------------------------------------------------------------------
# Sanity checks for JSON Pointer edge-cases
# ------------------------------------------------------------------

{
  ex:feed ex:json ?J .
  (?J "#/orders/0/shipTo/country") string:jsonPointer "BE" .
} => {
  ex:checks ex:fragmentPointerWorks true .
} .

{
  ex:feed ex:json ?J .
  (?J "/meta~0data/batch") string:jsonPointer "2025-12-18" .
} => {
  ex:checks ex:tildeEscapeWorks true .
} .

# ------------------------------------------------------------------
# 1) Materialize orders (JSON -> RDF-ish facts)
# ------------------------------------------------------------------

{
  ex:feed ex:json ?J .
  (?J "/orders") string:jsonPointer ?Orders .
  ?Orders list:iterate (?OrderIndex ?OrderJson) .

  (?OrderJson "/orderId") string:jsonPointer ?OrderId .
  (?OrderJson "/shipTo/country") string:jsonPointer ?Country .

  (?OrderJson "/customer") string:jsonPointer ?CustJson .
  (?CustJson "/email") string:jsonPointer ?Email .
  (?CustJson "/vatId") string:jsonPointer ?VatIdRaw .

  (?OrderJson "/declared") string:jsonPointer ?Decl .
  (?Decl "/netCents") string:jsonPointer ?NetD .
  (?Decl "/vatCents") string:jsonPointer ?VatD .
  (?Decl "/grossCents") string:jsonPointer ?GrossD .

  ("urn:example:order:%s" ?OrderId) string:format ?OrderUriStr .
  ?Order log:uri ?OrderUriStr .
} => {
  ?Order a ex:Order ;
         ex:orderId ?OrderId ;
         ex:orderIndex ?OrderIndex ;
         ex:shipCountry ?Country ;
         ex:email ?Email ;
         ex:vatIdRaw ?VatIdRaw ;
         ex:declaredNetCents ?NetD ;
         ex:declaredVatCents ?VatD ;
         ex:declaredGrossCents ?GrossD .
} .

# ------------------------------------------------------------------
# 2) Materialize customers
#    - If vatId is present -> customer IRI from normalized VAT key
#    - Else -> customer IRI is log:skolem(email)
# ------------------------------------------------------------------

# VAT customer
{
  ?Order a ex:Order ; ex:vatIdRaw ?VatIdRaw ; ex:email ?Email .
  ?VatIdRaw string:notEqualIgnoringCase "null" .
  (?VatIdRaw "[^0-9A-Za-z]" "") string:replace ?VatKey .

  ("urn:example:customer:vat:%s" ?VatKey) string:format ?CustUriStr .
  ?Cust log:uri ?CustUriStr .
} => {
  ?Cust a ex:Customer ;
        ex:vatKey ?VatKey ;
        ex:vatIdRaw ?VatIdRaw ;
        ex:email ?Email .
  ?Order ex:customer ?Cust .
} .

# Non-VAT customer
{
  ?Order a ex:Order ; ex:vatIdRaw "null" ; ex:email ?Email .
  ?Email log:skolem ?Cust .
} => {
  ?Cust a ex:Customer ;
        ex:vatIdRaw "null" ;
        ex:email ?Email .
  ?Order ex:customer ?Cust .
} .

# Registry reconciliation (VAT customers only)
{
  ?Cust a ex:Customer ; ex:vatKey ?VatKey .
  ?Reg ex:vatKey ?VatKey .
} => {
  ?Cust owl:sameAs ?Reg .
} .

# Detect conflicting emails for the SAME VAT-keyed customer
# (Use string:lessThan to avoid duplicate symmetric pairs.)
{
  ?Cust a ex:Customer ; ex:vatKey ?VatKey ; ex:email ?E1 ; ex:email ?E2 .
  ?E1 string:lessThan ?E2 .
  ?E1 string:notEqualIgnoringCase ?E2 .
} => {
  ?Cust a ex:CustomerEmailConflict ;
        ex:conflictingEmail ?E1, ?E2 .
} .

# ------------------------------------------------------------------
# 3) Materialize order lines + map SKU -> canonical product + compute money
#    VAT logic:
#      - ship outside EU -> VAT = 0 (export)
#      - ship in EU and customer has VAT -> VAT = 0 (reverse charge)
#      - ship in EU and customer has no VAT -> VAT = product vatBps
# ------------------------------------------------------------------

# Helper macro: create line IRI + compute netCents
{
  ex:feed ex:json ?J .
  (?J "/orders") string:jsonPointer ?Orders .
  ?Orders list:iterate (?OrderIndex ?OrderJson) .

  (?OrderJson "/orderId") string:jsonPointer ?OrderId .
  ("urn:example:order:%s" ?OrderId) string:format ?OrderUriStr .
  ?Order log:uri ?OrderUriStr .

  (?OrderJson "/lines") string:jsonPointer ?Lines .
  ?Lines list:iterate (?LineIndex ?LineJson) .

  (?LineJson "/sku") string:jsonPointer ?SkuJson .
  (?LineJson "/qty") string:jsonPointer ?Qty .
  (?LineJson "/unitCents") string:jsonPointer ?UnitCents .

  # SKU reconciliation is case-insensitive
  # (Guard with a type, otherwise already-derived OrderLine nodes can start acting as “products”.)
  ?Product a ex:Product ; ex:sku ?SkuCat .
  ?SkuJson string:equalIgnoringCase ?SkuCat .

  (?Qty ?UnitCents) math:product ?NetCents .

  ("urn:example:order:%s#line:%s" ?OrderId ?LineIndex) string:format ?LineUriStr .
  ?Line log:uri ?LineUriStr .
} => {
  ?Order ex:line ?Line .

  ?Line a ex:OrderLine ;
        ex:lineIndex ?LineIndex ;
        ex:product ?Product ;
        ex:sku ?SkuCat ;
        ex:qty ?Qty ;
        ex:unitCents ?UnitCents ;
        ex:netCents ?NetCents .
} .

# Export (outside EU): VAT=0
{
  ?Order a ex:Order ; ex:shipCountry ?Country .
  ex:policy ex:euCountries ?EU .
  ?EU list:notMember ?Country .

  ?Order ex:line ?Line .
  ?Line ex:netCents ?NetCents .
} => {
  ?Line ex:vatBps 0 ;
        ex:vatCents 0 ;
        ex:grossCents ?NetCents ;
        ex:vatReason ex:Export .
} .

# Reverse charge (EU + VAT id present): VAT=0
{
  ?Order a ex:Order ; ex:shipCountry ?Country ; ex:vatIdRaw ?VatIdRaw .
  ex:policy ex:euCountries ?EU .
  ?EU list:member ?Country .
  ?VatIdRaw string:notEqualIgnoringCase "null" .

  ?Order ex:line ?Line .
  ?Line ex:netCents ?NetCents .
} => {
  ?Line ex:vatBps 0 ;
        ex:vatCents 0 ;
        ex:grossCents ?NetCents ;
        ex:vatReason ex:ReverseCharge .
} .

# Domestic EU consumer (EU + no VAT): VAT = product vatBps
{
  ?Order a ex:Order ; ex:shipCountry ?Country ; ex:vatIdRaw "null" .
  ex:policy ex:euCountries ?EU .
  ?EU list:member ?Country .

  ?Order ex:line ?Line .
  ?Line ex:product ?Product ; ex:netCents ?NetCents .
  ?Product ex:vatBps ?VatBps .

  (?NetCents ?VatBps) math:product ?NetTimesBps .
  (?NetTimesBps 10000) math:integerQuotient ?VatCents .
  (?NetCents ?VatCents) math:sum ?GrossCents .
} => {
  ?Line ex:vatBps ?VatBps ;
        ex:vatCents ?VatCents ;
        ex:grossCents ?GrossCents ;
        ex:vatReason ex:Domestic .
} .

# ------------------------------------------------------------------
# 4) Reconcile computed totals vs declared totals
#    (Assumes 2 lines per order: index 0 and 1 — on purpose, to keep the example finite.)
# ------------------------------------------------------------------

{
  ?Order a ex:Order .

  ?Order ex:line ?L0 . ?L0 ex:lineIndex 0 ; ex:netCents ?N0 ; ex:vatCents ?V0 ; ex:grossCents ?G0 .
  ?Order ex:line ?L1 . ?L1 ex:lineIndex 1 ; ex:netCents ?N1 ; ex:vatCents ?V1 ; ex:grossCents ?G1 .

  (?N0 ?N1) math:sum ?Net .
  (?V0 ?V1) math:sum ?Vat .
  (?G0 ?G1) math:sum ?Gross .
} => {
  ?Order ex:computedNetCents ?Net ;
         ex:computedVatCents ?Vat ;
         ex:computedGrossCents ?Gross .
} .

# Mark OK orders
{
  ?Order a ex:Order ;
         ex:declaredNetCents ?DN ; ex:declaredVatCents ?DV ; ex:declaredGrossCents ?DG ;
         ex:computedNetCents ?CN ; ex:computedVatCents ?CV ; ex:computedGrossCents ?CG .

  ?DN math:equalTo ?CN .
  ?DV math:equalTo ?CV .
  ?DG math:equalTo ?CG .
} => {
  ?Order a ex:OrderOk .
} .

# Emit issues for VAT mismatch
{
  ?Order a ex:Order ; ex:orderId ?Oid ; ex:declaredVatCents ?DV ; ex:computedVatCents ?CV .
  ?DV math:notEqualTo ?CV .

  ("urn:example:issue:%s:vat" ?Oid) string:format ?IssueUriStr .
  ?Issue log:uri ?IssueUriStr .
} => {
  ?Issue a ex:Issue ;
         ex:onOrder ?Order ;
         ex:field "vatCents" ;
         ex:declared ?DV ;
         ex:computed ?CV .
  ?Order ex:hasIssue ?Issue .
} .

# Emit issues for GROSS mismatch
{
  ?Order a ex:Order ; ex:orderId ?Oid ; ex:declaredGrossCents ?DG ; ex:computedGrossCents ?CG .
  ?DG math:notEqualTo ?CG .

  ("urn:example:issue:%s:gross" ?Oid) string:format ?IssueUriStr .
  ?Issue log:uri ?IssueUriStr .
} => {
  ?Issue a ex:Issue ;
         ex:onOrder ?Order ;
         ex:field "grossCents" ;
         ex:declared ?DG ;
         ex:computed ?CG .
  ?Order ex:hasIssue ?Issue .
} .

