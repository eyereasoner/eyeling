# =================
# Takeuchi Function
# =================
#
# See https://en.wikipedia.org/wiki/Tak_(function)
#
#   tak(x,y,z) = z                                              if x <= y
#   tak(x,y,z) = tak(tak(x-1,y,z), tak(y-1,z,x), tak(z-1,x,y))  otherwise

@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix : <https://eyereasoner.github.io/eye/reasoning#>.

# Forward/tabling style: compute only what’s reachable from :needTak.

# Seed: only the call we want
(8 4 2) :needTak true .

# If a call is needed and X>Y, mark the three direct subcalls as needed
{
  (?X ?Y ?Z) :needTak true.
  ?X math:greaterThan ?Y.
  (?X 1) math:difference ?X1.
  (?Y 1) math:difference ?Y1.
  (?Z 1) math:difference ?Z1.
}
=>
{
  (?X1 ?Y ?Z) :needTak true.
  (?Y1 ?Z ?X) :needTak true.
  (?Z1 ?X ?Y) :needTak true.
}.

# Base case: if X<=Y then result is Z
{
  (?X ?Y ?Z) :needTak true.
  ?X math:notGreaterThan ?Y.
}
=>
{
  (?X ?Y ?Z) :tak ?Z.
}.

# Once the three direct subcalls have results, we also need the “final call” tak(A1,A2,A3)
{
  (?X ?Y ?Z) :needTak true.
  ?X math:greaterThan ?Y.

  (?X 1) math:difference ?X1.
  (?X1 ?Y ?Z) :tak ?A1.

  (?Y 1) math:difference ?Y1.
  (?Y1 ?Z ?X) :tak ?A2.

  (?Z 1) math:difference ?Z1.
  (?Z1 ?X ?Y) :tak ?A3.
}
=>
{
  (?A1 ?A2 ?A3) :needTak true.
}.

# Recursive case: if everything is known, tak(X,Y,Z) is tak(A1,A2,A3)
{
  (?X ?Y ?Z) :needTak true.
  ?X math:greaterThan ?Y.

  (?X 1) math:difference ?X1.
  (?X1 ?Y ?Z) :tak ?A1.

  (?Y 1) math:difference ?Y1.
  (?Y1 ?Z ?X) :tak ?A2.

  (?Z 1) math:difference ?Z1.
  (?Z1 ?X ?Y) :tak ?A3.

  (?A1 ?A2 ?A3) :tak ?A.
}
=>
{
  (?X ?Y ?Z) :tak ?A.
}.

