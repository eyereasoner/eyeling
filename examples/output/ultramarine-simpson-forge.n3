@prefix : <http://example.org/ultramarine-simpson#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b5 :y "4.909297426825682"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b5 :y "4.909297426825682"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b5 :dy "3.5838531634528574"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b5 :dy "3.5838531634528574"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b5 :ds "3.720753081997118"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b5 :ds "3.720753081997118"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :sample _:b5 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :sample _:b5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :x 2.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :x 2.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :coef 1.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :coef 1.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :y "4.909297426825682"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :y "4.909297426825682"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :dy "3.5838531634528574"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :dy "3.5838531634528574"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :ds "3.720753081997118"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :ds "3.720753081997118"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sampleResult _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b5 .
#   _:b5 :x 2.0 .
#   _:b5 :coef 1.0 .
#   2.0 math:sin "0.9092974268256817"^^xsd:decimal .
#   (2.0 2.0) math:exponentiation "4"^^xsd:decimal .
#   ("0.9092974268256817"^^xsd:decimal "4"^^xsd:decimal) math:sum "4.909297426825682"^^xsd:decimal .
#   2.0 math:cos "-0.4161468365471424"^^xsd:decimal .
#   (2.0 2.0) math:product "4"^^xsd:decimal .
#   ("-0.4161468365471424"^^xsd:decimal "4"^^xsd:decimal) math:sum "3.5838531634528574"^^xsd:decimal .
#   ("3.5838531634528574"^^xsd:decimal 2.0) math:exponentiation "12.844003497191053"^^xsd:decimal .
#   (1.0 "12.844003497191053"^^xsd:decimal) math:sum "13.844003497191053"^^xsd:decimal .
#   ("13.844003497191053"^^xsd:decimal 0.5) math:exponentiation "3.720753081997118"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "-0.4161468365471424"^^xsd:decimal
#   ?ds = "3.720753081997118"^^xsd:decimal
#   ?dy = "3.5838531634528574"^^xsd:decimal
#   ?dy2 = "12.844003497191053"^^xsd:decimal
#   ?onePlus = "13.844003497191053"^^xsd:decimal
#   ?s = _:b5
#   ?sinx = "0.9092974268256817"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "4"^^xsd:decimal
#   ?x = 2.0
#   ?x2 = "4"^^xsd:decimal
#   ?y = "4.909297426825682"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sampleResult _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b4 :y "3.2474949866040546"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b4 :y "3.2474949866040546"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b4 :dy "3.070737201667703"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b4 :dy "3.070737201667703"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b4 :ds "3.229462333222977"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b4 :ds "3.229462333222977"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :sample _:b4 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :sample _:b4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :x 1.5 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :x 1.5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :coef 4.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :coef 4.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :y "3.2474949866040546"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :y "3.2474949866040546"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :dy "3.070737201667703"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :dy "3.070737201667703"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :ds "3.229462333222977"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :ds "3.229462333222977"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sampleResult _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b4 .
#   _:b4 :x 1.5 .
#   _:b4 :coef 4.0 .
#   1.5 math:sin "0.9974949866040544"^^xsd:decimal .
#   (1.5 2.0) math:exponentiation "2.25"^^xsd:decimal .
#   ("0.9974949866040544"^^xsd:decimal "2.25"^^xsd:decimal) math:sum "3.2474949866040546"^^xsd:decimal .
#   1.5 math:cos "0.0707372016677029"^^xsd:decimal .
#   (2.0 1.5) math:product "3"^^xsd:decimal .
#   ("0.0707372016677029"^^xsd:decimal "3"^^xsd:decimal) math:sum "3.070737201667703"^^xsd:decimal .
#   ("3.070737201667703"^^xsd:decimal 2.0) math:exponentiation "9.429426961705994"^^xsd:decimal .
#   (1.0 "9.429426961705994"^^xsd:decimal) math:sum "10.429426961705994"^^xsd:decimal .
#   ("10.429426961705994"^^xsd:decimal 0.5) math:exponentiation "3.229462333222977"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.0707372016677029"^^xsd:decimal
#   ?ds = "3.229462333222977"^^xsd:decimal
#   ?dy = "3.070737201667703"^^xsd:decimal
#   ?dy2 = "9.429426961705994"^^xsd:decimal
#   ?onePlus = "10.429426961705994"^^xsd:decimal
#   ?s = _:b4
#   ?sinx = "0.9974949866040544"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "3"^^xsd:decimal
#   ?x = 1.5
#   ?x2 = "2.25"^^xsd:decimal
#   ?y = "3.2474949866040546"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sampleResult _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b3 :y "1.8414709848078965"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b3 :y "1.8414709848078965"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b3 :dy "2.5403023058681398"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b3 :dy "2.5403023058681398"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b3 :ds "2.7300431874237794"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b3 :ds "2.7300431874237794"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :sample _:b3 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :sample _:b3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :x 1.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :x 1.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :coef 2.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :coef 2.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :y "1.8414709848078965"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :y "1.8414709848078965"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :dy "2.5403023058681398"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :dy "2.5403023058681398"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :ds "2.7300431874237794"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :ds "2.7300431874237794"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sampleResult _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b3 .
#   _:b3 :x 1.0 .
#   _:b3 :coef 2.0 .
#   1.0 math:sin "0.8414709848078965"^^xsd:decimal .
#   (1.0 2.0) math:exponentiation "1"^^xsd:decimal .
#   ("0.8414709848078965"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8414709848078965"^^xsd:decimal .
#   1.0 math:cos "0.5403023058681398"^^xsd:decimal .
#   (2.0 1.0) math:product "2"^^xsd:decimal .
#   ("0.5403023058681398"^^xsd:decimal "2"^^xsd:decimal) math:sum "2.5403023058681398"^^xsd:decimal .
#   ("2.5403023058681398"^^xsd:decimal 2.0) math:exponentiation "6.453135805198988"^^xsd:decimal .
#   (1.0 "6.453135805198988"^^xsd:decimal) math:sum "7.453135805198988"^^xsd:decimal .
#   ("7.453135805198988"^^xsd:decimal 0.5) math:exponentiation "2.7300431874237794"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 2.0
#   ?cosx = "0.5403023058681398"^^xsd:decimal
#   ?ds = "2.7300431874237794"^^xsd:decimal
#   ?dy = "2.5403023058681398"^^xsd:decimal
#   ?dy2 = "6.453135805198988"^^xsd:decimal
#   ?onePlus = "7.453135805198988"^^xsd:decimal
#   ?s = _:b3
#   ?sinx = "0.8414709848078965"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "2"^^xsd:decimal
#   ?x = 1.0
#   ?x2 = "1"^^xsd:decimal
#   ?y = "1.8414709848078965"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sampleResult _:sk_2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b2 :y "0.729425538604203"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b2 :y "0.729425538604203"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b2 :dy "1.8775825618903728"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b2 :dy "1.8775825618903728"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b2 :ds "2.12727907823934"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b2 :ds "2.12727907823934"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :sample _:b2 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :sample _:b2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :x 0.5 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :x 0.5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :coef 4.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :coef 4.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :y "0.729425538604203"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :y "0.729425538604203"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :dy "1.8775825618903728"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :dy "1.8775825618903728"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :ds "2.12727907823934"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :ds "2.12727907823934"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sampleResult _:sk_3 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b2 .
#   _:b2 :x 0.5 .
#   _:b2 :coef 4.0 .
#   0.5 math:sin "0.479425538604203"^^xsd:decimal .
#   (0.5 2.0) math:exponentiation "0.25"^^xsd:decimal .
#   ("0.479425538604203"^^xsd:decimal "0.25"^^xsd:decimal) math:sum "0.729425538604203"^^xsd:decimal .
#   0.5 math:cos "0.8775825618903728"^^xsd:decimal .
#   (2.0 0.5) math:product "1"^^xsd:decimal .
#   ("0.8775825618903728"^^xsd:decimal "1"^^xsd:decimal) math:sum "1.8775825618903728"^^xsd:decimal .
#   ("1.8775825618903728"^^xsd:decimal 2.0) math:exponentiation "3.5253162767148156"^^xsd:decimal .
#   (1.0 "3.5253162767148156"^^xsd:decimal) math:sum "4.525316276714816"^^xsd:decimal .
#   ("4.525316276714816"^^xsd:decimal 0.5) math:exponentiation "2.12727907823934"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 4.0
#   ?cosx = "0.8775825618903728"^^xsd:decimal
#   ?ds = "2.12727907823934"^^xsd:decimal
#   ?dy = "1.8775825618903728"^^xsd:decimal
#   ?dy2 = "3.5253162767148156"^^xsd:decimal
#   ?onePlus = "4.525316276714816"^^xsd:decimal
#   ?s = _:b2
#   ?sinx = "0.479425538604203"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "1"^^xsd:decimal
#   ?x = 0.5
#   ?x2 = "0.25"^^xsd:decimal
#   ?y = "0.729425538604203"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sampleResult _:sk_3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b1 :y "0"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b1 :y "0"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b1 :dy "1"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b1 :dy "1"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:b1 :ds "1.4142135623730951"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:b1 :ds "1.4142135623730951"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :sample _:b1 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :sample _:b1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :x 0.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :x 0.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :coef 1.0 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :coef 1.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :y "0"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :y "0"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :dy "1"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :dy "1"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :ds "1.4142135623730951"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :ds "1.4142135623730951"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sampleResult _:sk_4 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5) list:member _:b1 .
#   _:b1 :x 0.0 .
#   _:b1 :coef 1.0 .
#   0.0 math:sin "0"^^xsd:decimal .
#   (0.0 2.0) math:exponentiation "0"^^xsd:decimal .
#   ("0"^^xsd:decimal "0"^^xsd:decimal) math:sum "0"^^xsd:decimal .
#   0.0 math:cos "1"^^xsd:decimal .
#   (2.0 0.0) math:product "0"^^xsd:decimal .
#   ("1"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
#   ("1"^^xsd:decimal 2.0) math:exponentiation "1"^^xsd:decimal .
#   (1.0 "1"^^xsd:decimal) math:sum "2"^^xsd:decimal .
#   ("2"^^xsd:decimal 0.5) math:exponentiation "1.4142135623730951"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     ?ss list:member ?s .
#     ?s :x ?x .
#     ?s :coef ?c .
#     ?x math:sin ?sinx .
#     (?x 2.0) math:exponentiation ?x2 .
#     (?sinx ?x2) math:sum ?y .
#     ?x math:cos ?cosx .
#     (2.0 ?x) math:product ?twox .
#     (?cosx ?twox) math:sum ?dy .
#     (?dy 2.0) math:exponentiation ?dy2 .
#     (1.0 ?dy2) math:sum ?onePlus .
#     (?onePlus 0.5) math:exponentiation ?ds .
#   } => {
#     ?s :y ?y .
#     ?s :dy ?dy .
#     ?s :ds ?ds .
#     _:b6 :sample ?s .
#     _:b6 :x ?x .
#     _:b6 :coef ?c .
#     _:b6 :y ?y .
#     _:b6 :dy ?dy .
#     _:b6 :ds ?ds .
#     :Simpson1 :sampleResult _:b6 .
#   } .
# with substitution (on rule variables):
#   ?c = 1.0
#   ?cosx = "1"^^xsd:decimal
#   ?ds = "1.4142135623730951"^^xsd:decimal
#   ?dy = "1"^^xsd:decimal
#   ?dy2 = "1"^^xsd:decimal
#   ?onePlus = "2"^^xsd:decimal
#   ?s = _:b1
#   ?sinx = "0"^^xsd:decimal
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?twox = "0"^^xsd:decimal
#   ?x = 0.0
#   ?x2 = "0"^^xsd:decimal
#   ?y = "0"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sampleResult _:sk_4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (?wy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?c ?y) math:product ?wy .
#   } ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal) math:sum "24.499921497274507"^^xsd:decimal .
#   (?wxy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :x ?x .
#       ?s :y ?y .
#       (?x ?y) math:product ?xy .
#       (?c ?xy) math:product ?wxy .
#   } ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal) math:sum "34.445357820099886"^^xsd:decimal .
#   (?wy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#       (?c ?y2) math:product ?wy2 .
#   } ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b3 .
#   ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal) math:sum "75.19637321836198"^^xsd:decimal .
#   (?wds {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :ds ?ds .
#       (?c ?ds) math:product ?wds .
#   } ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)) log:collectAllIn ?_b4 .
#   ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal) math:sum "32.02201866506704"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     (?wy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?c ?y) math:product ?wy .
#     } ?wys) log:collectAllIn ?_b1 .
#     ?wys math:sum ?sumWY .
#     (?wxy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :x ?x .
#         ?s :y ?y .
#         (?x ?y) math:product ?xy .
#         (?c ?xy) math:product ?wxy .
#     } ?wxys) log:collectAllIn ?_b2 .
#     ?wxys math:sum ?sumWXY .
#     (?wy2 {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#         (?c ?y2) math:product ?wy2 .
#     } ?wy2s) log:collectAllIn ?_b3 .
#     ?wy2s math:sum ?sumWY2 .
#     (?wds {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :ds ?ds .
#         (?c ?ds) math:product ?wds .
#     } ?wdss) log:collectAllIn ?_b4 .
#     ?wdss math:sum ?sumWDS .
#   } => {
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#   } .
# with substitution (on rule variables):
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?wdss = ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)
#   ?wxys = ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)
#   ?wy2s = ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)
#   ?wys = ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (?wy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?c ?y) math:product ?wy .
#   } ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal) math:sum "24.499921497274507"^^xsd:decimal .
#   (?wxy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :x ?x .
#       ?s :y ?y .
#       (?x ?y) math:product ?xy .
#       (?c ?xy) math:product ?wxy .
#   } ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal) math:sum "34.445357820099886"^^xsd:decimal .
#   (?wy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#       (?c ?y2) math:product ?wy2 .
#   } ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b3 .
#   ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal) math:sum "75.19637321836198"^^xsd:decimal .
#   (?wds {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :ds ?ds .
#       (?c ?ds) math:product ?wds .
#   } ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)) log:collectAllIn ?_b4 .
#   ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal) math:sum "32.02201866506704"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     (?wy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?c ?y) math:product ?wy .
#     } ?wys) log:collectAllIn ?_b1 .
#     ?wys math:sum ?sumWY .
#     (?wxy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :x ?x .
#         ?s :y ?y .
#         (?x ?y) math:product ?xy .
#         (?c ?xy) math:product ?wxy .
#     } ?wxys) log:collectAllIn ?_b2 .
#     ?wxys math:sum ?sumWXY .
#     (?wy2 {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#         (?c ?y2) math:product ?wy2 .
#     } ?wy2s) log:collectAllIn ?_b3 .
#     ?wy2s math:sum ?sumWY2 .
#     (?wds {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :ds ?ds .
#         (?c ?ds) math:product ?wds .
#     } ?wdss) log:collectAllIn ?_b4 .
#     ?wdss math:sum ?sumWDS .
#   } => {
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#   } .
# with substitution (on rule variables):
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?wdss = ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)
#   ?wxys = ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)
#   ?wy2s = ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)
#   ?wys = ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (?wy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?c ?y) math:product ?wy .
#   } ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal) math:sum "24.499921497274507"^^xsd:decimal .
#   (?wxy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :x ?x .
#       ?s :y ?y .
#       (?x ?y) math:product ?xy .
#       (?c ?xy) math:product ?wxy .
#   } ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal) math:sum "34.445357820099886"^^xsd:decimal .
#   (?wy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#       (?c ?y2) math:product ?wy2 .
#   } ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b3 .
#   ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal) math:sum "75.19637321836198"^^xsd:decimal .
#   (?wds {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :ds ?ds .
#       (?c ?ds) math:product ?wds .
#   } ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)) log:collectAllIn ?_b4 .
#   ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal) math:sum "32.02201866506704"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     (?wy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?c ?y) math:product ?wy .
#     } ?wys) log:collectAllIn ?_b1 .
#     ?wys math:sum ?sumWY .
#     (?wxy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :x ?x .
#         ?s :y ?y .
#         (?x ?y) math:product ?xy .
#         (?c ?xy) math:product ?wxy .
#     } ?wxys) log:collectAllIn ?_b2 .
#     ?wxys math:sum ?sumWXY .
#     (?wy2 {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#         (?c ?y2) math:product ?wy2 .
#     } ?wy2s) log:collectAllIn ?_b3 .
#     ?wy2s math:sum ?sumWY2 .
#     (?wds {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :ds ?ds .
#         (?c ?ds) math:product ?wds .
#     } ?wdss) log:collectAllIn ?_b4 .
#     ?wdss math:sum ?sumWDS .
#   } => {
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#   } .
# with substitution (on rule variables):
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?wdss = ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)
#   ?wxys = ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)
#   ?wy2s = ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)
#   ?wys = ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :samples (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   (?wy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?c ?y) math:product ?wy .
#   } ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal) math:sum "24.499921497274507"^^xsd:decimal .
#   (?wxy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :x ?x .
#       ?s :y ?y .
#       (?x ?y) math:product ?xy .
#       (?c ?xy) math:product ?wxy .
#   } ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal) math:sum "34.445357820099886"^^xsd:decimal .
#   (?wy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#       (?c ?y2) math:product ?wy2 .
#   } ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b3 .
#   ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal) math:sum "75.19637321836198"^^xsd:decimal .
#   (?wds {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?s .
#       ?s :coef ?c .
#       ?s :ds ?ds .
#       (?c ?ds) math:product ?wds .
#   } ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)) log:collectAllIn ?_b4 .
#   ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal) math:sum "32.02201866506704"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :samples ?ss .
#     (?wy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?c ?y) math:product ?wy .
#     } ?wys) log:collectAllIn ?_b1 .
#     ?wys math:sum ?sumWY .
#     (?wxy {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :x ?x .
#         ?s :y ?y .
#         (?x ?y) math:product ?xy .
#         (?c ?xy) math:product ?wxy .
#     } ?wxys) log:collectAllIn ?_b2 .
#     ?wxys math:sum ?sumWXY .
#     (?wy2 {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#         (?c ?y2) math:product ?wy2 .
#     } ?wy2s) log:collectAllIn ?_b3 .
#     ?wy2s math:sum ?sumWY2 .
#     (?wds {
#         ?ss list:member ?s .
#         ?s :coef ?c .
#         ?s :ds ?ds .
#         (?c ?ds) math:product ?wds .
#     } ?wdss) log:collectAllIn ?_b4 .
#     ?wdss math:sum ?sumWDS .
#   } => {
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#   } .
# with substitution (on rule variables):
#   ?ss = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?wdss = ("3.720753081997118"^^xsd:decimal "12.917849332891908"^^xsd:decimal "5.460086374847559"^^xsd:decimal "8.50911631295736"^^xsd:decimal "1.4142135623730951"^^xsd:decimal)
#   ?wxys = ("9.818594853651364"^^xsd:decimal "19.484969919624326"^^xsd:decimal "3.682941969615793"^^xsd:decimal "1.458851077208406"^^xsd:decimal "0"^^xsd:decimal)
#   ?wy2s = ("24.10120122503726"^^xsd:decimal "42.18489475207387"^^xsd:decimal "6.782030775778728"^^xsd:decimal "2.1282464654721265"^^xsd:decimal "0"^^xsd:decimal)
#   ?wys = ("4.909297426825682"^^xsd:decimal "12.989979946416218"^^xsd:decimal "3.682941969615793"^^xsd:decimal "2.917702154416812"^^xsd:decimal "0"^^xsd:decimal)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :areaUnderCurve "4.083320249545751"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :areaUnderCurve "4.083320249545751"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :arcLength "5.337003110844506"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :arcLength "5.337003110844506"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :momentAboutY "5.740892970016647"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :momentAboutY "5.740892970016647"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :momentAboutX "6.266364434863498"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :momentAboutX "6.266364434863498"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :xbar "1.405937477143825"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :xbar "1.405937477143825"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :ybar "1.5346247788330099"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :ybar "1.5346247788330099"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Simpson1 :centroid _:sk_5 .
# It holds because the following instance of the rule body is provable:
#   :Simpson1 :h 0.5 .
#   :Simpson1 :sumWY "24.499921497274507"^^xsd:decimal .
#   :Simpson1 :sumWXY "34.445357820099886"^^xsd:decimal .
#   :Simpson1 :sumWY2 "75.19637321836198"^^xsd:decimal .
#   :Simpson1 :sumWDS "32.02201866506704"^^xsd:decimal .
#   (0.5 3.0) math:quotient "0.16666666666666666"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "24.499921497274507"^^xsd:decimal) math:product "4.083320249545751"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "34.445357820099886"^^xsd:decimal) math:product "5.740892970016647"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "75.19637321836198"^^xsd:decimal) math:product "12.532728869726997"^^xsd:decimal .
#   (0.5 "12.532728869726997"^^xsd:decimal) math:product "6.266364434863498"^^xsd:decimal .
#   ("0.16666666666666666"^^xsd:decimal "32.02201866506704"^^xsd:decimal) math:product "5.337003110844506"^^xsd:decimal .
#   ("5.740892970016647"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.405937477143825"^^xsd:decimal .
#   ("6.266364434863498"^^xsd:decimal "4.083320249545751"^^xsd:decimal) math:quotient "1.5346247788330099"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Simpson1 :h ?h .
#     :Simpson1 :sumWY ?sumWY .
#     :Simpson1 :sumWXY ?sumWXY .
#     :Simpson1 :sumWY2 ?sumWY2 .
#     :Simpson1 :sumWDS ?sumWDS .
#     (?h 3.0) math:quotient ?fac .
#     (?fac ?sumWY) math:product ?A .
#     (?fac ?sumWXY) math:product ?My .
#     (?fac ?sumWY2) math:product ?Iy2 .
#     (0.5 ?Iy2) math:product ?Mx .
#     (?fac ?sumWDS) math:product ?L .
#     (?My ?A) math:quotient ?xbar .
#     (?Mx ?A) math:quotient ?ybar .
#   } => {
#     :Simpson1 :areaUnderCurve ?A .
#     :Simpson1 :arcLength ?L .
#     :Simpson1 :momentAboutY ?My .
#     :Simpson1 :momentAboutX ?Mx .
#     _:b7 :xbar ?xbar .
#     _:b7 :ybar ?ybar .
#     :Simpson1 :centroid _:b7 .
#   } .
# with substitution (on rule variables):
#   ?A = "4.083320249545751"^^xsd:decimal
#   ?Iy2 = "12.532728869726997"^^xsd:decimal
#   ?L = "5.337003110844506"^^xsd:decimal
#   ?Mx = "6.266364434863498"^^xsd:decimal
#   ?My = "5.740892970016647"^^xsd:decimal
#   ?fac = "0.16666666666666666"^^xsd:decimal
#   ?h = 0.5
#   ?sumWDS = "32.02201866506704"^^xsd:decimal
#   ?sumWXY = "34.445357820099886"^^xsd:decimal
#   ?sumWY = "24.499921497274507"^^xsd:decimal
#   ?sumWY2 = "75.19637321836198"^^xsd:decimal
#   ?xbar = "1.405937477143825"^^xsd:decimal
#   ?ybar = "1.5346247788330099"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Simpson1 :centroid _:sk_5 .

