@prefix : <http://example.org/ruby-runge#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :yAtX0 "-0.27999999999999986"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :x0 0.6 .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       (0.6 ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("-0.2912"^^xsd:decimal "0.5824"^^xsd:decimal "-0.5823999999999999"^^xsd:decimal "-0.14559999999999998"^^xsd:decimal "0.1568"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("-0.2912"^^xsd:decimal "0.5824"^^xsd:decimal "-0.5823999999999999"^^xsd:decimal "-0.14559999999999998"^^xsd:decimal "0.1568"^^xsd:decimal) math:sum "-0.27999999999999986"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :x0 ?x0 .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?x0 ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?y0 .
#   } => {
#     :Interp1 :yAtX0 ?y0 .
#   } .
# with substitution (on rule variables):
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("-0.2912"^^xsd:decimal "0.5824"^^xsd:decimal "-0.5823999999999999"^^xsd:decimal "-0.14559999999999998"^^xsd:decimal "0.1568"^^xsd:decimal)
#   ?x0 = 0.6
#   ?y0 = "-0.27999999999999986"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :yAtX0 "-0.27999999999999986"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :yAtXPlus "-0.2775980000000001"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :x0 0.6 .
#   :Interp1 :h 0.001 .
#   (0.6 0.001) math:sum "0.601"^^xsd:decimal .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       ("0.601"^^xsd:decimal ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("-0.291249943716375"^^xsd:decimal "0.5835426727665"^^xsd:decimal "-0.58111529060025"^^xsd:decimal "-0.1454300602335"^^xsd:decimal "0.15665462178362502"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("-0.291249943716375"^^xsd:decimal "0.5835426727665"^^xsd:decimal "-0.58111529060025"^^xsd:decimal "-0.1454300602335"^^xsd:decimal "0.15665462178362502"^^xsd:decimal) math:sum "-0.2775980000000001"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :x0 ?x0 .
#     :Interp1 :h ?h .
#     (?x0 ?h) math:sum ?xPlus .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?xPlus ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?yPlus .
#   } => {
#     :Interp1 :yAtXPlus ?yPlus .
#     :Interp1 :xPlus ?xPlus .
#   } .
# with substitution (on rule variables):
#   ?h = 0.001
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("-0.291249943716375"^^xsd:decimal "0.5835426727665"^^xsd:decimal "-0.58111529060025"^^xsd:decimal "-0.1454300602335"^^xsd:decimal "0.15665462178362502"^^xsd:decimal)
#   ?x0 = 0.6
#   ?xPlus = "0.601"^^xsd:decimal
#   ?yPlus = "-0.2775980000000001"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :yAtXPlus "-0.2775980000000001"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :xPlus "0.601"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :x0 0.6 .
#   :Interp1 :h 0.001 .
#   (0.6 0.001) math:sum "0.601"^^xsd:decimal .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       ("0.601"^^xsd:decimal ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("-0.291249943716375"^^xsd:decimal "0.5835426727665"^^xsd:decimal "-0.58111529060025"^^xsd:decimal "-0.1454300602335"^^xsd:decimal "0.15665462178362502"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("-0.291249943716375"^^xsd:decimal "0.5835426727665"^^xsd:decimal "-0.58111529060025"^^xsd:decimal "-0.1454300602335"^^xsd:decimal "0.15665462178362502"^^xsd:decimal) math:sum "-0.2775980000000001"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :x0 ?x0 .
#     :Interp1 :h ?h .
#     (?x0 ?h) math:sum ?xPlus .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?xPlus ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?yPlus .
#   } => {
#     :Interp1 :yAtXPlus ?yPlus .
#     :Interp1 :xPlus ?xPlus .
#   } .
# with substitution (on rule variables):
#   ?h = 0.001
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("-0.291249943716375"^^xsd:decimal "0.5835426727665"^^xsd:decimal "-0.58111529060025"^^xsd:decimal "-0.1454300602335"^^xsd:decimal "0.15665462178362502"^^xsd:decimal)
#   ?x0 = 0.6
#   ?xPlus = "0.601"^^xsd:decimal
#   ?yPlus = "-0.2775980000000001"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :xPlus "0.601"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :yAtXMinus "-0.28239800000000004"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :x0 0.6 .
#   :Interp1 :h 0.001 .
#   (0.6 0.001) math:difference "0.599"^^xsd:decimal .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       ("0.599"^^xsd:decimal ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("-0.291147279616375"^^xsd:decimal "0.5812573405665"^^xsd:decimal "-0.58368328940025"^^xsd:decimal "-0.1457687264335"^^xsd:decimal "0.156943954883625"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("-0.291147279616375"^^xsd:decimal "0.5812573405665"^^xsd:decimal "-0.58368328940025"^^xsd:decimal "-0.1457687264335"^^xsd:decimal "0.156943954883625"^^xsd:decimal) math:sum "-0.28239800000000004"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :x0 ?x0 .
#     :Interp1 :h ?h .
#     (?x0 ?h) math:difference ?xMinus .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?xMinus ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?yMinus .
#   } => {
#     :Interp1 :yAtXMinus ?yMinus .
#     :Interp1 :xMinus ?xMinus .
#   } .
# with substitution (on rule variables):
#   ?h = 0.001
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("-0.291147279616375"^^xsd:decimal "0.5812573405665"^^xsd:decimal "-0.58368328940025"^^xsd:decimal "-0.1457687264335"^^xsd:decimal "0.156943954883625"^^xsd:decimal)
#   ?x0 = 0.6
#   ?xMinus = "0.599"^^xsd:decimal
#   ?yMinus = "-0.28239800000000004"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :yAtXMinus "-0.28239800000000004"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :xMinus "0.599"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :x0 0.6 .
#   :Interp1 :h 0.001 .
#   (0.6 0.001) math:difference "0.599"^^xsd:decimal .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       ("0.599"^^xsd:decimal ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("-0.291147279616375"^^xsd:decimal "0.5812573405665"^^xsd:decimal "-0.58368328940025"^^xsd:decimal "-0.1457687264335"^^xsd:decimal "0.156943954883625"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("-0.291147279616375"^^xsd:decimal "0.5812573405665"^^xsd:decimal "-0.58368328940025"^^xsd:decimal "-0.1457687264335"^^xsd:decimal "0.156943954883625"^^xsd:decimal) math:sum "-0.28239800000000004"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :x0 ?x0 .
#     :Interp1 :h ?h .
#     (?x0 ?h) math:difference ?xMinus .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?xMinus ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?yMinus .
#   } => {
#     :Interp1 :yAtXMinus ?yMinus .
#     :Interp1 :xMinus ?xMinus .
#   } .
# with substitution (on rule variables):
#   ?h = 0.001
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("-0.291147279616375"^^xsd:decimal "0.5812573405665"^^xsd:decimal "-0.58368328940025"^^xsd:decimal "-0.1457687264335"^^xsd:decimal "0.156943954883625"^^xsd:decimal)
#   ?x0 = 0.6
#   ?xMinus = "0.599"^^xsd:decimal
#   ?yMinus = "-0.28239800000000004"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :xMinus "0.599"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :derivativeAtX0 "2.3999999999999577"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :yAtXPlus "-0.2775980000000001"^^xsd:decimal .
#   :Interp1 :yAtXMinus "-0.28239800000000004"^^xsd:decimal .
#   :Interp1 :h 0.001 .
#   ("-0.2775980000000001"^^xsd:decimal "-0.28239800000000004"^^xsd:decimal) math:difference "0.0047999999999999154"^^xsd:decimal .
#   (2.0 0.001) math:product "0.002"^^xsd:decimal .
#   ("0.0047999999999999154"^^xsd:decimal "0.002"^^xsd:decimal) math:quotient "2.3999999999999577"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :yAtXPlus ?yP .
#     :Interp1 :yAtXMinus ?yM .
#     :Interp1 :h ?h .
#     (?yP ?yM) math:difference ?dy .
#     (2.0 ?h) math:product ?twoH .
#     (?dy ?twoH) math:quotient ?dydx .
#   } => {
#     :Interp1 :derivativeAtX0 ?dydx .
#   } .
# with substitution (on rule variables):
#   ?dy = "0.0047999999999999154"^^xsd:decimal
#   ?dydx = "2.3999999999999577"^^xsd:decimal
#   ?h = 0.001
#   ?twoH = "0.002"^^xsd:decimal
#   ?yM = "-0.28239800000000004"^^xsd:decimal
#   ?yP = "-0.2775980000000001"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :derivativeAtX0 "2.3999999999999577"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :yAtBracketA "-1"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :bracketA 0.0 .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       (0.0 ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("0"^^xsd:decimal "0"^^xsd:decimal "-1"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("0"^^xsd:decimal "0"^^xsd:decimal "-1"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal) math:sum "-1"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :bracketA ?xa .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?xa ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?ya .
#   } => {
#     :Interp1 :yAtBracketA ?ya .
#   } .
# with substitution (on rule variables):
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("0"^^xsd:decimal "0"^^xsd:decimal "-1"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal)
#   ?xa = 0.0
#   ?ya = "-1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :yAtBracketA "-1"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :yAtBracketB "1"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :points (_:b1 _:b2 _:b3 _:b4 _:b5) .
#   :Interp1 :bracketB 1.0 .
#   (?term {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pi .
#       ?pi :x ?xi .
#       ?pi :y ?yi .
#       (?f {
#       (_:b1 _:b2 _:b3 _:b4 _:b5) list:member ?pj .
#       ?pj :x ?xj .
#       ?xj math:notEqualTo ?xi .
#       (1.0 ?xj) math:difference ?num .
#       (?xi ?xj) math:difference ?den .
#       (?num ?den) math:quotient ?f .
#   } ?factors) log:collectAllIn ?_b1 .
#       ?factors math:product ?basis .
#       (?yi ?basis) math:product ?term .
#   } ("0"^^xsd:decimal "1"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal)) log:collectAllIn ?_b2 .
#   ("0"^^xsd:decimal "1"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal) math:sum "1"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Interp1 :points ?pts .
#     :Interp1 :bracketB ?xb .
#     (?term {
#         ?pts list:member ?pi .
#         ?pi :x ?xi .
#         ?pi :y ?yi .
#         (?f {
#         ?pts list:member ?pj .
#         ?pj :x ?xj .
#         ?xj math:notEqualTo ?xi .
#         (?xb ?xj) math:difference ?num .
#         (?xi ?xj) math:difference ?den .
#         (?num ?den) math:quotient ?f .
#     } ?factors) log:collectAllIn ?_b1 .
#         ?factors math:product ?basis .
#         (?yi ?basis) math:product ?term .
#     } ?terms) log:collectAllIn ?_b2 .
#     ?terms math:sum ?yb .
#   } => {
#     :Interp1 :yAtBracketB ?yb .
#   } .
# with substitution (on rule variables):
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5)
#   ?terms = ("0"^^xsd:decimal "1"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal "0"^^xsd:decimal)
#   ?xb = 1.0
#   ?yb = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :yAtBracketB "1"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :a 0.0 .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :bracketA 0.0 .
#   :Interp1 :bracketB 1.0 .
#   :Interp1 :yAtBracketA "-1"^^xsd:decimal .
#   :Interp1 :yAtBracketB "1"^^xsd:decimal .
#   ("-1"^^xsd:decimal "1"^^xsd:decimal) math:product "-1"^^xsd:decimal .
#   "-1"^^xsd:decimal math:lessThan 0.0 .
# via the schematic forward rule:
#   {
#     :Interp1 :bracketA ?xa .
#     :Interp1 :bracketB ?xb .
#     :Interp1 :yAtBracketA ?ya .
#     :Interp1 :yAtBracketB ?yb .
#     (?ya ?yb) math:product ?prod .
#     ?prod math:lessThan 0.0 .
#   } => {
#     _:b6 :a ?xa .
#     _:b6 :b ?xb .
#     _:b6 :ya ?ya .
#     _:b6 :yb ?yb .
#     :Interp1 :rootBracket _:b6 .
#   } .
# with substitution (on rule variables):
#   ?prod = "-1"^^xsd:decimal
#   ?xa = 0.0
#   ?xb = 1.0
#   ?ya = "-1"^^xsd:decimal
#   ?yb = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :a 0.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :b 1.0 .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :bracketA 0.0 .
#   :Interp1 :bracketB 1.0 .
#   :Interp1 :yAtBracketA "-1"^^xsd:decimal .
#   :Interp1 :yAtBracketB "1"^^xsd:decimal .
#   ("-1"^^xsd:decimal "1"^^xsd:decimal) math:product "-1"^^xsd:decimal .
#   "-1"^^xsd:decimal math:lessThan 0.0 .
# via the schematic forward rule:
#   {
#     :Interp1 :bracketA ?xa .
#     :Interp1 :bracketB ?xb .
#     :Interp1 :yAtBracketA ?ya .
#     :Interp1 :yAtBracketB ?yb .
#     (?ya ?yb) math:product ?prod .
#     ?prod math:lessThan 0.0 .
#   } => {
#     _:b6 :a ?xa .
#     _:b6 :b ?xb .
#     _:b6 :ya ?ya .
#     _:b6 :yb ?yb .
#     :Interp1 :rootBracket _:b6 .
#   } .
# with substitution (on rule variables):
#   ?prod = "-1"^^xsd:decimal
#   ?xa = 0.0
#   ?xb = 1.0
#   ?ya = "-1"^^xsd:decimal
#   ?yb = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :b 1.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :ya "-1"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :bracketA 0.0 .
#   :Interp1 :bracketB 1.0 .
#   :Interp1 :yAtBracketA "-1"^^xsd:decimal .
#   :Interp1 :yAtBracketB "1"^^xsd:decimal .
#   ("-1"^^xsd:decimal "1"^^xsd:decimal) math:product "-1"^^xsd:decimal .
#   "-1"^^xsd:decimal math:lessThan 0.0 .
# via the schematic forward rule:
#   {
#     :Interp1 :bracketA ?xa .
#     :Interp1 :bracketB ?xb .
#     :Interp1 :yAtBracketA ?ya .
#     :Interp1 :yAtBracketB ?yb .
#     (?ya ?yb) math:product ?prod .
#     ?prod math:lessThan 0.0 .
#   } => {
#     _:b6 :a ?xa .
#     _:b6 :b ?xb .
#     _:b6 :ya ?ya .
#     _:b6 :yb ?yb .
#     :Interp1 :rootBracket _:b6 .
#   } .
# with substitution (on rule variables):
#   ?prod = "-1"^^xsd:decimal
#   ?xa = 0.0
#   ?xb = 1.0
#   ?ya = "-1"^^xsd:decimal
#   ?yb = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :ya "-1"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :yb "1"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :bracketA 0.0 .
#   :Interp1 :bracketB 1.0 .
#   :Interp1 :yAtBracketA "-1"^^xsd:decimal .
#   :Interp1 :yAtBracketB "1"^^xsd:decimal .
#   ("-1"^^xsd:decimal "1"^^xsd:decimal) math:product "-1"^^xsd:decimal .
#   "-1"^^xsd:decimal math:lessThan 0.0 .
# via the schematic forward rule:
#   {
#     :Interp1 :bracketA ?xa .
#     :Interp1 :bracketB ?xb .
#     :Interp1 :yAtBracketA ?ya .
#     :Interp1 :yAtBracketB ?yb .
#     (?ya ?yb) math:product ?prod .
#     ?prod math:lessThan 0.0 .
#   } => {
#     _:b6 :a ?xa .
#     _:b6 :b ?xb .
#     _:b6 :ya ?ya .
#     _:b6 :yb ?yb .
#     :Interp1 :rootBracket _:b6 .
#   } .
# with substitution (on rule variables):
#   ?prod = "-1"^^xsd:decimal
#   ?xa = 0.0
#   ?xb = 1.0
#   ?ya = "-1"^^xsd:decimal
#   ?yb = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :yb "1"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Interp1 :rootBracket _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :Interp1 :bracketA 0.0 .
#   :Interp1 :bracketB 1.0 .
#   :Interp1 :yAtBracketA "-1"^^xsd:decimal .
#   :Interp1 :yAtBracketB "1"^^xsd:decimal .
#   ("-1"^^xsd:decimal "1"^^xsd:decimal) math:product "-1"^^xsd:decimal .
#   "-1"^^xsd:decimal math:lessThan 0.0 .
# via the schematic forward rule:
#   {
#     :Interp1 :bracketA ?xa .
#     :Interp1 :bracketB ?xb .
#     :Interp1 :yAtBracketA ?ya .
#     :Interp1 :yAtBracketB ?yb .
#     (?ya ?yb) math:product ?prod .
#     ?prod math:lessThan 0.0 .
#   } => {
#     _:b6 :a ?xa .
#     _:b6 :b ?xb .
#     _:b6 :ya ?ya .
#     _:b6 :yb ?yb .
#     :Interp1 :rootBracket _:b6 .
#   } .
# with substitution (on rule variables):
#   ?prod = "-1"^^xsd:decimal
#   ?xa = 0.0
#   ?xb = 1.0
#   ?ya = "-1"^^xsd:decimal
#   ?yb = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Interp1 :rootBracket _:sk_0 .

