@prefix : <http://example.org/jade-eigen-loom#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :n 7 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:length 7 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#   } (20.0 7.0 6.0 5.0 4.0 3.0 2.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#   } (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)) log:collectAllIn ?_b1 .
#   (20.0 7.0 6.0 5.0 4.0 3.0 2.0) math:sum "47"^^xsd:decimal .
#   (-3.0 13.0 7.9 5.1 3.2 2.0 1.0) math:sum "29.2"^^xsd:decimal .
#   ("47"^^xsd:decimal 7) math:quotient "6.714285714285714"^^xsd:decimal .
#   ("29.2"^^xsd:decimal 7) math:quotient "4.171428571428572"^^xsd:decimal .
#   (?dx2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?dx 2.0) math:exponentiation ?dx2 .
#   } ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal) math:sum "223.42857142857142"^^xsd:decimal .
#   ("223.42857142857142"^^xsd:decimal 7) math:quotient "31.918367346938773"^^xsd:decimal .
#   (?dy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dy 2.0) math:exponentiation ?dy2 .
#   } ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal) math:sum "159.8542857142857"^^xsd:decimal .
#   ("159.8542857142857"^^xsd:decimal 7) math:quotient "22.836326530612244"^^xsd:decimal .
#   (?dxdy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dx ?dy) math:product ?dxdy .
#   } ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal) math:sum "-71.35714285714286"^^xsd:decimal .
#   ("-71.35714285714286"^^xsd:decimal 7) math:quotient "-10.193877551020408"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?sumX ?n) math:quotient ?meanX .
#     (?sumY ?n) math:quotient ?meanY .
#     (?dx2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x ?meanX) math:difference ?dx .
#         (?dx 2.0) math:exponentiation ?dx2 .
#     } ?dx2s) log:collectAllIn ?_b1 .
#     ?dx2s math:sum ?ssXX .
#     (?ssXX ?n) math:quotient ?covXX .
#     (?dy2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y ?meanY) math:difference ?dy .
#         (?dy 2.0) math:exponentiation ?dy2 .
#     } ?dy2s) log:collectAllIn ?_b1 .
#     ?dy2s math:sum ?ssYY .
#     (?ssYY ?n) math:quotient ?covYY .
#     (?dxdy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?meanX) math:difference ?dx .
#         (?y ?meanY) math:difference ?dy .
#         (?dx ?dy) math:product ?dxdy .
#     } ?dxdys) log:collectAllIn ?_b1 .
#     ?dxdys math:sum ?ssXY .
#     (?ssXY ?n) math:quotient ?covXY .
#   } => {
#     :PCA1 :n ?n .
#     :PCA1 :meanX ?meanX .
#     :PCA1 :meanY ?meanY .
#     :PCA1 :covXX ?covXX .
#     :PCA1 :covYY ?covYY .
#     :PCA1 :covXY ?covXY .
#   } .
# with substitution (on rule variables):
#   ?covXX = "31.918367346938773"^^xsd:decimal
#   ?covXY = "-10.193877551020408"^^xsd:decimal
#   ?covYY = "22.836326530612244"^^xsd:decimal
#   ?dx2s = ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)
#   ?dxdys = ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)
#   ?dy2s = ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)
#   ?meanX = "6.714285714285714"^^xsd:decimal
#   ?meanY = "4.171428571428572"^^xsd:decimal
#   ?n = 7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?ssXX = "223.42857142857142"^^xsd:decimal
#   ?ssXY = "-71.35714285714286"^^xsd:decimal
#   ?ssYY = "159.8542857142857"^^xsd:decimal
#   ?sumX = "47"^^xsd:decimal
#   ?sumY = "29.2"^^xsd:decimal
#   ?xs = (20.0 7.0 6.0 5.0 4.0 3.0 2.0)
#   ?ys = (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :n 7 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:length 7 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#   } (20.0 7.0 6.0 5.0 4.0 3.0 2.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#   } (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)) log:collectAllIn ?_b1 .
#   (20.0 7.0 6.0 5.0 4.0 3.0 2.0) math:sum "47"^^xsd:decimal .
#   (-3.0 13.0 7.9 5.1 3.2 2.0 1.0) math:sum "29.2"^^xsd:decimal .
#   ("47"^^xsd:decimal 7) math:quotient "6.714285714285714"^^xsd:decimal .
#   ("29.2"^^xsd:decimal 7) math:quotient "4.171428571428572"^^xsd:decimal .
#   (?dx2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?dx 2.0) math:exponentiation ?dx2 .
#   } ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal) math:sum "223.42857142857142"^^xsd:decimal .
#   ("223.42857142857142"^^xsd:decimal 7) math:quotient "31.918367346938773"^^xsd:decimal .
#   (?dy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dy 2.0) math:exponentiation ?dy2 .
#   } ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal) math:sum "159.8542857142857"^^xsd:decimal .
#   ("159.8542857142857"^^xsd:decimal 7) math:quotient "22.836326530612244"^^xsd:decimal .
#   (?dxdy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dx ?dy) math:product ?dxdy .
#   } ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal) math:sum "-71.35714285714286"^^xsd:decimal .
#   ("-71.35714285714286"^^xsd:decimal 7) math:quotient "-10.193877551020408"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?sumX ?n) math:quotient ?meanX .
#     (?sumY ?n) math:quotient ?meanY .
#     (?dx2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x ?meanX) math:difference ?dx .
#         (?dx 2.0) math:exponentiation ?dx2 .
#     } ?dx2s) log:collectAllIn ?_b1 .
#     ?dx2s math:sum ?ssXX .
#     (?ssXX ?n) math:quotient ?covXX .
#     (?dy2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y ?meanY) math:difference ?dy .
#         (?dy 2.0) math:exponentiation ?dy2 .
#     } ?dy2s) log:collectAllIn ?_b1 .
#     ?dy2s math:sum ?ssYY .
#     (?ssYY ?n) math:quotient ?covYY .
#     (?dxdy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?meanX) math:difference ?dx .
#         (?y ?meanY) math:difference ?dy .
#         (?dx ?dy) math:product ?dxdy .
#     } ?dxdys) log:collectAllIn ?_b1 .
#     ?dxdys math:sum ?ssXY .
#     (?ssXY ?n) math:quotient ?covXY .
#   } => {
#     :PCA1 :n ?n .
#     :PCA1 :meanX ?meanX .
#     :PCA1 :meanY ?meanY .
#     :PCA1 :covXX ?covXX .
#     :PCA1 :covYY ?covYY .
#     :PCA1 :covXY ?covXY .
#   } .
# with substitution (on rule variables):
#   ?covXX = "31.918367346938773"^^xsd:decimal
#   ?covXY = "-10.193877551020408"^^xsd:decimal
#   ?covYY = "22.836326530612244"^^xsd:decimal
#   ?dx2s = ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)
#   ?dxdys = ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)
#   ?dy2s = ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)
#   ?meanX = "6.714285714285714"^^xsd:decimal
#   ?meanY = "4.171428571428572"^^xsd:decimal
#   ?n = 7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?ssXX = "223.42857142857142"^^xsd:decimal
#   ?ssXY = "-71.35714285714286"^^xsd:decimal
#   ?ssYY = "159.8542857142857"^^xsd:decimal
#   ?sumX = "47"^^xsd:decimal
#   ?sumY = "29.2"^^xsd:decimal
#   ?xs = (20.0 7.0 6.0 5.0 4.0 3.0 2.0)
#   ?ys = (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :meanX "6.714285714285714"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:length 7 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#   } (20.0 7.0 6.0 5.0 4.0 3.0 2.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#   } (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)) log:collectAllIn ?_b1 .
#   (20.0 7.0 6.0 5.0 4.0 3.0 2.0) math:sum "47"^^xsd:decimal .
#   (-3.0 13.0 7.9 5.1 3.2 2.0 1.0) math:sum "29.2"^^xsd:decimal .
#   ("47"^^xsd:decimal 7) math:quotient "6.714285714285714"^^xsd:decimal .
#   ("29.2"^^xsd:decimal 7) math:quotient "4.171428571428572"^^xsd:decimal .
#   (?dx2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?dx 2.0) math:exponentiation ?dx2 .
#   } ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal) math:sum "223.42857142857142"^^xsd:decimal .
#   ("223.42857142857142"^^xsd:decimal 7) math:quotient "31.918367346938773"^^xsd:decimal .
#   (?dy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dy 2.0) math:exponentiation ?dy2 .
#   } ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal) math:sum "159.8542857142857"^^xsd:decimal .
#   ("159.8542857142857"^^xsd:decimal 7) math:quotient "22.836326530612244"^^xsd:decimal .
#   (?dxdy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dx ?dy) math:product ?dxdy .
#   } ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal) math:sum "-71.35714285714286"^^xsd:decimal .
#   ("-71.35714285714286"^^xsd:decimal 7) math:quotient "-10.193877551020408"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?sumX ?n) math:quotient ?meanX .
#     (?sumY ?n) math:quotient ?meanY .
#     (?dx2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x ?meanX) math:difference ?dx .
#         (?dx 2.0) math:exponentiation ?dx2 .
#     } ?dx2s) log:collectAllIn ?_b1 .
#     ?dx2s math:sum ?ssXX .
#     (?ssXX ?n) math:quotient ?covXX .
#     (?dy2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y ?meanY) math:difference ?dy .
#         (?dy 2.0) math:exponentiation ?dy2 .
#     } ?dy2s) log:collectAllIn ?_b1 .
#     ?dy2s math:sum ?ssYY .
#     (?ssYY ?n) math:quotient ?covYY .
#     (?dxdy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?meanX) math:difference ?dx .
#         (?y ?meanY) math:difference ?dy .
#         (?dx ?dy) math:product ?dxdy .
#     } ?dxdys) log:collectAllIn ?_b1 .
#     ?dxdys math:sum ?ssXY .
#     (?ssXY ?n) math:quotient ?covXY .
#   } => {
#     :PCA1 :n ?n .
#     :PCA1 :meanX ?meanX .
#     :PCA1 :meanY ?meanY .
#     :PCA1 :covXX ?covXX .
#     :PCA1 :covYY ?covYY .
#     :PCA1 :covXY ?covXY .
#   } .
# with substitution (on rule variables):
#   ?covXX = "31.918367346938773"^^xsd:decimal
#   ?covXY = "-10.193877551020408"^^xsd:decimal
#   ?covYY = "22.836326530612244"^^xsd:decimal
#   ?dx2s = ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)
#   ?dxdys = ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)
#   ?dy2s = ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)
#   ?meanX = "6.714285714285714"^^xsd:decimal
#   ?meanY = "4.171428571428572"^^xsd:decimal
#   ?n = 7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?ssXX = "223.42857142857142"^^xsd:decimal
#   ?ssXY = "-71.35714285714286"^^xsd:decimal
#   ?ssYY = "159.8542857142857"^^xsd:decimal
#   ?sumX = "47"^^xsd:decimal
#   ?sumY = "29.2"^^xsd:decimal
#   ?xs = (20.0 7.0 6.0 5.0 4.0 3.0 2.0)
#   ?ys = (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :meanY "4.171428571428572"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:length 7 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#   } (20.0 7.0 6.0 5.0 4.0 3.0 2.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#   } (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)) log:collectAllIn ?_b1 .
#   (20.0 7.0 6.0 5.0 4.0 3.0 2.0) math:sum "47"^^xsd:decimal .
#   (-3.0 13.0 7.9 5.1 3.2 2.0 1.0) math:sum "29.2"^^xsd:decimal .
#   ("47"^^xsd:decimal 7) math:quotient "6.714285714285714"^^xsd:decimal .
#   ("29.2"^^xsd:decimal 7) math:quotient "4.171428571428572"^^xsd:decimal .
#   (?dx2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?dx 2.0) math:exponentiation ?dx2 .
#   } ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal) math:sum "223.42857142857142"^^xsd:decimal .
#   ("223.42857142857142"^^xsd:decimal 7) math:quotient "31.918367346938773"^^xsd:decimal .
#   (?dy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dy 2.0) math:exponentiation ?dy2 .
#   } ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal) math:sum "159.8542857142857"^^xsd:decimal .
#   ("159.8542857142857"^^xsd:decimal 7) math:quotient "22.836326530612244"^^xsd:decimal .
#   (?dxdy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dx ?dy) math:product ?dxdy .
#   } ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal) math:sum "-71.35714285714286"^^xsd:decimal .
#   ("-71.35714285714286"^^xsd:decimal 7) math:quotient "-10.193877551020408"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?sumX ?n) math:quotient ?meanX .
#     (?sumY ?n) math:quotient ?meanY .
#     (?dx2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x ?meanX) math:difference ?dx .
#         (?dx 2.0) math:exponentiation ?dx2 .
#     } ?dx2s) log:collectAllIn ?_b1 .
#     ?dx2s math:sum ?ssXX .
#     (?ssXX ?n) math:quotient ?covXX .
#     (?dy2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y ?meanY) math:difference ?dy .
#         (?dy 2.0) math:exponentiation ?dy2 .
#     } ?dy2s) log:collectAllIn ?_b1 .
#     ?dy2s math:sum ?ssYY .
#     (?ssYY ?n) math:quotient ?covYY .
#     (?dxdy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?meanX) math:difference ?dx .
#         (?y ?meanY) math:difference ?dy .
#         (?dx ?dy) math:product ?dxdy .
#     } ?dxdys) log:collectAllIn ?_b1 .
#     ?dxdys math:sum ?ssXY .
#     (?ssXY ?n) math:quotient ?covXY .
#   } => {
#     :PCA1 :n ?n .
#     :PCA1 :meanX ?meanX .
#     :PCA1 :meanY ?meanY .
#     :PCA1 :covXX ?covXX .
#     :PCA1 :covYY ?covYY .
#     :PCA1 :covXY ?covXY .
#   } .
# with substitution (on rule variables):
#   ?covXX = "31.918367346938773"^^xsd:decimal
#   ?covXY = "-10.193877551020408"^^xsd:decimal
#   ?covYY = "22.836326530612244"^^xsd:decimal
#   ?dx2s = ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)
#   ?dxdys = ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)
#   ?dy2s = ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)
#   ?meanX = "6.714285714285714"^^xsd:decimal
#   ?meanY = "4.171428571428572"^^xsd:decimal
#   ?n = 7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?ssXX = "223.42857142857142"^^xsd:decimal
#   ?ssXY = "-71.35714285714286"^^xsd:decimal
#   ?ssYY = "159.8542857142857"^^xsd:decimal
#   ?sumX = "47"^^xsd:decimal
#   ?sumY = "29.2"^^xsd:decimal
#   ?xs = (20.0 7.0 6.0 5.0 4.0 3.0 2.0)
#   ?ys = (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :covXX "31.918367346938773"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:length 7 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#   } (20.0 7.0 6.0 5.0 4.0 3.0 2.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#   } (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)) log:collectAllIn ?_b1 .
#   (20.0 7.0 6.0 5.0 4.0 3.0 2.0) math:sum "47"^^xsd:decimal .
#   (-3.0 13.0 7.9 5.1 3.2 2.0 1.0) math:sum "29.2"^^xsd:decimal .
#   ("47"^^xsd:decimal 7) math:quotient "6.714285714285714"^^xsd:decimal .
#   ("29.2"^^xsd:decimal 7) math:quotient "4.171428571428572"^^xsd:decimal .
#   (?dx2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?dx 2.0) math:exponentiation ?dx2 .
#   } ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal) math:sum "223.42857142857142"^^xsd:decimal .
#   ("223.42857142857142"^^xsd:decimal 7) math:quotient "31.918367346938773"^^xsd:decimal .
#   (?dy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dy 2.0) math:exponentiation ?dy2 .
#   } ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal) math:sum "159.8542857142857"^^xsd:decimal .
#   ("159.8542857142857"^^xsd:decimal 7) math:quotient "22.836326530612244"^^xsd:decimal .
#   (?dxdy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dx ?dy) math:product ?dxdy .
#   } ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal) math:sum "-71.35714285714286"^^xsd:decimal .
#   ("-71.35714285714286"^^xsd:decimal 7) math:quotient "-10.193877551020408"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?sumX ?n) math:quotient ?meanX .
#     (?sumY ?n) math:quotient ?meanY .
#     (?dx2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x ?meanX) math:difference ?dx .
#         (?dx 2.0) math:exponentiation ?dx2 .
#     } ?dx2s) log:collectAllIn ?_b1 .
#     ?dx2s math:sum ?ssXX .
#     (?ssXX ?n) math:quotient ?covXX .
#     (?dy2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y ?meanY) math:difference ?dy .
#         (?dy 2.0) math:exponentiation ?dy2 .
#     } ?dy2s) log:collectAllIn ?_b1 .
#     ?dy2s math:sum ?ssYY .
#     (?ssYY ?n) math:quotient ?covYY .
#     (?dxdy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?meanX) math:difference ?dx .
#         (?y ?meanY) math:difference ?dy .
#         (?dx ?dy) math:product ?dxdy .
#     } ?dxdys) log:collectAllIn ?_b1 .
#     ?dxdys math:sum ?ssXY .
#     (?ssXY ?n) math:quotient ?covXY .
#   } => {
#     :PCA1 :n ?n .
#     :PCA1 :meanX ?meanX .
#     :PCA1 :meanY ?meanY .
#     :PCA1 :covXX ?covXX .
#     :PCA1 :covYY ?covYY .
#     :PCA1 :covXY ?covXY .
#   } .
# with substitution (on rule variables):
#   ?covXX = "31.918367346938773"^^xsd:decimal
#   ?covXY = "-10.193877551020408"^^xsd:decimal
#   ?covYY = "22.836326530612244"^^xsd:decimal
#   ?dx2s = ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)
#   ?dxdys = ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)
#   ?dy2s = ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)
#   ?meanX = "6.714285714285714"^^xsd:decimal
#   ?meanY = "4.171428571428572"^^xsd:decimal
#   ?n = 7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?ssXX = "223.42857142857142"^^xsd:decimal
#   ?ssXY = "-71.35714285714286"^^xsd:decimal
#   ?ssYY = "159.8542857142857"^^xsd:decimal
#   ?sumX = "47"^^xsd:decimal
#   ?sumY = "29.2"^^xsd:decimal
#   ?xs = (20.0 7.0 6.0 5.0 4.0 3.0 2.0)
#   ?ys = (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :covYY "22.836326530612244"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:length 7 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#   } (20.0 7.0 6.0 5.0 4.0 3.0 2.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#   } (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)) log:collectAllIn ?_b1 .
#   (20.0 7.0 6.0 5.0 4.0 3.0 2.0) math:sum "47"^^xsd:decimal .
#   (-3.0 13.0 7.9 5.1 3.2 2.0 1.0) math:sum "29.2"^^xsd:decimal .
#   ("47"^^xsd:decimal 7) math:quotient "6.714285714285714"^^xsd:decimal .
#   ("29.2"^^xsd:decimal 7) math:quotient "4.171428571428572"^^xsd:decimal .
#   (?dx2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?dx 2.0) math:exponentiation ?dx2 .
#   } ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal) math:sum "223.42857142857142"^^xsd:decimal .
#   ("223.42857142857142"^^xsd:decimal 7) math:quotient "31.918367346938773"^^xsd:decimal .
#   (?dy2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :y ?y .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dy 2.0) math:exponentiation ?dy2 .
#   } ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal) math:sum "159.8542857142857"^^xsd:decimal .
#   ("159.8542857142857"^^xsd:decimal 7) math:quotient "22.836326530612244"^^xsd:decimal .
#   (?dxdy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x "6.714285714285714"^^xsd:decimal) math:difference ?dx .
#       (?y "4.171428571428572"^^xsd:decimal) math:difference ?dy .
#       (?dx ?dy) math:product ?dxdy .
#   } ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal) math:sum "-71.35714285714286"^^xsd:decimal .
#   ("-71.35714285714286"^^xsd:decimal 7) math:quotient "-10.193877551020408"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?sumX ?n) math:quotient ?meanX .
#     (?sumY ?n) math:quotient ?meanY .
#     (?dx2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x ?meanX) math:difference ?dx .
#         (?dx 2.0) math:exponentiation ?dx2 .
#     } ?dx2s) log:collectAllIn ?_b1 .
#     ?dx2s math:sum ?ssXX .
#     (?ssXX ?n) math:quotient ?covXX .
#     (?dy2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y ?meanY) math:difference ?dy .
#         (?dy 2.0) math:exponentiation ?dy2 .
#     } ?dy2s) log:collectAllIn ?_b1 .
#     ?dy2s math:sum ?ssYY .
#     (?ssYY ?n) math:quotient ?covYY .
#     (?dxdy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?meanX) math:difference ?dx .
#         (?y ?meanY) math:difference ?dy .
#         (?dx ?dy) math:product ?dxdy .
#     } ?dxdys) log:collectAllIn ?_b1 .
#     ?dxdys math:sum ?ssXY .
#     (?ssXY ?n) math:quotient ?covXY .
#   } => {
#     :PCA1 :n ?n .
#     :PCA1 :meanX ?meanX .
#     :PCA1 :meanY ?meanY .
#     :PCA1 :covXX ?covXX .
#     :PCA1 :covYY ?covYY .
#     :PCA1 :covXY ?covXY .
#   } .
# with substitution (on rule variables):
#   ?covXX = "31.918367346938773"^^xsd:decimal
#   ?covXY = "-10.193877551020408"^^xsd:decimal
#   ?covYY = "22.836326530612244"^^xsd:decimal
#   ?dx2s = ("176.51020408163262"^^xsd:decimal "0.08163265306122441"^^xsd:decimal "0.5102040816326533"^^xsd:decimal "2.9387755102040822"^^xsd:decimal "7.367346938775511"^^xsd:decimal "13.795918367346939"^^xsd:decimal "22.22448979591837"^^xsd:decimal)
#   ?dxdys = ("-95.27755102040815"^^xsd:decimal "2.522448979591836"^^xsd:decimal "-2.6632653061224496"^^xsd:decimal "-1.5918367346938767"^^xsd:decimal "2.6367346938775515"^^xsd:decimal "8.06530612244898"^^xsd:decimal "14.951020408163266"^^xsd:decimal)
#   ?dy2s = ("51.42938775510204"^^xsd:decimal "77.94367346938776"^^xsd:decimal "13.902244897959184"^^xsd:decimal "0.8622448979591825"^^xsd:decimal "0.9436734693877553"^^xsd:decimal "4.715102040816328"^^xsd:decimal "10.057959183673471"^^xsd:decimal)
#   ?meanX = "6.714285714285714"^^xsd:decimal
#   ?meanY = "4.171428571428572"^^xsd:decimal
#   ?n = 7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?ssXX = "223.42857142857142"^^xsd:decimal
#   ?ssXY = "-71.35714285714286"^^xsd:decimal
#   ?ssYY = "159.8542857142857"^^xsd:decimal
#   ?sumX = "47"^^xsd:decimal
#   ?sumY = "29.2"^^xsd:decimal
#   ?xs = (20.0 7.0 6.0 5.0 4.0 3.0 2.0)
#   ?ys = (-3.0 13.0 7.9 5.1 3.2 2.0 1.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :covXY "-10.193877551020408"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:sum "54.75469387755102"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:product "728.8982590587254"^^xsd:decimal .
#   ("-10.193877551020408"^^xsd:decimal 2.0) math:exponentiation "103.91513952519784"^^xsd:decimal .
#   ("728.8982590587254"^^xsd:decimal "103.91513952519784"^^xsd:decimal) math:difference "624.9831195335275"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal 2.0) math:exponentiation "2998.076501624323"^^xsd:decimal .
#   (4.0 "624.9831195335275"^^xsd:decimal) math:product "2499.93247813411"^^xsd:decimal .
#   ("2998.076501624323"^^xsd:decimal "2499.93247813411"^^xsd:decimal) math:difference "498.14402349021293"^^xsd:decimal .
#   ("498.14402349021293"^^xsd:decimal 0.5) math:exponentiation "22.319140294603933"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal "22.319140294603933"^^xsd:decimal) math:sum "77.07383417215496"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal "22.319140294603933"^^xsd:decimal) math:difference "32.43555358294709"^^xsd:decimal .
#   ("77.07383417215496"^^xsd:decimal 2.0) math:quotient "38.53691708607748"^^xsd:decimal .
#   ("32.43555358294709"^^xsd:decimal 2.0) math:quotient "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal "54.75469387755102"^^xsd:decimal) math:quotient "0.7038102919953919"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:sum ?tr .
#     (?a ?d) math:product ?ad .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?ad ?b2) math:difference ?det .
#     (?tr 2.0) math:exponentiation ?tr2 .
#     (4.0 ?det) math:product ?fourDet .
#     (?tr2 ?fourDet) math:difference ?disc .
#     (?disc 0.5) math:exponentiation ?sqrtDisc .
#     (?tr ?sqrtDisc) math:sum ?trPlus .
#     (?tr ?sqrtDisc) math:difference ?trMinus .
#     (?trPlus 2.0) math:quotient ?lambda1 .
#     (?trMinus 2.0) math:quotient ?lambda2 .
#     (?lambda1 ?tr) math:quotient ?explained1 .
#   } => {
#     :PCA1 :lambda1 ?lambda1 .
#     :PCA1 :lambda2 ?lambda2 .
#     :PCA1 :explainedVar1 ?explained1 .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?ad = "728.8982590587254"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?b2 = "103.91513952519784"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?det = "624.9831195335275"^^xsd:decimal
#   ?disc = "498.14402349021293"^^xsd:decimal
#   ?explained1 = "0.7038102919953919"^^xsd:decimal
#   ?fourDet = "2499.93247813411"^^xsd:decimal
#   ?lambda1 = "38.53691708607748"^^xsd:decimal
#   ?lambda2 = "16.217776791473543"^^xsd:decimal
#   ?sqrtDisc = "22.319140294603933"^^xsd:decimal
#   ?tr = "54.75469387755102"^^xsd:decimal
#   ?tr2 = "2998.076501624323"^^xsd:decimal
#   ?trMinus = "32.43555358294709"^^xsd:decimal
#   ?trPlus = "77.07383417215496"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:sum "54.75469387755102"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:product "728.8982590587254"^^xsd:decimal .
#   ("-10.193877551020408"^^xsd:decimal 2.0) math:exponentiation "103.91513952519784"^^xsd:decimal .
#   ("728.8982590587254"^^xsd:decimal "103.91513952519784"^^xsd:decimal) math:difference "624.9831195335275"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal 2.0) math:exponentiation "2998.076501624323"^^xsd:decimal .
#   (4.0 "624.9831195335275"^^xsd:decimal) math:product "2499.93247813411"^^xsd:decimal .
#   ("2998.076501624323"^^xsd:decimal "2499.93247813411"^^xsd:decimal) math:difference "498.14402349021293"^^xsd:decimal .
#   ("498.14402349021293"^^xsd:decimal 0.5) math:exponentiation "22.319140294603933"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal "22.319140294603933"^^xsd:decimal) math:sum "77.07383417215496"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal "22.319140294603933"^^xsd:decimal) math:difference "32.43555358294709"^^xsd:decimal .
#   ("77.07383417215496"^^xsd:decimal 2.0) math:quotient "38.53691708607748"^^xsd:decimal .
#   ("32.43555358294709"^^xsd:decimal 2.0) math:quotient "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal "54.75469387755102"^^xsd:decimal) math:quotient "0.7038102919953919"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:sum ?tr .
#     (?a ?d) math:product ?ad .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?ad ?b2) math:difference ?det .
#     (?tr 2.0) math:exponentiation ?tr2 .
#     (4.0 ?det) math:product ?fourDet .
#     (?tr2 ?fourDet) math:difference ?disc .
#     (?disc 0.5) math:exponentiation ?sqrtDisc .
#     (?tr ?sqrtDisc) math:sum ?trPlus .
#     (?tr ?sqrtDisc) math:difference ?trMinus .
#     (?trPlus 2.0) math:quotient ?lambda1 .
#     (?trMinus 2.0) math:quotient ?lambda2 .
#     (?lambda1 ?tr) math:quotient ?explained1 .
#   } => {
#     :PCA1 :lambda1 ?lambda1 .
#     :PCA1 :lambda2 ?lambda2 .
#     :PCA1 :explainedVar1 ?explained1 .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?ad = "728.8982590587254"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?b2 = "103.91513952519784"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?det = "624.9831195335275"^^xsd:decimal
#   ?disc = "498.14402349021293"^^xsd:decimal
#   ?explained1 = "0.7038102919953919"^^xsd:decimal
#   ?fourDet = "2499.93247813411"^^xsd:decimal
#   ?lambda1 = "38.53691708607748"^^xsd:decimal
#   ?lambda2 = "16.217776791473543"^^xsd:decimal
#   ?sqrtDisc = "22.319140294603933"^^xsd:decimal
#   ?tr = "54.75469387755102"^^xsd:decimal
#   ?tr2 = "2998.076501624323"^^xsd:decimal
#   ?trMinus = "32.43555358294709"^^xsd:decimal
#   ?trPlus = "77.07383417215496"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :explainedVar1 "0.7038102919953919"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:sum "54.75469387755102"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:product "728.8982590587254"^^xsd:decimal .
#   ("-10.193877551020408"^^xsd:decimal 2.0) math:exponentiation "103.91513952519784"^^xsd:decimal .
#   ("728.8982590587254"^^xsd:decimal "103.91513952519784"^^xsd:decimal) math:difference "624.9831195335275"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal 2.0) math:exponentiation "2998.076501624323"^^xsd:decimal .
#   (4.0 "624.9831195335275"^^xsd:decimal) math:product "2499.93247813411"^^xsd:decimal .
#   ("2998.076501624323"^^xsd:decimal "2499.93247813411"^^xsd:decimal) math:difference "498.14402349021293"^^xsd:decimal .
#   ("498.14402349021293"^^xsd:decimal 0.5) math:exponentiation "22.319140294603933"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal "22.319140294603933"^^xsd:decimal) math:sum "77.07383417215496"^^xsd:decimal .
#   ("54.75469387755102"^^xsd:decimal "22.319140294603933"^^xsd:decimal) math:difference "32.43555358294709"^^xsd:decimal .
#   ("77.07383417215496"^^xsd:decimal 2.0) math:quotient "38.53691708607748"^^xsd:decimal .
#   ("32.43555358294709"^^xsd:decimal 2.0) math:quotient "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal "54.75469387755102"^^xsd:decimal) math:quotient "0.7038102919953919"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:sum ?tr .
#     (?a ?d) math:product ?ad .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?ad ?b2) math:difference ?det .
#     (?tr 2.0) math:exponentiation ?tr2 .
#     (4.0 ?det) math:product ?fourDet .
#     (?tr2 ?fourDet) math:difference ?disc .
#     (?disc 0.5) math:exponentiation ?sqrtDisc .
#     (?tr ?sqrtDisc) math:sum ?trPlus .
#     (?tr ?sqrtDisc) math:difference ?trMinus .
#     (?trPlus 2.0) math:quotient ?lambda1 .
#     (?trMinus 2.0) math:quotient ?lambda2 .
#     (?lambda1 ?tr) math:quotient ?explained1 .
#   } => {
#     :PCA1 :lambda1 ?lambda1 .
#     :PCA1 :lambda2 ?lambda2 .
#     :PCA1 :explainedVar1 ?explained1 .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?ad = "728.8982590587254"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?b2 = "103.91513952519784"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?det = "624.9831195335275"^^xsd:decimal
#   ?disc = "498.14402349021293"^^xsd:decimal
#   ?explained1 = "0.7038102919953919"^^xsd:decimal
#   ?fourDet = "2499.93247813411"^^xsd:decimal
#   ?lambda1 = "38.53691708607748"^^xsd:decimal
#   ?lambda2 = "16.217776791473543"^^xsd:decimal
#   ?sqrtDisc = "22.319140294603933"^^xsd:decimal
#   ?tr = "54.75469387755102"^^xsd:decimal
#   ?tr2 = "2998.076501624323"^^xsd:decimal
#   ?trMinus = "32.43555358294709"^^xsd:decimal
#   ?trPlus = "77.07383417215496"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :explainedVar1 "0.7038102919953919"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :_phi "-1.1517197151996337"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:difference "9.08204081632653"^^xsd:decimal .
#   (2.0 "-10.193877551020408"^^xsd:decimal) math:product "-20.387755102040817"^^xsd:decimal .
#   ("-20.387755102040817"^^xsd:decimal "9.08204081632653"^^xsd:decimal) math:quotient "-2.2448429284077123"^^xsd:decimal .
#   "-2.2448429284077123"^^xsd:decimal math:atan "-1.1517197151996337"^^xsd:decimal .
#   "9.08204081632653"^^xsd:decimal math:notEqualTo 0.0 .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:difference ?diff .
#     (2.0 ?b) math:product ?twoB .
#     (?twoB ?diff) math:quotient ?ratio .
#     ?ratio math:atan ?phi .
#     ?diff math:notEqualTo 0.0 .
#   } => {
#     :PCA1 :_phi ?phi .
#     :PCA1 :_diff ?diff .
#     :PCA1 :_twoB ?twoB .
#     :PCA1 :_b ?b .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?diff = "9.08204081632653"^^xsd:decimal
#   ?phi = "-1.1517197151996337"^^xsd:decimal
#   ?ratio = "-2.2448429284077123"^^xsd:decimal
#   ?twoB = "-20.387755102040817"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :_phi "-1.1517197151996337"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :_diff "9.08204081632653"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:difference "9.08204081632653"^^xsd:decimal .
#   (2.0 "-10.193877551020408"^^xsd:decimal) math:product "-20.387755102040817"^^xsd:decimal .
#   ("-20.387755102040817"^^xsd:decimal "9.08204081632653"^^xsd:decimal) math:quotient "-2.2448429284077123"^^xsd:decimal .
#   "-2.2448429284077123"^^xsd:decimal math:atan "-1.1517197151996337"^^xsd:decimal .
#   "9.08204081632653"^^xsd:decimal math:notEqualTo 0.0 .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:difference ?diff .
#     (2.0 ?b) math:product ?twoB .
#     (?twoB ?diff) math:quotient ?ratio .
#     ?ratio math:atan ?phi .
#     ?diff math:notEqualTo 0.0 .
#   } => {
#     :PCA1 :_phi ?phi .
#     :PCA1 :_diff ?diff .
#     :PCA1 :_twoB ?twoB .
#     :PCA1 :_b ?b .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?diff = "9.08204081632653"^^xsd:decimal
#   ?phi = "-1.1517197151996337"^^xsd:decimal
#   ?ratio = "-2.2448429284077123"^^xsd:decimal
#   ?twoB = "-20.387755102040817"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :_diff "9.08204081632653"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :_twoB "-20.387755102040817"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:difference "9.08204081632653"^^xsd:decimal .
#   (2.0 "-10.193877551020408"^^xsd:decimal) math:product "-20.387755102040817"^^xsd:decimal .
#   ("-20.387755102040817"^^xsd:decimal "9.08204081632653"^^xsd:decimal) math:quotient "-2.2448429284077123"^^xsd:decimal .
#   "-2.2448429284077123"^^xsd:decimal math:atan "-1.1517197151996337"^^xsd:decimal .
#   "9.08204081632653"^^xsd:decimal math:notEqualTo 0.0 .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:difference ?diff .
#     (2.0 ?b) math:product ?twoB .
#     (?twoB ?diff) math:quotient ?ratio .
#     ?ratio math:atan ?phi .
#     ?diff math:notEqualTo 0.0 .
#   } => {
#     :PCA1 :_phi ?phi .
#     :PCA1 :_diff ?diff .
#     :PCA1 :_twoB ?twoB .
#     :PCA1 :_b ?b .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?diff = "9.08204081632653"^^xsd:decimal
#   ?phi = "-1.1517197151996337"^^xsd:decimal
#   ?ratio = "-2.2448429284077123"^^xsd:decimal
#   ?twoB = "-20.387755102040817"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :_twoB "-20.387755102040817"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :_b "-10.193877551020408"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :covXX "31.918367346938773"^^xsd:decimal .
#   :PCA1 :covYY "22.836326530612244"^^xsd:decimal .
#   :PCA1 :covXY "-10.193877551020408"^^xsd:decimal .
#   ("31.918367346938773"^^xsd:decimal "22.836326530612244"^^xsd:decimal) math:difference "9.08204081632653"^^xsd:decimal .
#   (2.0 "-10.193877551020408"^^xsd:decimal) math:product "-20.387755102040817"^^xsd:decimal .
#   ("-20.387755102040817"^^xsd:decimal "9.08204081632653"^^xsd:decimal) math:quotient "-2.2448429284077123"^^xsd:decimal .
#   "-2.2448429284077123"^^xsd:decimal math:atan "-1.1517197151996337"^^xsd:decimal .
#   "9.08204081632653"^^xsd:decimal math:notEqualTo 0.0 .
# via the schematic forward rule:
#   {
#     :PCA1 :covXX ?a .
#     :PCA1 :covYY ?d .
#     :PCA1 :covXY ?b .
#     (?a ?d) math:difference ?diff .
#     (2.0 ?b) math:product ?twoB .
#     (?twoB ?diff) math:quotient ?ratio .
#     ?ratio math:atan ?phi .
#     ?diff math:notEqualTo 0.0 .
#   } => {
#     :PCA1 :_phi ?phi .
#     :PCA1 :_diff ?diff .
#     :PCA1 :_twoB ?twoB .
#     :PCA1 :_b ?b .
#   } .
# with substitution (on rule variables):
#   ?a = "31.918367346938773"^^xsd:decimal
#   ?b = "-10.193877551020408"^^xsd:decimal
#   ?d = "22.836326530612244"^^xsd:decimal
#   ?diff = "9.08204081632653"^^xsd:decimal
#   ?phi = "-1.1517197151996337"^^xsd:decimal
#   ?ratio = "-2.2448429284077123"^^xsd:decimal
#   ?twoB = "-20.387755102040817"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :_b "-10.193877551020408"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :_phi "-1.1517197151996337"^^xsd:decimal .
#   :PCA1 :_diff "9.08204081632653"^^xsd:decimal .
#   (0.5 "-1.1517197151996337"^^xsd:decimal) math:product "-0.5758598575998168"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:degrees "-32.99433943147409"^^xsd:decimal .
#   "9.08204081632653"^^xsd:decimal math:greaterThan 0.0 .
# via the schematic forward rule:
#   {
#     :PCA1 :_phi ?phi .
#     :PCA1 :_diff ?diff .
#     (0.5 ?phi) math:product ?theta .
#     ?theta math:degrees ?thetaDeg .
#     ?diff math:greaterThan 0.0 .
#   } => {
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :thetaDeg ?thetaDeg .
#   } .
# with substitution (on rule variables):
#   ?diff = "9.08204081632653"^^xsd:decimal
#   ?phi = "-1.1517197151996337"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?thetaDeg = "-32.99433943147409"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :thetaDeg "-32.99433943147409"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :_phi "-1.1517197151996337"^^xsd:decimal .
#   :PCA1 :_diff "9.08204081632653"^^xsd:decimal .
#   (0.5 "-1.1517197151996337"^^xsd:decimal) math:product "-0.5758598575998168"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:degrees "-32.99433943147409"^^xsd:decimal .
#   "9.08204081632653"^^xsd:decimal math:greaterThan 0.0 .
# via the schematic forward rule:
#   {
#     :PCA1 :_phi ?phi .
#     :PCA1 :_diff ?diff .
#     (0.5 ?phi) math:product ?theta .
#     ?theta math:degrees ?thetaDeg .
#     ?diff math:greaterThan 0.0 .
#   } => {
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :thetaDeg ?thetaDeg .
#   } .
# with substitution (on rule variables):
#   ?diff = "9.08204081632653"^^xsd:decimal
#   ?phi = "-1.1517197151996337"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?thetaDeg = "-32.99433943147409"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :thetaDeg "-32.99433943147409"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :point _:b7 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b7 .
#   _:b7 :x 20.0 .
#   _:b7 :y -3.0 .
#   (20.0 "6.714285714285714"^^xsd:decimal) math:difference "13.285714285714285"^^xsd:decimal .
#   (-3.0 "4.171428571428572"^^xsd:decimal) math:difference "-7.171428571428572"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "11.143052367800513"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "3.905245715227793"^^xsd:decimal .
#   ("11.143052367800513"^^xsd:decimal "3.905245715227793"^^xsd:decimal) math:sum "15.048298083028305"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-7.234817759286548"^^xsd:decimal .
#   (0.0 "-7.234817759286548"^^xsd:decimal) math:difference "7.234817759286548"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-6.014851923264363"^^xsd:decimal .
#   ("7.234817759286548"^^xsd:decimal "-6.014851923264363"^^xsd:decimal) math:sum "1.219965836022185"^^xsd:decimal .
#   ("15.048298083028305"^^xsd:decimal 2.0) math:exponentiation "226.45127519567336"^^xsd:decimal .
#   ("1.219965836022185"^^xsd:decimal 2.0) math:exponentiation "1.4883166410613087"^^xsd:decimal .
#   ("226.45127519567336"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "5.8762166856747635"^^xsd:decimal .
#   ("1.4883166410613087"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0917706946024678"^^xsd:decimal .
#   ("5.8762166856747635"^^xsd:decimal "0.0917706946024678"^^xsd:decimal) math:sum "5.967987380277231"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "13.285714285714285"^^xsd:decimal
#   ?dxC = "11.143052367800513"^^xsd:decimal
#   ?dxS = "-7.234817759286548"^^xsd:decimal
#   ?dy = "-7.171428571428572"^^xsd:decimal
#   ?dyC = "-6.014851923264363"^^xsd:decimal
#   ?dyS = "3.905245715227793"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "5.967987380277231"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "7.234817759286548"^^xsd:decimal
#   ?p = _:b7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "15.048298083028305"^^xsd:decimal
#   ?u2 = "226.45127519567336"^^xsd:decimal
#   ?u2Over = "5.8762166856747635"^^xsd:decimal
#   ?v = "1.219965836022185"^^xsd:decimal
#   ?v2 = "1.4883166410613087"^^xsd:decimal
#   ?v2Over = "0.0917706946024678"^^xsd:decimal
#   ?x = 20.0
#   ?y = -3.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :point _:b7 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :u "15.048298083028305"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b7 .
#   _:b7 :x 20.0 .
#   _:b7 :y -3.0 .
#   (20.0 "6.714285714285714"^^xsd:decimal) math:difference "13.285714285714285"^^xsd:decimal .
#   (-3.0 "4.171428571428572"^^xsd:decimal) math:difference "-7.171428571428572"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "11.143052367800513"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "3.905245715227793"^^xsd:decimal .
#   ("11.143052367800513"^^xsd:decimal "3.905245715227793"^^xsd:decimal) math:sum "15.048298083028305"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-7.234817759286548"^^xsd:decimal .
#   (0.0 "-7.234817759286548"^^xsd:decimal) math:difference "7.234817759286548"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-6.014851923264363"^^xsd:decimal .
#   ("7.234817759286548"^^xsd:decimal "-6.014851923264363"^^xsd:decimal) math:sum "1.219965836022185"^^xsd:decimal .
#   ("15.048298083028305"^^xsd:decimal 2.0) math:exponentiation "226.45127519567336"^^xsd:decimal .
#   ("1.219965836022185"^^xsd:decimal 2.0) math:exponentiation "1.4883166410613087"^^xsd:decimal .
#   ("226.45127519567336"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "5.8762166856747635"^^xsd:decimal .
#   ("1.4883166410613087"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0917706946024678"^^xsd:decimal .
#   ("5.8762166856747635"^^xsd:decimal "0.0917706946024678"^^xsd:decimal) math:sum "5.967987380277231"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "13.285714285714285"^^xsd:decimal
#   ?dxC = "11.143052367800513"^^xsd:decimal
#   ?dxS = "-7.234817759286548"^^xsd:decimal
#   ?dy = "-7.171428571428572"^^xsd:decimal
#   ?dyC = "-6.014851923264363"^^xsd:decimal
#   ?dyS = "3.905245715227793"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "5.967987380277231"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "7.234817759286548"^^xsd:decimal
#   ?p = _:b7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "15.048298083028305"^^xsd:decimal
#   ?u2 = "226.45127519567336"^^xsd:decimal
#   ?u2Over = "5.8762166856747635"^^xsd:decimal
#   ?v = "1.219965836022185"^^xsd:decimal
#   ?v2 = "1.4883166410613087"^^xsd:decimal
#   ?v2Over = "0.0917706946024678"^^xsd:decimal
#   ?x = 20.0
#   ?y = -3.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :u "15.048298083028305"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :v "1.219965836022185"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b7 .
#   _:b7 :x 20.0 .
#   _:b7 :y -3.0 .
#   (20.0 "6.714285714285714"^^xsd:decimal) math:difference "13.285714285714285"^^xsd:decimal .
#   (-3.0 "4.171428571428572"^^xsd:decimal) math:difference "-7.171428571428572"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "11.143052367800513"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "3.905245715227793"^^xsd:decimal .
#   ("11.143052367800513"^^xsd:decimal "3.905245715227793"^^xsd:decimal) math:sum "15.048298083028305"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-7.234817759286548"^^xsd:decimal .
#   (0.0 "-7.234817759286548"^^xsd:decimal) math:difference "7.234817759286548"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-6.014851923264363"^^xsd:decimal .
#   ("7.234817759286548"^^xsd:decimal "-6.014851923264363"^^xsd:decimal) math:sum "1.219965836022185"^^xsd:decimal .
#   ("15.048298083028305"^^xsd:decimal 2.0) math:exponentiation "226.45127519567336"^^xsd:decimal .
#   ("1.219965836022185"^^xsd:decimal 2.0) math:exponentiation "1.4883166410613087"^^xsd:decimal .
#   ("226.45127519567336"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "5.8762166856747635"^^xsd:decimal .
#   ("1.4883166410613087"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0917706946024678"^^xsd:decimal .
#   ("5.8762166856747635"^^xsd:decimal "0.0917706946024678"^^xsd:decimal) math:sum "5.967987380277231"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "13.285714285714285"^^xsd:decimal
#   ?dxC = "11.143052367800513"^^xsd:decimal
#   ?dxS = "-7.234817759286548"^^xsd:decimal
#   ?dy = "-7.171428571428572"^^xsd:decimal
#   ?dyC = "-6.014851923264363"^^xsd:decimal
#   ?dyS = "3.905245715227793"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "5.967987380277231"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "7.234817759286548"^^xsd:decimal
#   ?p = _:b7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "15.048298083028305"^^xsd:decimal
#   ?u2 = "226.45127519567336"^^xsd:decimal
#   ?u2Over = "5.8762166856747635"^^xsd:decimal
#   ?v = "1.219965836022185"^^xsd:decimal
#   ?v2 = "1.4883166410613087"^^xsd:decimal
#   ?v2Over = "0.0917706946024678"^^xsd:decimal
#   ?x = 20.0
#   ?y = -3.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :v "1.219965836022185"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :md2 "5.967987380277231"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b7 .
#   _:b7 :x 20.0 .
#   _:b7 :y -3.0 .
#   (20.0 "6.714285714285714"^^xsd:decimal) math:difference "13.285714285714285"^^xsd:decimal .
#   (-3.0 "4.171428571428572"^^xsd:decimal) math:difference "-7.171428571428572"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "11.143052367800513"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "3.905245715227793"^^xsd:decimal .
#   ("11.143052367800513"^^xsd:decimal "3.905245715227793"^^xsd:decimal) math:sum "15.048298083028305"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-7.234817759286548"^^xsd:decimal .
#   (0.0 "-7.234817759286548"^^xsd:decimal) math:difference "7.234817759286548"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-6.014851923264363"^^xsd:decimal .
#   ("7.234817759286548"^^xsd:decimal "-6.014851923264363"^^xsd:decimal) math:sum "1.219965836022185"^^xsd:decimal .
#   ("15.048298083028305"^^xsd:decimal 2.0) math:exponentiation "226.45127519567336"^^xsd:decimal .
#   ("1.219965836022185"^^xsd:decimal 2.0) math:exponentiation "1.4883166410613087"^^xsd:decimal .
#   ("226.45127519567336"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "5.8762166856747635"^^xsd:decimal .
#   ("1.4883166410613087"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0917706946024678"^^xsd:decimal .
#   ("5.8762166856747635"^^xsd:decimal "0.0917706946024678"^^xsd:decimal) math:sum "5.967987380277231"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "13.285714285714285"^^xsd:decimal
#   ?dxC = "11.143052367800513"^^xsd:decimal
#   ?dxS = "-7.234817759286548"^^xsd:decimal
#   ?dy = "-7.171428571428572"^^xsd:decimal
#   ?dyC = "-6.014851923264363"^^xsd:decimal
#   ?dyS = "3.905245715227793"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "5.967987380277231"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "7.234817759286548"^^xsd:decimal
#   ?p = _:b7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "15.048298083028305"^^xsd:decimal
#   ?u2 = "226.45127519567336"^^xsd:decimal
#   ?u2Over = "5.8762166856747635"^^xsd:decimal
#   ?v = "1.219965836022185"^^xsd:decimal
#   ?v2 = "1.4883166410613087"^^xsd:decimal
#   ?v2Over = "0.0917706946024678"^^xsd:decimal
#   ?x = 20.0
#   ?y = -3.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :md2 "5.967987380277231"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b7 .
#   _:b7 :x 20.0 .
#   _:b7 :y -3.0 .
#   (20.0 "6.714285714285714"^^xsd:decimal) math:difference "13.285714285714285"^^xsd:decimal .
#   (-3.0 "4.171428571428572"^^xsd:decimal) math:difference "-7.171428571428572"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "11.143052367800513"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "3.905245715227793"^^xsd:decimal .
#   ("11.143052367800513"^^xsd:decimal "3.905245715227793"^^xsd:decimal) math:sum "15.048298083028305"^^xsd:decimal .
#   ("13.285714285714285"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-7.234817759286548"^^xsd:decimal .
#   (0.0 "-7.234817759286548"^^xsd:decimal) math:difference "7.234817759286548"^^xsd:decimal .
#   ("-7.171428571428572"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-6.014851923264363"^^xsd:decimal .
#   ("7.234817759286548"^^xsd:decimal "-6.014851923264363"^^xsd:decimal) math:sum "1.219965836022185"^^xsd:decimal .
#   ("15.048298083028305"^^xsd:decimal 2.0) math:exponentiation "226.45127519567336"^^xsd:decimal .
#   ("1.219965836022185"^^xsd:decimal 2.0) math:exponentiation "1.4883166410613087"^^xsd:decimal .
#   ("226.45127519567336"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "5.8762166856747635"^^xsd:decimal .
#   ("1.4883166410613087"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0917706946024678"^^xsd:decimal .
#   ("5.8762166856747635"^^xsd:decimal "0.0917706946024678"^^xsd:decimal) math:sum "5.967987380277231"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "13.285714285714285"^^xsd:decimal
#   ?dxC = "11.143052367800513"^^xsd:decimal
#   ?dxS = "-7.234817759286548"^^xsd:decimal
#   ?dy = "-7.171428571428572"^^xsd:decimal
#   ?dyC = "-6.014851923264363"^^xsd:decimal
#   ?dyS = "3.905245715227793"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "5.967987380277231"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "7.234817759286548"^^xsd:decimal
#   ?p = _:b7
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "15.048298083028305"^^xsd:decimal
#   ?u2 = "226.45127519567336"^^xsd:decimal
#   ?u2Over = "5.8762166856747635"^^xsd:decimal
#   ?v = "1.219965836022185"^^xsd:decimal
#   ?v2 = "1.4883166410613087"^^xsd:decimal
#   ?v2Over = "0.0917706946024678"^^xsd:decimal
#   ?x = 20.0
#   ?y = -3.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :point _:b6 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b6 .
#   _:b6 :x 7.0 .
#   _:b6 :y 13.0 .
#   (7.0 "6.714285714285714"^^xsd:decimal) math:difference "0.2857142857142856"^^xsd:decimal .
#   (13.0 "4.171428571428572"^^xsd:decimal) math:difference "8.82857142857143"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.23963553479140878"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-4.807653091654933"^^xsd:decimal .
#   ("0.23963553479140878"^^xsd:decimal "-4.807653091654933"^^xsd:decimal) math:sum "-4.5680175568635235"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.1555874786943343"^^xsd:decimal .
#   (0.0 "-0.1555874786943343"^^xsd:decimal) math:difference "0.1555874786943343"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "7.404738025054535"^^xsd:decimal .
#   ("0.1555874786943343"^^xsd:decimal "7.404738025054535"^^xsd:decimal) math:sum "7.56032550374887"^^xsd:decimal .
#   ("-4.5680175568635235"^^xsd:decimal 2.0) math:exponentiation "20.866784399813394"^^xsd:decimal .
#   ("7.56032550374887"^^xsd:decimal 2.0) math:exponentiation "57.158521722635605"^^xsd:decimal .
#   ("20.866784399813394"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.541475187369155"^^xsd:decimal .
#   ("57.158521722635605"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "3.5244363304276427"^^xsd:decimal .
#   ("0.541475187369155"^^xsd:decimal "3.5244363304276427"^^xsd:decimal) math:sum "4.065911517796797"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "0.2857142857142856"^^xsd:decimal
#   ?dxC = "0.23963553479140878"^^xsd:decimal
#   ?dxS = "-0.1555874786943343"^^xsd:decimal
#   ?dy = "8.82857142857143"^^xsd:decimal
#   ?dyC = "7.404738025054535"^^xsd:decimal
#   ?dyS = "-4.807653091654933"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "4.065911517796797"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "0.1555874786943343"^^xsd:decimal
#   ?p = _:b6
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-4.5680175568635235"^^xsd:decimal
#   ?u2 = "20.866784399813394"^^xsd:decimal
#   ?u2Over = "0.541475187369155"^^xsd:decimal
#   ?v = "7.56032550374887"^^xsd:decimal
#   ?v2 = "57.158521722635605"^^xsd:decimal
#   ?v2Over = "3.5244363304276427"^^xsd:decimal
#   ?x = 7.0
#   ?y = 13.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :point _:b6 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :u "-4.5680175568635235"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b6 .
#   _:b6 :x 7.0 .
#   _:b6 :y 13.0 .
#   (7.0 "6.714285714285714"^^xsd:decimal) math:difference "0.2857142857142856"^^xsd:decimal .
#   (13.0 "4.171428571428572"^^xsd:decimal) math:difference "8.82857142857143"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.23963553479140878"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-4.807653091654933"^^xsd:decimal .
#   ("0.23963553479140878"^^xsd:decimal "-4.807653091654933"^^xsd:decimal) math:sum "-4.5680175568635235"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.1555874786943343"^^xsd:decimal .
#   (0.0 "-0.1555874786943343"^^xsd:decimal) math:difference "0.1555874786943343"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "7.404738025054535"^^xsd:decimal .
#   ("0.1555874786943343"^^xsd:decimal "7.404738025054535"^^xsd:decimal) math:sum "7.56032550374887"^^xsd:decimal .
#   ("-4.5680175568635235"^^xsd:decimal 2.0) math:exponentiation "20.866784399813394"^^xsd:decimal .
#   ("7.56032550374887"^^xsd:decimal 2.0) math:exponentiation "57.158521722635605"^^xsd:decimal .
#   ("20.866784399813394"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.541475187369155"^^xsd:decimal .
#   ("57.158521722635605"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "3.5244363304276427"^^xsd:decimal .
#   ("0.541475187369155"^^xsd:decimal "3.5244363304276427"^^xsd:decimal) math:sum "4.065911517796797"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "0.2857142857142856"^^xsd:decimal
#   ?dxC = "0.23963553479140878"^^xsd:decimal
#   ?dxS = "-0.1555874786943343"^^xsd:decimal
#   ?dy = "8.82857142857143"^^xsd:decimal
#   ?dyC = "7.404738025054535"^^xsd:decimal
#   ?dyS = "-4.807653091654933"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "4.065911517796797"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "0.1555874786943343"^^xsd:decimal
#   ?p = _:b6
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-4.5680175568635235"^^xsd:decimal
#   ?u2 = "20.866784399813394"^^xsd:decimal
#   ?u2Over = "0.541475187369155"^^xsd:decimal
#   ?v = "7.56032550374887"^^xsd:decimal
#   ?v2 = "57.158521722635605"^^xsd:decimal
#   ?v2Over = "3.5244363304276427"^^xsd:decimal
#   ?x = 7.0
#   ?y = 13.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :u "-4.5680175568635235"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :v "7.56032550374887"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b6 .
#   _:b6 :x 7.0 .
#   _:b6 :y 13.0 .
#   (7.0 "6.714285714285714"^^xsd:decimal) math:difference "0.2857142857142856"^^xsd:decimal .
#   (13.0 "4.171428571428572"^^xsd:decimal) math:difference "8.82857142857143"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.23963553479140878"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-4.807653091654933"^^xsd:decimal .
#   ("0.23963553479140878"^^xsd:decimal "-4.807653091654933"^^xsd:decimal) math:sum "-4.5680175568635235"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.1555874786943343"^^xsd:decimal .
#   (0.0 "-0.1555874786943343"^^xsd:decimal) math:difference "0.1555874786943343"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "7.404738025054535"^^xsd:decimal .
#   ("0.1555874786943343"^^xsd:decimal "7.404738025054535"^^xsd:decimal) math:sum "7.56032550374887"^^xsd:decimal .
#   ("-4.5680175568635235"^^xsd:decimal 2.0) math:exponentiation "20.866784399813394"^^xsd:decimal .
#   ("7.56032550374887"^^xsd:decimal 2.0) math:exponentiation "57.158521722635605"^^xsd:decimal .
#   ("20.866784399813394"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.541475187369155"^^xsd:decimal .
#   ("57.158521722635605"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "3.5244363304276427"^^xsd:decimal .
#   ("0.541475187369155"^^xsd:decimal "3.5244363304276427"^^xsd:decimal) math:sum "4.065911517796797"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "0.2857142857142856"^^xsd:decimal
#   ?dxC = "0.23963553479140878"^^xsd:decimal
#   ?dxS = "-0.1555874786943343"^^xsd:decimal
#   ?dy = "8.82857142857143"^^xsd:decimal
#   ?dyC = "7.404738025054535"^^xsd:decimal
#   ?dyS = "-4.807653091654933"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "4.065911517796797"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "0.1555874786943343"^^xsd:decimal
#   ?p = _:b6
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-4.5680175568635235"^^xsd:decimal
#   ?u2 = "20.866784399813394"^^xsd:decimal
#   ?u2Over = "0.541475187369155"^^xsd:decimal
#   ?v = "7.56032550374887"^^xsd:decimal
#   ?v2 = "57.158521722635605"^^xsd:decimal
#   ?v2Over = "3.5244363304276427"^^xsd:decimal
#   ?x = 7.0
#   ?y = 13.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :v "7.56032550374887"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :md2 "4.065911517796797"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b6 .
#   _:b6 :x 7.0 .
#   _:b6 :y 13.0 .
#   (7.0 "6.714285714285714"^^xsd:decimal) math:difference "0.2857142857142856"^^xsd:decimal .
#   (13.0 "4.171428571428572"^^xsd:decimal) math:difference "8.82857142857143"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.23963553479140878"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-4.807653091654933"^^xsd:decimal .
#   ("0.23963553479140878"^^xsd:decimal "-4.807653091654933"^^xsd:decimal) math:sum "-4.5680175568635235"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.1555874786943343"^^xsd:decimal .
#   (0.0 "-0.1555874786943343"^^xsd:decimal) math:difference "0.1555874786943343"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "7.404738025054535"^^xsd:decimal .
#   ("0.1555874786943343"^^xsd:decimal "7.404738025054535"^^xsd:decimal) math:sum "7.56032550374887"^^xsd:decimal .
#   ("-4.5680175568635235"^^xsd:decimal 2.0) math:exponentiation "20.866784399813394"^^xsd:decimal .
#   ("7.56032550374887"^^xsd:decimal 2.0) math:exponentiation "57.158521722635605"^^xsd:decimal .
#   ("20.866784399813394"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.541475187369155"^^xsd:decimal .
#   ("57.158521722635605"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "3.5244363304276427"^^xsd:decimal .
#   ("0.541475187369155"^^xsd:decimal "3.5244363304276427"^^xsd:decimal) math:sum "4.065911517796797"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "0.2857142857142856"^^xsd:decimal
#   ?dxC = "0.23963553479140878"^^xsd:decimal
#   ?dxS = "-0.1555874786943343"^^xsd:decimal
#   ?dy = "8.82857142857143"^^xsd:decimal
#   ?dyC = "7.404738025054535"^^xsd:decimal
#   ?dyS = "-4.807653091654933"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "4.065911517796797"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "0.1555874786943343"^^xsd:decimal
#   ?p = _:b6
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-4.5680175568635235"^^xsd:decimal
#   ?u2 = "20.866784399813394"^^xsd:decimal
#   ?u2Over = "0.541475187369155"^^xsd:decimal
#   ?v = "7.56032550374887"^^xsd:decimal
#   ?v2 = "57.158521722635605"^^xsd:decimal
#   ?v2Over = "3.5244363304276427"^^xsd:decimal
#   ?x = 7.0
#   ?y = 13.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :md2 "4.065911517796797"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b6 .
#   _:b6 :x 7.0 .
#   _:b6 :y 13.0 .
#   (7.0 "6.714285714285714"^^xsd:decimal) math:difference "0.2857142857142856"^^xsd:decimal .
#   (13.0 "4.171428571428572"^^xsd:decimal) math:difference "8.82857142857143"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.23963553479140878"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-4.807653091654933"^^xsd:decimal .
#   ("0.23963553479140878"^^xsd:decimal "-4.807653091654933"^^xsd:decimal) math:sum "-4.5680175568635235"^^xsd:decimal .
#   ("0.2857142857142856"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.1555874786943343"^^xsd:decimal .
#   (0.0 "-0.1555874786943343"^^xsd:decimal) math:difference "0.1555874786943343"^^xsd:decimal .
#   ("8.82857142857143"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "7.404738025054535"^^xsd:decimal .
#   ("0.1555874786943343"^^xsd:decimal "7.404738025054535"^^xsd:decimal) math:sum "7.56032550374887"^^xsd:decimal .
#   ("-4.5680175568635235"^^xsd:decimal 2.0) math:exponentiation "20.866784399813394"^^xsd:decimal .
#   ("7.56032550374887"^^xsd:decimal 2.0) math:exponentiation "57.158521722635605"^^xsd:decimal .
#   ("20.866784399813394"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.541475187369155"^^xsd:decimal .
#   ("57.158521722635605"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "3.5244363304276427"^^xsd:decimal .
#   ("0.541475187369155"^^xsd:decimal "3.5244363304276427"^^xsd:decimal) math:sum "4.065911517796797"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "0.2857142857142856"^^xsd:decimal
#   ?dxC = "0.23963553479140878"^^xsd:decimal
#   ?dxS = "-0.1555874786943343"^^xsd:decimal
#   ?dy = "8.82857142857143"^^xsd:decimal
#   ?dyC = "7.404738025054535"^^xsd:decimal
#   ?dyS = "-4.807653091654933"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "4.065911517796797"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "0.1555874786943343"^^xsd:decimal
#   ?p = _:b6
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-4.5680175568635235"^^xsd:decimal
#   ?u2 = "20.866784399813394"^^xsd:decimal
#   ?u2Over = "0.541475187369155"^^xsd:decimal
#   ?v = "7.56032550374887"^^xsd:decimal
#   ?v2 = "57.158521722635605"^^xsd:decimal
#   ?v2Over = "3.5244363304276427"^^xsd:decimal
#   ?x = 7.0
#   ?y = 13.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :point _:b5 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b5 .
#   _:b5 :x 6.0 .
#   _:b5 :y 7.9 .
#   (6.0 "6.714285714285714"^^xsd:decimal) math:difference "-0.7142857142857144"^^xsd:decimal .
#   (7.9 "4.171428571428572"^^xsd:decimal) math:difference "3.7285714285714286"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.5990888369785223"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-2.0304165969610635"^^xsd:decimal .
#   ("-0.5990888369785223"^^xsd:decimal "-2.0304165969610635"^^xsd:decimal) math:sum "-2.6295054339395856"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.388968696735836"^^xsd:decimal .
#   (0.0 "0.388968696735836"^^xsd:decimal) math:difference "-0.388968696735836"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "3.127243729027886"^^xsd:decimal .
#   ("-0.388968696735836"^^xsd:decimal "3.127243729027886"^^xsd:decimal) math:sum "2.73827503229205"^^xsd:decimal .
#   ("-2.6295054339395856"^^xsd:decimal 2.0) math:exponentiation "6.9142988271178085"^^xsd:decimal .
#   ("2.73827503229205"^^xsd:decimal 2.0) math:exponentiation "7.498150152474028"^^xsd:decimal .
#   ("6.9142988271178085"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.17942013398928033"^^xsd:decimal .
#   ("7.498150152474028"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.4623414324222394"^^xsd:decimal .
#   ("0.17942013398928033"^^xsd:decimal "0.4623414324222394"^^xsd:decimal) math:sum "0.6417615664115197"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-0.7142857142857144"^^xsd:decimal
#   ?dxC = "-0.5990888369785223"^^xsd:decimal
#   ?dxS = "0.388968696735836"^^xsd:decimal
#   ?dy = "3.7285714285714286"^^xsd:decimal
#   ?dyC = "3.127243729027886"^^xsd:decimal
#   ?dyS = "-2.0304165969610635"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.6417615664115197"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.388968696735836"^^xsd:decimal
#   ?p = _:b5
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.6295054339395856"^^xsd:decimal
#   ?u2 = "6.9142988271178085"^^xsd:decimal
#   ?u2Over = "0.17942013398928033"^^xsd:decimal
#   ?v = "2.73827503229205"^^xsd:decimal
#   ?v2 = "7.498150152474028"^^xsd:decimal
#   ?v2Over = "0.4623414324222394"^^xsd:decimal
#   ?x = 6.0
#   ?y = 7.9
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :point _:b5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :u "-2.6295054339395856"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b5 .
#   _:b5 :x 6.0 .
#   _:b5 :y 7.9 .
#   (6.0 "6.714285714285714"^^xsd:decimal) math:difference "-0.7142857142857144"^^xsd:decimal .
#   (7.9 "4.171428571428572"^^xsd:decimal) math:difference "3.7285714285714286"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.5990888369785223"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-2.0304165969610635"^^xsd:decimal .
#   ("-0.5990888369785223"^^xsd:decimal "-2.0304165969610635"^^xsd:decimal) math:sum "-2.6295054339395856"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.388968696735836"^^xsd:decimal .
#   (0.0 "0.388968696735836"^^xsd:decimal) math:difference "-0.388968696735836"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "3.127243729027886"^^xsd:decimal .
#   ("-0.388968696735836"^^xsd:decimal "3.127243729027886"^^xsd:decimal) math:sum "2.73827503229205"^^xsd:decimal .
#   ("-2.6295054339395856"^^xsd:decimal 2.0) math:exponentiation "6.9142988271178085"^^xsd:decimal .
#   ("2.73827503229205"^^xsd:decimal 2.0) math:exponentiation "7.498150152474028"^^xsd:decimal .
#   ("6.9142988271178085"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.17942013398928033"^^xsd:decimal .
#   ("7.498150152474028"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.4623414324222394"^^xsd:decimal .
#   ("0.17942013398928033"^^xsd:decimal "0.4623414324222394"^^xsd:decimal) math:sum "0.6417615664115197"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-0.7142857142857144"^^xsd:decimal
#   ?dxC = "-0.5990888369785223"^^xsd:decimal
#   ?dxS = "0.388968696735836"^^xsd:decimal
#   ?dy = "3.7285714285714286"^^xsd:decimal
#   ?dyC = "3.127243729027886"^^xsd:decimal
#   ?dyS = "-2.0304165969610635"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.6417615664115197"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.388968696735836"^^xsd:decimal
#   ?p = _:b5
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.6295054339395856"^^xsd:decimal
#   ?u2 = "6.9142988271178085"^^xsd:decimal
#   ?u2Over = "0.17942013398928033"^^xsd:decimal
#   ?v = "2.73827503229205"^^xsd:decimal
#   ?v2 = "7.498150152474028"^^xsd:decimal
#   ?v2Over = "0.4623414324222394"^^xsd:decimal
#   ?x = 6.0
#   ?y = 7.9
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :u "-2.6295054339395856"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :v "2.73827503229205"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b5 .
#   _:b5 :x 6.0 .
#   _:b5 :y 7.9 .
#   (6.0 "6.714285714285714"^^xsd:decimal) math:difference "-0.7142857142857144"^^xsd:decimal .
#   (7.9 "4.171428571428572"^^xsd:decimal) math:difference "3.7285714285714286"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.5990888369785223"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-2.0304165969610635"^^xsd:decimal .
#   ("-0.5990888369785223"^^xsd:decimal "-2.0304165969610635"^^xsd:decimal) math:sum "-2.6295054339395856"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.388968696735836"^^xsd:decimal .
#   (0.0 "0.388968696735836"^^xsd:decimal) math:difference "-0.388968696735836"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "3.127243729027886"^^xsd:decimal .
#   ("-0.388968696735836"^^xsd:decimal "3.127243729027886"^^xsd:decimal) math:sum "2.73827503229205"^^xsd:decimal .
#   ("-2.6295054339395856"^^xsd:decimal 2.0) math:exponentiation "6.9142988271178085"^^xsd:decimal .
#   ("2.73827503229205"^^xsd:decimal 2.0) math:exponentiation "7.498150152474028"^^xsd:decimal .
#   ("6.9142988271178085"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.17942013398928033"^^xsd:decimal .
#   ("7.498150152474028"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.4623414324222394"^^xsd:decimal .
#   ("0.17942013398928033"^^xsd:decimal "0.4623414324222394"^^xsd:decimal) math:sum "0.6417615664115197"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-0.7142857142857144"^^xsd:decimal
#   ?dxC = "-0.5990888369785223"^^xsd:decimal
#   ?dxS = "0.388968696735836"^^xsd:decimal
#   ?dy = "3.7285714285714286"^^xsd:decimal
#   ?dyC = "3.127243729027886"^^xsd:decimal
#   ?dyS = "-2.0304165969610635"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.6417615664115197"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.388968696735836"^^xsd:decimal
#   ?p = _:b5
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.6295054339395856"^^xsd:decimal
#   ?u2 = "6.9142988271178085"^^xsd:decimal
#   ?u2Over = "0.17942013398928033"^^xsd:decimal
#   ?v = "2.73827503229205"^^xsd:decimal
#   ?v2 = "7.498150152474028"^^xsd:decimal
#   ?v2Over = "0.4623414324222394"^^xsd:decimal
#   ?x = 6.0
#   ?y = 7.9
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :v "2.73827503229205"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :md2 "0.6417615664115197"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b5 .
#   _:b5 :x 6.0 .
#   _:b5 :y 7.9 .
#   (6.0 "6.714285714285714"^^xsd:decimal) math:difference "-0.7142857142857144"^^xsd:decimal .
#   (7.9 "4.171428571428572"^^xsd:decimal) math:difference "3.7285714285714286"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.5990888369785223"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-2.0304165969610635"^^xsd:decimal .
#   ("-0.5990888369785223"^^xsd:decimal "-2.0304165969610635"^^xsd:decimal) math:sum "-2.6295054339395856"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.388968696735836"^^xsd:decimal .
#   (0.0 "0.388968696735836"^^xsd:decimal) math:difference "-0.388968696735836"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "3.127243729027886"^^xsd:decimal .
#   ("-0.388968696735836"^^xsd:decimal "3.127243729027886"^^xsd:decimal) math:sum "2.73827503229205"^^xsd:decimal .
#   ("-2.6295054339395856"^^xsd:decimal 2.0) math:exponentiation "6.9142988271178085"^^xsd:decimal .
#   ("2.73827503229205"^^xsd:decimal 2.0) math:exponentiation "7.498150152474028"^^xsd:decimal .
#   ("6.9142988271178085"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.17942013398928033"^^xsd:decimal .
#   ("7.498150152474028"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.4623414324222394"^^xsd:decimal .
#   ("0.17942013398928033"^^xsd:decimal "0.4623414324222394"^^xsd:decimal) math:sum "0.6417615664115197"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-0.7142857142857144"^^xsd:decimal
#   ?dxC = "-0.5990888369785223"^^xsd:decimal
#   ?dxS = "0.388968696735836"^^xsd:decimal
#   ?dy = "3.7285714285714286"^^xsd:decimal
#   ?dyC = "3.127243729027886"^^xsd:decimal
#   ?dyS = "-2.0304165969610635"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.6417615664115197"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.388968696735836"^^xsd:decimal
#   ?p = _:b5
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.6295054339395856"^^xsd:decimal
#   ?u2 = "6.9142988271178085"^^xsd:decimal
#   ?u2Over = "0.17942013398928033"^^xsd:decimal
#   ?v = "2.73827503229205"^^xsd:decimal
#   ?v2 = "7.498150152474028"^^xsd:decimal
#   ?v2Over = "0.4623414324222394"^^xsd:decimal
#   ?x = 6.0
#   ?y = 7.9
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :md2 "0.6417615664115197"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b5 .
#   _:b5 :x 6.0 .
#   _:b5 :y 7.9 .
#   (6.0 "6.714285714285714"^^xsd:decimal) math:difference "-0.7142857142857144"^^xsd:decimal .
#   (7.9 "4.171428571428572"^^xsd:decimal) math:difference "3.7285714285714286"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.5990888369785223"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-2.0304165969610635"^^xsd:decimal .
#   ("-0.5990888369785223"^^xsd:decimal "-2.0304165969610635"^^xsd:decimal) math:sum "-2.6295054339395856"^^xsd:decimal .
#   ("-0.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.388968696735836"^^xsd:decimal .
#   (0.0 "0.388968696735836"^^xsd:decimal) math:difference "-0.388968696735836"^^xsd:decimal .
#   ("3.7285714285714286"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "3.127243729027886"^^xsd:decimal .
#   ("-0.388968696735836"^^xsd:decimal "3.127243729027886"^^xsd:decimal) math:sum "2.73827503229205"^^xsd:decimal .
#   ("-2.6295054339395856"^^xsd:decimal 2.0) math:exponentiation "6.9142988271178085"^^xsd:decimal .
#   ("2.73827503229205"^^xsd:decimal 2.0) math:exponentiation "7.498150152474028"^^xsd:decimal .
#   ("6.9142988271178085"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.17942013398928033"^^xsd:decimal .
#   ("7.498150152474028"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.4623414324222394"^^xsd:decimal .
#   ("0.17942013398928033"^^xsd:decimal "0.4623414324222394"^^xsd:decimal) math:sum "0.6417615664115197"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-0.7142857142857144"^^xsd:decimal
#   ?dxC = "-0.5990888369785223"^^xsd:decimal
#   ?dxS = "0.388968696735836"^^xsd:decimal
#   ?dy = "3.7285714285714286"^^xsd:decimal
#   ?dyC = "3.127243729027886"^^xsd:decimal
#   ?dyS = "-2.0304165969610635"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.6417615664115197"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.388968696735836"^^xsd:decimal
#   ?p = _:b5
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.6295054339395856"^^xsd:decimal
#   ?u2 = "6.9142988271178085"^^xsd:decimal
#   ?u2Over = "0.17942013398928033"^^xsd:decimal
#   ?v = "2.73827503229205"^^xsd:decimal
#   ?v2 = "7.498150152474028"^^xsd:decimal
#   ?v2Over = "0.4623414324222394"^^xsd:decimal
#   ?x = 6.0
#   ?y = 7.9
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :point _:b4 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b4 .
#   _:b4 :x 5.0 .
#   _:b4 :y 5.1 .
#   (5.0 "6.714285714285714"^^xsd:decimal) math:difference "-1.7142857142857144"^^xsd:decimal .
#   (5.1 "4.171428571428572"^^xsd:decimal) math:difference "0.9285714285714279"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.4378132087484534"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.5056593057565864"^^xsd:decimal .
#   ("-1.4378132087484534"^^xsd:decimal "-0.5056593057565864"^^xsd:decimal) math:sum "-1.9434725145050398"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.9335248721660063"^^xsd:decimal .
#   (0.0 "0.9335248721660063"^^xsd:decimal) math:difference "-0.9335248721660063"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.7788154880720783"^^xsd:decimal .
#   ("-0.9335248721660063"^^xsd:decimal "0.7788154880720783"^^xsd:decimal) math:sum "-0.15470938409392798"^^xsd:decimal .
#   ("-1.9434725145050398"^^xsd:decimal 2.0) math:exponentiation "3.777085414636542"^^xsd:decimal .
#   ("-0.15470938409392798"^^xsd:decimal 2.0) math:exponentiation "0.023934993526722535"^^xsd:decimal .
#   ("3.777085414636542"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.0980121322678694"^^xsd:decimal .
#   ("0.023934993526722535"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0014758492384299123"^^xsd:decimal .
#   ("0.0980121322678694"^^xsd:decimal "0.0014758492384299123"^^xsd:decimal) math:sum "0.09948798150629931"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-1.7142857142857144"^^xsd:decimal
#   ?dxC = "-1.4378132087484534"^^xsd:decimal
#   ?dxS = "0.9335248721660063"^^xsd:decimal
#   ?dy = "0.9285714285714279"^^xsd:decimal
#   ?dyC = "0.7788154880720783"^^xsd:decimal
#   ?dyS = "-0.5056593057565864"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.09948798150629931"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.9335248721660063"^^xsd:decimal
#   ?p = _:b4
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9434725145050398"^^xsd:decimal
#   ?u2 = "3.777085414636542"^^xsd:decimal
#   ?u2Over = "0.0980121322678694"^^xsd:decimal
#   ?v = "-0.15470938409392798"^^xsd:decimal
#   ?v2 = "0.023934993526722535"^^xsd:decimal
#   ?v2Over = "0.0014758492384299123"^^xsd:decimal
#   ?x = 5.0
#   ?y = 5.1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :point _:b4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :u "-1.9434725145050398"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b4 .
#   _:b4 :x 5.0 .
#   _:b4 :y 5.1 .
#   (5.0 "6.714285714285714"^^xsd:decimal) math:difference "-1.7142857142857144"^^xsd:decimal .
#   (5.1 "4.171428571428572"^^xsd:decimal) math:difference "0.9285714285714279"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.4378132087484534"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.5056593057565864"^^xsd:decimal .
#   ("-1.4378132087484534"^^xsd:decimal "-0.5056593057565864"^^xsd:decimal) math:sum "-1.9434725145050398"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.9335248721660063"^^xsd:decimal .
#   (0.0 "0.9335248721660063"^^xsd:decimal) math:difference "-0.9335248721660063"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.7788154880720783"^^xsd:decimal .
#   ("-0.9335248721660063"^^xsd:decimal "0.7788154880720783"^^xsd:decimal) math:sum "-0.15470938409392798"^^xsd:decimal .
#   ("-1.9434725145050398"^^xsd:decimal 2.0) math:exponentiation "3.777085414636542"^^xsd:decimal .
#   ("-0.15470938409392798"^^xsd:decimal 2.0) math:exponentiation "0.023934993526722535"^^xsd:decimal .
#   ("3.777085414636542"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.0980121322678694"^^xsd:decimal .
#   ("0.023934993526722535"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0014758492384299123"^^xsd:decimal .
#   ("0.0980121322678694"^^xsd:decimal "0.0014758492384299123"^^xsd:decimal) math:sum "0.09948798150629931"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-1.7142857142857144"^^xsd:decimal
#   ?dxC = "-1.4378132087484534"^^xsd:decimal
#   ?dxS = "0.9335248721660063"^^xsd:decimal
#   ?dy = "0.9285714285714279"^^xsd:decimal
#   ?dyC = "0.7788154880720783"^^xsd:decimal
#   ?dyS = "-0.5056593057565864"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.09948798150629931"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.9335248721660063"^^xsd:decimal
#   ?p = _:b4
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9434725145050398"^^xsd:decimal
#   ?u2 = "3.777085414636542"^^xsd:decimal
#   ?u2Over = "0.0980121322678694"^^xsd:decimal
#   ?v = "-0.15470938409392798"^^xsd:decimal
#   ?v2 = "0.023934993526722535"^^xsd:decimal
#   ?v2Over = "0.0014758492384299123"^^xsd:decimal
#   ?x = 5.0
#   ?y = 5.1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :u "-1.9434725145050398"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :v "-0.15470938409392798"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b4 .
#   _:b4 :x 5.0 .
#   _:b4 :y 5.1 .
#   (5.0 "6.714285714285714"^^xsd:decimal) math:difference "-1.7142857142857144"^^xsd:decimal .
#   (5.1 "4.171428571428572"^^xsd:decimal) math:difference "0.9285714285714279"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.4378132087484534"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.5056593057565864"^^xsd:decimal .
#   ("-1.4378132087484534"^^xsd:decimal "-0.5056593057565864"^^xsd:decimal) math:sum "-1.9434725145050398"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.9335248721660063"^^xsd:decimal .
#   (0.0 "0.9335248721660063"^^xsd:decimal) math:difference "-0.9335248721660063"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.7788154880720783"^^xsd:decimal .
#   ("-0.9335248721660063"^^xsd:decimal "0.7788154880720783"^^xsd:decimal) math:sum "-0.15470938409392798"^^xsd:decimal .
#   ("-1.9434725145050398"^^xsd:decimal 2.0) math:exponentiation "3.777085414636542"^^xsd:decimal .
#   ("-0.15470938409392798"^^xsd:decimal 2.0) math:exponentiation "0.023934993526722535"^^xsd:decimal .
#   ("3.777085414636542"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.0980121322678694"^^xsd:decimal .
#   ("0.023934993526722535"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0014758492384299123"^^xsd:decimal .
#   ("0.0980121322678694"^^xsd:decimal "0.0014758492384299123"^^xsd:decimal) math:sum "0.09948798150629931"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-1.7142857142857144"^^xsd:decimal
#   ?dxC = "-1.4378132087484534"^^xsd:decimal
#   ?dxS = "0.9335248721660063"^^xsd:decimal
#   ?dy = "0.9285714285714279"^^xsd:decimal
#   ?dyC = "0.7788154880720783"^^xsd:decimal
#   ?dyS = "-0.5056593057565864"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.09948798150629931"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.9335248721660063"^^xsd:decimal
#   ?p = _:b4
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9434725145050398"^^xsd:decimal
#   ?u2 = "3.777085414636542"^^xsd:decimal
#   ?u2Over = "0.0980121322678694"^^xsd:decimal
#   ?v = "-0.15470938409392798"^^xsd:decimal
#   ?v2 = "0.023934993526722535"^^xsd:decimal
#   ?v2Over = "0.0014758492384299123"^^xsd:decimal
#   ?x = 5.0
#   ?y = 5.1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :v "-0.15470938409392798"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :md2 "0.09948798150629931"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b4 .
#   _:b4 :x 5.0 .
#   _:b4 :y 5.1 .
#   (5.0 "6.714285714285714"^^xsd:decimal) math:difference "-1.7142857142857144"^^xsd:decimal .
#   (5.1 "4.171428571428572"^^xsd:decimal) math:difference "0.9285714285714279"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.4378132087484534"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.5056593057565864"^^xsd:decimal .
#   ("-1.4378132087484534"^^xsd:decimal "-0.5056593057565864"^^xsd:decimal) math:sum "-1.9434725145050398"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.9335248721660063"^^xsd:decimal .
#   (0.0 "0.9335248721660063"^^xsd:decimal) math:difference "-0.9335248721660063"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.7788154880720783"^^xsd:decimal .
#   ("-0.9335248721660063"^^xsd:decimal "0.7788154880720783"^^xsd:decimal) math:sum "-0.15470938409392798"^^xsd:decimal .
#   ("-1.9434725145050398"^^xsd:decimal 2.0) math:exponentiation "3.777085414636542"^^xsd:decimal .
#   ("-0.15470938409392798"^^xsd:decimal 2.0) math:exponentiation "0.023934993526722535"^^xsd:decimal .
#   ("3.777085414636542"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.0980121322678694"^^xsd:decimal .
#   ("0.023934993526722535"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0014758492384299123"^^xsd:decimal .
#   ("0.0980121322678694"^^xsd:decimal "0.0014758492384299123"^^xsd:decimal) math:sum "0.09948798150629931"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-1.7142857142857144"^^xsd:decimal
#   ?dxC = "-1.4378132087484534"^^xsd:decimal
#   ?dxS = "0.9335248721660063"^^xsd:decimal
#   ?dy = "0.9285714285714279"^^xsd:decimal
#   ?dyC = "0.7788154880720783"^^xsd:decimal
#   ?dyS = "-0.5056593057565864"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.09948798150629931"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.9335248721660063"^^xsd:decimal
#   ?p = _:b4
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9434725145050398"^^xsd:decimal
#   ?u2 = "3.777085414636542"^^xsd:decimal
#   ?u2Over = "0.0980121322678694"^^xsd:decimal
#   ?v = "-0.15470938409392798"^^xsd:decimal
#   ?v2 = "0.023934993526722535"^^xsd:decimal
#   ?v2Over = "0.0014758492384299123"^^xsd:decimal
#   ?x = 5.0
#   ?y = 5.1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :md2 "0.09948798150629931"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_3 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b4 .
#   _:b4 :x 5.0 .
#   _:b4 :y 5.1 .
#   (5.0 "6.714285714285714"^^xsd:decimal) math:difference "-1.7142857142857144"^^xsd:decimal .
#   (5.1 "4.171428571428572"^^xsd:decimal) math:difference "0.9285714285714279"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.4378132087484534"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "-0.5056593057565864"^^xsd:decimal .
#   ("-1.4378132087484534"^^xsd:decimal "-0.5056593057565864"^^xsd:decimal) math:sum "-1.9434725145050398"^^xsd:decimal .
#   ("-1.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.9335248721660063"^^xsd:decimal .
#   (0.0 "0.9335248721660063"^^xsd:decimal) math:difference "-0.9335248721660063"^^xsd:decimal .
#   ("0.9285714285714279"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "0.7788154880720783"^^xsd:decimal .
#   ("-0.9335248721660063"^^xsd:decimal "0.7788154880720783"^^xsd:decimal) math:sum "-0.15470938409392798"^^xsd:decimal .
#   ("-1.9434725145050398"^^xsd:decimal 2.0) math:exponentiation "3.777085414636542"^^xsd:decimal .
#   ("-0.15470938409392798"^^xsd:decimal 2.0) math:exponentiation "0.023934993526722535"^^xsd:decimal .
#   ("3.777085414636542"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.0980121322678694"^^xsd:decimal .
#   ("0.023934993526722535"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.0014758492384299123"^^xsd:decimal .
#   ("0.0980121322678694"^^xsd:decimal "0.0014758492384299123"^^xsd:decimal) math:sum "0.09948798150629931"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-1.7142857142857144"^^xsd:decimal
#   ?dxC = "-1.4378132087484534"^^xsd:decimal
#   ?dxS = "0.9335248721660063"^^xsd:decimal
#   ?dy = "0.9285714285714279"^^xsd:decimal
#   ?dyC = "0.7788154880720783"^^xsd:decimal
#   ?dyS = "-0.5056593057565864"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.09948798150629931"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-0.9335248721660063"^^xsd:decimal
#   ?p = _:b4
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9434725145050398"^^xsd:decimal
#   ?u2 = "3.777085414636542"^^xsd:decimal
#   ?u2Over = "0.0980121322678694"^^xsd:decimal
#   ?v = "-0.15470938409392798"^^xsd:decimal
#   ?v2 = "0.023934993526722535"^^xsd:decimal
#   ?v2Over = "0.0014758492384299123"^^xsd:decimal
#   ?x = 5.0
#   ?y = 5.1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :point _:b3 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b3 .
#   _:b3 :x 4.0 .
#   _:b3 :y 3.2 .
#   (4.0 "6.714285714285714"^^xsd:decimal) math:difference "-2.7142857142857144"^^xsd:decimal .
#   (3.2 "4.171428571428572"^^xsd:decimal) math:difference "-0.9714285714285715"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.2765375805183843"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.528997427560737"^^xsd:decimal .
#   ("-2.2765375805183843"^^xsd:decimal "0.528997427560737"^^xsd:decimal) math:sum "-1.7475401529576473"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.4780810475961768"^^xsd:decimal .
#   (0.0 "1.4780810475961768"^^xsd:decimal) math:difference "-1.4780810475961768"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.8147608182907903"^^xsd:decimal .
#   ("-1.4780810475961768"^^xsd:decimal "-0.8147608182907903"^^xsd:decimal) math:sum "-2.292841865886967"^^xsd:decimal .
#   ("-1.7475401529576473"^^xsd:decimal 2.0) math:exponentiation "3.0538965861992375"^^xsd:decimal .
#   ("-2.292841865886967"^^xsd:decimal 2.0) math:exponentiation "5.257123821964029"^^xsd:decimal .
#   ("3.0538965861992375"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.07924600142190777"^^xsd:decimal .
#   ("5.257123821964029"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.3241581068453198"^^xsd:decimal .
#   ("0.07924600142190777"^^xsd:decimal "0.3241581068453198"^^xsd:decimal) math:sum "0.4034041082672276"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-2.7142857142857144"^^xsd:decimal
#   ?dxC = "-2.2765375805183843"^^xsd:decimal
#   ?dxS = "1.4780810475961768"^^xsd:decimal
#   ?dy = "-0.9714285714285715"^^xsd:decimal
#   ?dyC = "-0.8147608182907903"^^xsd:decimal
#   ?dyS = "0.528997427560737"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.4034041082672276"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-1.4780810475961768"^^xsd:decimal
#   ?p = _:b3
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.7475401529576473"^^xsd:decimal
#   ?u2 = "3.0538965861992375"^^xsd:decimal
#   ?u2Over = "0.07924600142190777"^^xsd:decimal
#   ?v = "-2.292841865886967"^^xsd:decimal
#   ?v2 = "5.257123821964029"^^xsd:decimal
#   ?v2Over = "0.3241581068453198"^^xsd:decimal
#   ?x = 4.0
#   ?y = 3.2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :point _:b3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :u "-1.7475401529576473"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b3 .
#   _:b3 :x 4.0 .
#   _:b3 :y 3.2 .
#   (4.0 "6.714285714285714"^^xsd:decimal) math:difference "-2.7142857142857144"^^xsd:decimal .
#   (3.2 "4.171428571428572"^^xsd:decimal) math:difference "-0.9714285714285715"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.2765375805183843"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.528997427560737"^^xsd:decimal .
#   ("-2.2765375805183843"^^xsd:decimal "0.528997427560737"^^xsd:decimal) math:sum "-1.7475401529576473"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.4780810475961768"^^xsd:decimal .
#   (0.0 "1.4780810475961768"^^xsd:decimal) math:difference "-1.4780810475961768"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.8147608182907903"^^xsd:decimal .
#   ("-1.4780810475961768"^^xsd:decimal "-0.8147608182907903"^^xsd:decimal) math:sum "-2.292841865886967"^^xsd:decimal .
#   ("-1.7475401529576473"^^xsd:decimal 2.0) math:exponentiation "3.0538965861992375"^^xsd:decimal .
#   ("-2.292841865886967"^^xsd:decimal 2.0) math:exponentiation "5.257123821964029"^^xsd:decimal .
#   ("3.0538965861992375"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.07924600142190777"^^xsd:decimal .
#   ("5.257123821964029"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.3241581068453198"^^xsd:decimal .
#   ("0.07924600142190777"^^xsd:decimal "0.3241581068453198"^^xsd:decimal) math:sum "0.4034041082672276"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-2.7142857142857144"^^xsd:decimal
#   ?dxC = "-2.2765375805183843"^^xsd:decimal
#   ?dxS = "1.4780810475961768"^^xsd:decimal
#   ?dy = "-0.9714285714285715"^^xsd:decimal
#   ?dyC = "-0.8147608182907903"^^xsd:decimal
#   ?dyS = "0.528997427560737"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.4034041082672276"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-1.4780810475961768"^^xsd:decimal
#   ?p = _:b3
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.7475401529576473"^^xsd:decimal
#   ?u2 = "3.0538965861992375"^^xsd:decimal
#   ?u2Over = "0.07924600142190777"^^xsd:decimal
#   ?v = "-2.292841865886967"^^xsd:decimal
#   ?v2 = "5.257123821964029"^^xsd:decimal
#   ?v2Over = "0.3241581068453198"^^xsd:decimal
#   ?x = 4.0
#   ?y = 3.2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :u "-1.7475401529576473"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :v "-2.292841865886967"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b3 .
#   _:b3 :x 4.0 .
#   _:b3 :y 3.2 .
#   (4.0 "6.714285714285714"^^xsd:decimal) math:difference "-2.7142857142857144"^^xsd:decimal .
#   (3.2 "4.171428571428572"^^xsd:decimal) math:difference "-0.9714285714285715"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.2765375805183843"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.528997427560737"^^xsd:decimal .
#   ("-2.2765375805183843"^^xsd:decimal "0.528997427560737"^^xsd:decimal) math:sum "-1.7475401529576473"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.4780810475961768"^^xsd:decimal .
#   (0.0 "1.4780810475961768"^^xsd:decimal) math:difference "-1.4780810475961768"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.8147608182907903"^^xsd:decimal .
#   ("-1.4780810475961768"^^xsd:decimal "-0.8147608182907903"^^xsd:decimal) math:sum "-2.292841865886967"^^xsd:decimal .
#   ("-1.7475401529576473"^^xsd:decimal 2.0) math:exponentiation "3.0538965861992375"^^xsd:decimal .
#   ("-2.292841865886967"^^xsd:decimal 2.0) math:exponentiation "5.257123821964029"^^xsd:decimal .
#   ("3.0538965861992375"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.07924600142190777"^^xsd:decimal .
#   ("5.257123821964029"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.3241581068453198"^^xsd:decimal .
#   ("0.07924600142190777"^^xsd:decimal "0.3241581068453198"^^xsd:decimal) math:sum "0.4034041082672276"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-2.7142857142857144"^^xsd:decimal
#   ?dxC = "-2.2765375805183843"^^xsd:decimal
#   ?dxS = "1.4780810475961768"^^xsd:decimal
#   ?dy = "-0.9714285714285715"^^xsd:decimal
#   ?dyC = "-0.8147608182907903"^^xsd:decimal
#   ?dyS = "0.528997427560737"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.4034041082672276"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-1.4780810475961768"^^xsd:decimal
#   ?p = _:b3
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.7475401529576473"^^xsd:decimal
#   ?u2 = "3.0538965861992375"^^xsd:decimal
#   ?u2Over = "0.07924600142190777"^^xsd:decimal
#   ?v = "-2.292841865886967"^^xsd:decimal
#   ?v2 = "5.257123821964029"^^xsd:decimal
#   ?v2Over = "0.3241581068453198"^^xsd:decimal
#   ?x = 4.0
#   ?y = 3.2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :v "-2.292841865886967"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :md2 "0.4034041082672276"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b3 .
#   _:b3 :x 4.0 .
#   _:b3 :y 3.2 .
#   (4.0 "6.714285714285714"^^xsd:decimal) math:difference "-2.7142857142857144"^^xsd:decimal .
#   (3.2 "4.171428571428572"^^xsd:decimal) math:difference "-0.9714285714285715"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.2765375805183843"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.528997427560737"^^xsd:decimal .
#   ("-2.2765375805183843"^^xsd:decimal "0.528997427560737"^^xsd:decimal) math:sum "-1.7475401529576473"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.4780810475961768"^^xsd:decimal .
#   (0.0 "1.4780810475961768"^^xsd:decimal) math:difference "-1.4780810475961768"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.8147608182907903"^^xsd:decimal .
#   ("-1.4780810475961768"^^xsd:decimal "-0.8147608182907903"^^xsd:decimal) math:sum "-2.292841865886967"^^xsd:decimal .
#   ("-1.7475401529576473"^^xsd:decimal 2.0) math:exponentiation "3.0538965861992375"^^xsd:decimal .
#   ("-2.292841865886967"^^xsd:decimal 2.0) math:exponentiation "5.257123821964029"^^xsd:decimal .
#   ("3.0538965861992375"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.07924600142190777"^^xsd:decimal .
#   ("5.257123821964029"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.3241581068453198"^^xsd:decimal .
#   ("0.07924600142190777"^^xsd:decimal "0.3241581068453198"^^xsd:decimal) math:sum "0.4034041082672276"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-2.7142857142857144"^^xsd:decimal
#   ?dxC = "-2.2765375805183843"^^xsd:decimal
#   ?dxS = "1.4780810475961768"^^xsd:decimal
#   ?dy = "-0.9714285714285715"^^xsd:decimal
#   ?dyC = "-0.8147608182907903"^^xsd:decimal
#   ?dyS = "0.528997427560737"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.4034041082672276"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-1.4780810475961768"^^xsd:decimal
#   ?p = _:b3
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.7475401529576473"^^xsd:decimal
#   ?u2 = "3.0538965861992375"^^xsd:decimal
#   ?u2Over = "0.07924600142190777"^^xsd:decimal
#   ?v = "-2.292841865886967"^^xsd:decimal
#   ?v2 = "5.257123821964029"^^xsd:decimal
#   ?v2Over = "0.3241581068453198"^^xsd:decimal
#   ?x = 4.0
#   ?y = 3.2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :md2 "0.4034041082672276"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_4 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b3 .
#   _:b3 :x 4.0 .
#   _:b3 :y 3.2 .
#   (4.0 "6.714285714285714"^^xsd:decimal) math:difference "-2.7142857142857144"^^xsd:decimal .
#   (3.2 "4.171428571428572"^^xsd:decimal) math:difference "-0.9714285714285715"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.2765375805183843"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "0.528997427560737"^^xsd:decimal .
#   ("-2.2765375805183843"^^xsd:decimal "0.528997427560737"^^xsd:decimal) math:sum "-1.7475401529576473"^^xsd:decimal .
#   ("-2.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.4780810475961768"^^xsd:decimal .
#   (0.0 "1.4780810475961768"^^xsd:decimal) math:difference "-1.4780810475961768"^^xsd:decimal .
#   ("-0.9714285714285715"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-0.8147608182907903"^^xsd:decimal .
#   ("-1.4780810475961768"^^xsd:decimal "-0.8147608182907903"^^xsd:decimal) math:sum "-2.292841865886967"^^xsd:decimal .
#   ("-1.7475401529576473"^^xsd:decimal 2.0) math:exponentiation "3.0538965861992375"^^xsd:decimal .
#   ("-2.292841865886967"^^xsd:decimal 2.0) math:exponentiation "5.257123821964029"^^xsd:decimal .
#   ("3.0538965861992375"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.07924600142190777"^^xsd:decimal .
#   ("5.257123821964029"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.3241581068453198"^^xsd:decimal .
#   ("0.07924600142190777"^^xsd:decimal "0.3241581068453198"^^xsd:decimal) math:sum "0.4034041082672276"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-2.7142857142857144"^^xsd:decimal
#   ?dxC = "-2.2765375805183843"^^xsd:decimal
#   ?dxS = "1.4780810475961768"^^xsd:decimal
#   ?dy = "-0.9714285714285715"^^xsd:decimal
#   ?dyC = "-0.8147608182907903"^^xsd:decimal
#   ?dyS = "0.528997427560737"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "0.4034041082672276"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-1.4780810475961768"^^xsd:decimal
#   ?p = _:b3
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.7475401529576473"^^xsd:decimal
#   ?u2 = "3.0538965861992375"^^xsd:decimal
#   ?u2Over = "0.07924600142190777"^^xsd:decimal
#   ?v = "-2.292841865886967"^^xsd:decimal
#   ?v2 = "5.257123821964029"^^xsd:decimal
#   ?v2Over = "0.3241581068453198"^^xsd:decimal
#   ?x = 4.0
#   ?y = 3.2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :point _:b2 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b2 .
#   _:b2 :x 3.0 .
#   _:b2 :y 2.0 .
#   (3.0 "6.714285714285714"^^xsd:decimal) math:difference "-3.7142857142857144"^^xsd:decimal .
#   (2.0 "4.171428571428572"^^xsd:decimal) math:difference "-2.1714285714285717"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.1152619522883156"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.1824648380769414"^^xsd:decimal .
#   ("-3.1152619522883156"^^xsd:decimal "1.1824648380769414"^^xsd:decimal) math:sum "-1.9327971142113742"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.022637223026347"^^xsd:decimal .
#   (0.0 "2.022637223026347"^^xsd:decimal) math:difference "-2.022637223026347"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.8212300644147077"^^xsd:decimal .
#   ("-2.022637223026347"^^xsd:decimal "-1.8212300644147077"^^xsd:decimal) math:sum "-3.843867287441055"^^xsd:decimal .
#   ("-1.9327971142113742"^^xsd:decimal 2.0) math:exponentiation "3.735704684703816"^^xsd:decimal .
#   ("-3.843867287441055"^^xsd:decimal 2.0) math:exponentiation "14.775315723459453"^^xsd:decimal .
#   ("3.735704684703816"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.09693833775959837"^^xsd:decimal .
#   ("14.775315723459453"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.9110567936307731"^^xsd:decimal .
#   ("0.09693833775959837"^^xsd:decimal "0.9110567936307731"^^xsd:decimal) math:sum "1.0079951313903714"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-3.7142857142857144"^^xsd:decimal
#   ?dxC = "-3.1152619522883156"^^xsd:decimal
#   ?dxS = "2.022637223026347"^^xsd:decimal
#   ?dy = "-2.1714285714285717"^^xsd:decimal
#   ?dyC = "-1.8212300644147077"^^xsd:decimal
#   ?dyS = "1.1824648380769414"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.0079951313903714"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.022637223026347"^^xsd:decimal
#   ?p = _:b2
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9327971142113742"^^xsd:decimal
#   ?u2 = "3.735704684703816"^^xsd:decimal
#   ?u2Over = "0.09693833775959837"^^xsd:decimal
#   ?v = "-3.843867287441055"^^xsd:decimal
#   ?v2 = "14.775315723459453"^^xsd:decimal
#   ?v2Over = "0.9110567936307731"^^xsd:decimal
#   ?x = 3.0
#   ?y = 2.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :point _:b2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :u "-1.9327971142113742"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b2 .
#   _:b2 :x 3.0 .
#   _:b2 :y 2.0 .
#   (3.0 "6.714285714285714"^^xsd:decimal) math:difference "-3.7142857142857144"^^xsd:decimal .
#   (2.0 "4.171428571428572"^^xsd:decimal) math:difference "-2.1714285714285717"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.1152619522883156"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.1824648380769414"^^xsd:decimal .
#   ("-3.1152619522883156"^^xsd:decimal "1.1824648380769414"^^xsd:decimal) math:sum "-1.9327971142113742"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.022637223026347"^^xsd:decimal .
#   (0.0 "2.022637223026347"^^xsd:decimal) math:difference "-2.022637223026347"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.8212300644147077"^^xsd:decimal .
#   ("-2.022637223026347"^^xsd:decimal "-1.8212300644147077"^^xsd:decimal) math:sum "-3.843867287441055"^^xsd:decimal .
#   ("-1.9327971142113742"^^xsd:decimal 2.0) math:exponentiation "3.735704684703816"^^xsd:decimal .
#   ("-3.843867287441055"^^xsd:decimal 2.0) math:exponentiation "14.775315723459453"^^xsd:decimal .
#   ("3.735704684703816"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.09693833775959837"^^xsd:decimal .
#   ("14.775315723459453"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.9110567936307731"^^xsd:decimal .
#   ("0.09693833775959837"^^xsd:decimal "0.9110567936307731"^^xsd:decimal) math:sum "1.0079951313903714"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-3.7142857142857144"^^xsd:decimal
#   ?dxC = "-3.1152619522883156"^^xsd:decimal
#   ?dxS = "2.022637223026347"^^xsd:decimal
#   ?dy = "-2.1714285714285717"^^xsd:decimal
#   ?dyC = "-1.8212300644147077"^^xsd:decimal
#   ?dyS = "1.1824648380769414"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.0079951313903714"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.022637223026347"^^xsd:decimal
#   ?p = _:b2
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9327971142113742"^^xsd:decimal
#   ?u2 = "3.735704684703816"^^xsd:decimal
#   ?u2Over = "0.09693833775959837"^^xsd:decimal
#   ?v = "-3.843867287441055"^^xsd:decimal
#   ?v2 = "14.775315723459453"^^xsd:decimal
#   ?v2Over = "0.9110567936307731"^^xsd:decimal
#   ?x = 3.0
#   ?y = 2.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :u "-1.9327971142113742"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :v "-3.843867287441055"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b2 .
#   _:b2 :x 3.0 .
#   _:b2 :y 2.0 .
#   (3.0 "6.714285714285714"^^xsd:decimal) math:difference "-3.7142857142857144"^^xsd:decimal .
#   (2.0 "4.171428571428572"^^xsd:decimal) math:difference "-2.1714285714285717"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.1152619522883156"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.1824648380769414"^^xsd:decimal .
#   ("-3.1152619522883156"^^xsd:decimal "1.1824648380769414"^^xsd:decimal) math:sum "-1.9327971142113742"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.022637223026347"^^xsd:decimal .
#   (0.0 "2.022637223026347"^^xsd:decimal) math:difference "-2.022637223026347"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.8212300644147077"^^xsd:decimal .
#   ("-2.022637223026347"^^xsd:decimal "-1.8212300644147077"^^xsd:decimal) math:sum "-3.843867287441055"^^xsd:decimal .
#   ("-1.9327971142113742"^^xsd:decimal 2.0) math:exponentiation "3.735704684703816"^^xsd:decimal .
#   ("-3.843867287441055"^^xsd:decimal 2.0) math:exponentiation "14.775315723459453"^^xsd:decimal .
#   ("3.735704684703816"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.09693833775959837"^^xsd:decimal .
#   ("14.775315723459453"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.9110567936307731"^^xsd:decimal .
#   ("0.09693833775959837"^^xsd:decimal "0.9110567936307731"^^xsd:decimal) math:sum "1.0079951313903714"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-3.7142857142857144"^^xsd:decimal
#   ?dxC = "-3.1152619522883156"^^xsd:decimal
#   ?dxS = "2.022637223026347"^^xsd:decimal
#   ?dy = "-2.1714285714285717"^^xsd:decimal
#   ?dyC = "-1.8212300644147077"^^xsd:decimal
#   ?dyS = "1.1824648380769414"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.0079951313903714"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.022637223026347"^^xsd:decimal
#   ?p = _:b2
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9327971142113742"^^xsd:decimal
#   ?u2 = "3.735704684703816"^^xsd:decimal
#   ?u2Over = "0.09693833775959837"^^xsd:decimal
#   ?v = "-3.843867287441055"^^xsd:decimal
#   ?v2 = "14.775315723459453"^^xsd:decimal
#   ?v2Over = "0.9110567936307731"^^xsd:decimal
#   ?x = 3.0
#   ?y = 2.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :v "-3.843867287441055"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :md2 "1.0079951313903714"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b2 .
#   _:b2 :x 3.0 .
#   _:b2 :y 2.0 .
#   (3.0 "6.714285714285714"^^xsd:decimal) math:difference "-3.7142857142857144"^^xsd:decimal .
#   (2.0 "4.171428571428572"^^xsd:decimal) math:difference "-2.1714285714285717"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.1152619522883156"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.1824648380769414"^^xsd:decimal .
#   ("-3.1152619522883156"^^xsd:decimal "1.1824648380769414"^^xsd:decimal) math:sum "-1.9327971142113742"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.022637223026347"^^xsd:decimal .
#   (0.0 "2.022637223026347"^^xsd:decimal) math:difference "-2.022637223026347"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.8212300644147077"^^xsd:decimal .
#   ("-2.022637223026347"^^xsd:decimal "-1.8212300644147077"^^xsd:decimal) math:sum "-3.843867287441055"^^xsd:decimal .
#   ("-1.9327971142113742"^^xsd:decimal 2.0) math:exponentiation "3.735704684703816"^^xsd:decimal .
#   ("-3.843867287441055"^^xsd:decimal 2.0) math:exponentiation "14.775315723459453"^^xsd:decimal .
#   ("3.735704684703816"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.09693833775959837"^^xsd:decimal .
#   ("14.775315723459453"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.9110567936307731"^^xsd:decimal .
#   ("0.09693833775959837"^^xsd:decimal "0.9110567936307731"^^xsd:decimal) math:sum "1.0079951313903714"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-3.7142857142857144"^^xsd:decimal
#   ?dxC = "-3.1152619522883156"^^xsd:decimal
#   ?dxS = "2.022637223026347"^^xsd:decimal
#   ?dy = "-2.1714285714285717"^^xsd:decimal
#   ?dyC = "-1.8212300644147077"^^xsd:decimal
#   ?dyS = "1.1824648380769414"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.0079951313903714"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.022637223026347"^^xsd:decimal
#   ?p = _:b2
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9327971142113742"^^xsd:decimal
#   ?u2 = "3.735704684703816"^^xsd:decimal
#   ?u2Over = "0.09693833775959837"^^xsd:decimal
#   ?v = "-3.843867287441055"^^xsd:decimal
#   ?v2 = "14.775315723459453"^^xsd:decimal
#   ?v2Over = "0.9110567936307731"^^xsd:decimal
#   ?x = 3.0
#   ?y = 2.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :md2 "1.0079951313903714"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_5 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b2 .
#   _:b2 :x 3.0 .
#   _:b2 :y 2.0 .
#   (3.0 "6.714285714285714"^^xsd:decimal) math:difference "-3.7142857142857144"^^xsd:decimal .
#   (2.0 "4.171428571428572"^^xsd:decimal) math:difference "-2.1714285714285717"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.1152619522883156"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.1824648380769414"^^xsd:decimal .
#   ("-3.1152619522883156"^^xsd:decimal "1.1824648380769414"^^xsd:decimal) math:sum "-1.9327971142113742"^^xsd:decimal .
#   ("-3.7142857142857144"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.022637223026347"^^xsd:decimal .
#   (0.0 "2.022637223026347"^^xsd:decimal) math:difference "-2.022637223026347"^^xsd:decimal .
#   ("-2.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-1.8212300644147077"^^xsd:decimal .
#   ("-2.022637223026347"^^xsd:decimal "-1.8212300644147077"^^xsd:decimal) math:sum "-3.843867287441055"^^xsd:decimal .
#   ("-1.9327971142113742"^^xsd:decimal 2.0) math:exponentiation "3.735704684703816"^^xsd:decimal .
#   ("-3.843867287441055"^^xsd:decimal 2.0) math:exponentiation "14.775315723459453"^^xsd:decimal .
#   ("3.735704684703816"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.09693833775959837"^^xsd:decimal .
#   ("14.775315723459453"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "0.9110567936307731"^^xsd:decimal .
#   ("0.09693833775959837"^^xsd:decimal "0.9110567936307731"^^xsd:decimal) math:sum "1.0079951313903714"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-3.7142857142857144"^^xsd:decimal
#   ?dxC = "-3.1152619522883156"^^xsd:decimal
#   ?dxS = "2.022637223026347"^^xsd:decimal
#   ?dy = "-2.1714285714285717"^^xsd:decimal
#   ?dyC = "-1.8212300644147077"^^xsd:decimal
#   ?dyS = "1.1824648380769414"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.0079951313903714"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.022637223026347"^^xsd:decimal
#   ?p = _:b2
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-1.9327971142113742"^^xsd:decimal
#   ?u2 = "3.735704684703816"^^xsd:decimal
#   ?u2Over = "0.09693833775959837"^^xsd:decimal
#   ?v = "-3.843867287441055"^^xsd:decimal
#   ?v2 = "14.775315723459453"^^xsd:decimal
#   ?v2Over = "0.9110567936307731"^^xsd:decimal
#   ?x = 3.0
#   ?y = 2.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :point _:b1 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b1 .
#   _:b1 :x 2.0 .
#   _:b1 :y 1.0 .
#   (2.0 "6.714285714285714"^^xsd:decimal) math:difference "-4.714285714285714"^^xsd:decimal .
#   (1.0 "4.171428571428572"^^xsd:decimal) math:difference "-3.1714285714285717"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.9539863240582465"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.7270210135071118"^^xsd:decimal .
#   ("-3.9539863240582465"^^xsd:decimal "1.7270210135071118"^^xsd:decimal) math:sum "-2.226965310551135"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.567193398456517"^^xsd:decimal .
#   (0.0 "2.567193398456517"^^xsd:decimal) math:difference "-2.567193398456517"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.659954436184639"^^xsd:decimal .
#   ("-2.567193398456517"^^xsd:decimal "-2.659954436184639"^^xsd:decimal) math:sum "-5.227147834641157"^^xsd:decimal .
#   ("-2.226965310551135"^^xsd:decimal 2.0) math:exponentiation "4.959374494398113"^^xsd:decimal .
#   ("-5.227147834641157"^^xsd:decimal 2.0) math:exponentiation "27.323074485193732"^^xsd:decimal .
#   ("4.959374494398113"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.1286915215174237"^^xsd:decimal .
#   ("27.323074485193732"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "1.6847607928331318"^^xsd:decimal .
#   ("0.1286915215174237"^^xsd:decimal "1.6847607928331318"^^xsd:decimal) math:sum "1.8134523143505556"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-4.714285714285714"^^xsd:decimal
#   ?dxC = "-3.9539863240582465"^^xsd:decimal
#   ?dxS = "2.567193398456517"^^xsd:decimal
#   ?dy = "-3.1714285714285717"^^xsd:decimal
#   ?dyC = "-2.659954436184639"^^xsd:decimal
#   ?dyS = "1.7270210135071118"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.8134523143505556"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.567193398456517"^^xsd:decimal
#   ?p = _:b1
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.226965310551135"^^xsd:decimal
#   ?u2 = "4.959374494398113"^^xsd:decimal
#   ?u2Over = "0.1286915215174237"^^xsd:decimal
#   ?v = "-5.227147834641157"^^xsd:decimal
#   ?v2 = "27.323074485193732"^^xsd:decimal
#   ?v2Over = "1.6847607928331318"^^xsd:decimal
#   ?x = 2.0
#   ?y = 1.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :point _:b1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :u "-2.226965310551135"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b1 .
#   _:b1 :x 2.0 .
#   _:b1 :y 1.0 .
#   (2.0 "6.714285714285714"^^xsd:decimal) math:difference "-4.714285714285714"^^xsd:decimal .
#   (1.0 "4.171428571428572"^^xsd:decimal) math:difference "-3.1714285714285717"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.9539863240582465"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.7270210135071118"^^xsd:decimal .
#   ("-3.9539863240582465"^^xsd:decimal "1.7270210135071118"^^xsd:decimal) math:sum "-2.226965310551135"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.567193398456517"^^xsd:decimal .
#   (0.0 "2.567193398456517"^^xsd:decimal) math:difference "-2.567193398456517"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.659954436184639"^^xsd:decimal .
#   ("-2.567193398456517"^^xsd:decimal "-2.659954436184639"^^xsd:decimal) math:sum "-5.227147834641157"^^xsd:decimal .
#   ("-2.226965310551135"^^xsd:decimal 2.0) math:exponentiation "4.959374494398113"^^xsd:decimal .
#   ("-5.227147834641157"^^xsd:decimal 2.0) math:exponentiation "27.323074485193732"^^xsd:decimal .
#   ("4.959374494398113"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.1286915215174237"^^xsd:decimal .
#   ("27.323074485193732"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "1.6847607928331318"^^xsd:decimal .
#   ("0.1286915215174237"^^xsd:decimal "1.6847607928331318"^^xsd:decimal) math:sum "1.8134523143505556"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-4.714285714285714"^^xsd:decimal
#   ?dxC = "-3.9539863240582465"^^xsd:decimal
#   ?dxS = "2.567193398456517"^^xsd:decimal
#   ?dy = "-3.1714285714285717"^^xsd:decimal
#   ?dyC = "-2.659954436184639"^^xsd:decimal
#   ?dyS = "1.7270210135071118"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.8134523143505556"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.567193398456517"^^xsd:decimal
#   ?p = _:b1
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.226965310551135"^^xsd:decimal
#   ?u2 = "4.959374494398113"^^xsd:decimal
#   ?u2Over = "0.1286915215174237"^^xsd:decimal
#   ?v = "-5.227147834641157"^^xsd:decimal
#   ?v2 = "27.323074485193732"^^xsd:decimal
#   ?v2Over = "1.6847607928331318"^^xsd:decimal
#   ?x = 2.0
#   ?y = 1.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :u "-2.226965310551135"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :v "-5.227147834641157"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b1 .
#   _:b1 :x 2.0 .
#   _:b1 :y 1.0 .
#   (2.0 "6.714285714285714"^^xsd:decimal) math:difference "-4.714285714285714"^^xsd:decimal .
#   (1.0 "4.171428571428572"^^xsd:decimal) math:difference "-3.1714285714285717"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.9539863240582465"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.7270210135071118"^^xsd:decimal .
#   ("-3.9539863240582465"^^xsd:decimal "1.7270210135071118"^^xsd:decimal) math:sum "-2.226965310551135"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.567193398456517"^^xsd:decimal .
#   (0.0 "2.567193398456517"^^xsd:decimal) math:difference "-2.567193398456517"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.659954436184639"^^xsd:decimal .
#   ("-2.567193398456517"^^xsd:decimal "-2.659954436184639"^^xsd:decimal) math:sum "-5.227147834641157"^^xsd:decimal .
#   ("-2.226965310551135"^^xsd:decimal 2.0) math:exponentiation "4.959374494398113"^^xsd:decimal .
#   ("-5.227147834641157"^^xsd:decimal 2.0) math:exponentiation "27.323074485193732"^^xsd:decimal .
#   ("4.959374494398113"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.1286915215174237"^^xsd:decimal .
#   ("27.323074485193732"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "1.6847607928331318"^^xsd:decimal .
#   ("0.1286915215174237"^^xsd:decimal "1.6847607928331318"^^xsd:decimal) math:sum "1.8134523143505556"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-4.714285714285714"^^xsd:decimal
#   ?dxC = "-3.9539863240582465"^^xsd:decimal
#   ?dxS = "2.567193398456517"^^xsd:decimal
#   ?dy = "-3.1714285714285717"^^xsd:decimal
#   ?dyC = "-2.659954436184639"^^xsd:decimal
#   ?dyS = "1.7270210135071118"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.8134523143505556"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.567193398456517"^^xsd:decimal
#   ?p = _:b1
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.226965310551135"^^xsd:decimal
#   ?u2 = "4.959374494398113"^^xsd:decimal
#   ?u2Over = "0.1286915215174237"^^xsd:decimal
#   ?v = "-5.227147834641157"^^xsd:decimal
#   ?v2 = "27.323074485193732"^^xsd:decimal
#   ?v2Over = "1.6847607928331318"^^xsd:decimal
#   ?x = 2.0
#   ?y = 1.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :v "-5.227147834641157"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :md2 "1.8134523143505556"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b1 .
#   _:b1 :x 2.0 .
#   _:b1 :y 1.0 .
#   (2.0 "6.714285714285714"^^xsd:decimal) math:difference "-4.714285714285714"^^xsd:decimal .
#   (1.0 "4.171428571428572"^^xsd:decimal) math:difference "-3.1714285714285717"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.9539863240582465"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.7270210135071118"^^xsd:decimal .
#   ("-3.9539863240582465"^^xsd:decimal "1.7270210135071118"^^xsd:decimal) math:sum "-2.226965310551135"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.567193398456517"^^xsd:decimal .
#   (0.0 "2.567193398456517"^^xsd:decimal) math:difference "-2.567193398456517"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.659954436184639"^^xsd:decimal .
#   ("-2.567193398456517"^^xsd:decimal "-2.659954436184639"^^xsd:decimal) math:sum "-5.227147834641157"^^xsd:decimal .
#   ("-2.226965310551135"^^xsd:decimal 2.0) math:exponentiation "4.959374494398113"^^xsd:decimal .
#   ("-5.227147834641157"^^xsd:decimal 2.0) math:exponentiation "27.323074485193732"^^xsd:decimal .
#   ("4.959374494398113"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.1286915215174237"^^xsd:decimal .
#   ("27.323074485193732"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "1.6847607928331318"^^xsd:decimal .
#   ("0.1286915215174237"^^xsd:decimal "1.6847607928331318"^^xsd:decimal) math:sum "1.8134523143505556"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-4.714285714285714"^^xsd:decimal
#   ?dxC = "-3.9539863240582465"^^xsd:decimal
#   ?dxS = "2.567193398456517"^^xsd:decimal
#   ?dy = "-3.1714285714285717"^^xsd:decimal
#   ?dyC = "-2.659954436184639"^^xsd:decimal
#   ?dyS = "1.7270210135071118"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.8134523143505556"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.567193398456517"^^xsd:decimal
#   ?p = _:b1
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.226965310551135"^^xsd:decimal
#   ?u2 = "4.959374494398113"^^xsd:decimal
#   ?u2Over = "0.1286915215174237"^^xsd:decimal
#   ?v = "-5.227147834641157"^^xsd:decimal
#   ?v2 = "27.323074485193732"^^xsd:decimal
#   ?v2Over = "1.6847607928331318"^^xsd:decimal
#   ?x = 2.0
#   ?y = 1.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :md2 "1.8134523143505556"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :score _:sk_6 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) .
#   :PCA1 :meanX "6.714285714285714"^^xsd:decimal .
#   :PCA1 :meanY "4.171428571428572"^^xsd:decimal .
#   :PCA1 :thetaRad "-0.5758598575998168"^^xsd:decimal .
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:cos "0.8387243717699311"^^xsd:decimal .
#   "-0.5758598575998168"^^xsd:decimal math:sin "-0.5445561754301703"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7) list:member _:b1 .
#   _:b1 :x 2.0 .
#   _:b1 :y 1.0 .
#   (2.0 "6.714285714285714"^^xsd:decimal) math:difference "-4.714285714285714"^^xsd:decimal .
#   (1.0 "4.171428571428572"^^xsd:decimal) math:difference "-3.1714285714285717"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-3.9539863240582465"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "1.7270210135071118"^^xsd:decimal .
#   ("-3.9539863240582465"^^xsd:decimal "1.7270210135071118"^^xsd:decimal) math:sum "-2.226965310551135"^^xsd:decimal .
#   ("-4.714285714285714"^^xsd:decimal "-0.5445561754301703"^^xsd:decimal) math:product "2.567193398456517"^^xsd:decimal .
#   (0.0 "2.567193398456517"^^xsd:decimal) math:difference "-2.567193398456517"^^xsd:decimal .
#   ("-3.1714285714285717"^^xsd:decimal "0.8387243717699311"^^xsd:decimal) math:product "-2.659954436184639"^^xsd:decimal .
#   ("-2.567193398456517"^^xsd:decimal "-2.659954436184639"^^xsd:decimal) math:sum "-5.227147834641157"^^xsd:decimal .
#   ("-2.226965310551135"^^xsd:decimal 2.0) math:exponentiation "4.959374494398113"^^xsd:decimal .
#   ("-5.227147834641157"^^xsd:decimal 2.0) math:exponentiation "27.323074485193732"^^xsd:decimal .
#   ("4.959374494398113"^^xsd:decimal "38.53691708607748"^^xsd:decimal) math:quotient "0.1286915215174237"^^xsd:decimal .
#   ("27.323074485193732"^^xsd:decimal "16.217776791473543"^^xsd:decimal) math:quotient "1.6847607928331318"^^xsd:decimal .
#   ("0.1286915215174237"^^xsd:decimal "1.6847607928331318"^^xsd:decimal) math:sum "1.8134523143505556"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :points ?pts .
#     :PCA1 :meanX ?mx .
#     :PCA1 :meanY ?my .
#     :PCA1 :thetaRad ?theta .
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     ?theta math:cos ?c .
#     ?theta math:sin ?s .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?x ?mx) math:difference ?dx .
#     (?y ?my) math:difference ?dy .
#     (?dx ?c) math:product ?dxC .
#     (?dy ?s) math:product ?dyS .
#     (?dxC ?dyS) math:sum ?u .
#     (?dx ?s) math:product ?dxS .
#     (0.0 ?dxS) math:difference ?negDxS .
#     (?dy ?c) math:product ?dyC .
#     (?negDxS ?dyC) math:sum ?v .
#     (?u 2.0) math:exponentiation ?u2 .
#     (?v 2.0) math:exponentiation ?v2 .
#     (?u2 ?l1) math:quotient ?u2Over .
#     (?v2 ?l2) math:quotient ?v2Over .
#     (?u2Over ?v2Over) math:sum ?md2 .
#   } => {
#     _:b8 :point ?p .
#     _:b8 :u ?u .
#     _:b8 :v ?v .
#     _:b8 :md2 ?md2 .
#     :PCA1 :score _:b8 .
#   } .
# with substitution (on rule variables):
#   ?c = "0.8387243717699311"^^xsd:decimal
#   ?dx = "-4.714285714285714"^^xsd:decimal
#   ?dxC = "-3.9539863240582465"^^xsd:decimal
#   ?dxS = "2.567193398456517"^^xsd:decimal
#   ?dy = "-3.1714285714285717"^^xsd:decimal
#   ?dyC = "-2.659954436184639"^^xsd:decimal
#   ?dyS = "1.7270210135071118"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?md2 = "1.8134523143505556"^^xsd:decimal
#   ?mx = "6.714285714285714"^^xsd:decimal
#   ?my = "4.171428571428572"^^xsd:decimal
#   ?negDxS = "-2.567193398456517"^^xsd:decimal
#   ?p = _:b1
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7)
#   ?s = "-0.5445561754301703"^^xsd:decimal
#   ?theta = "-0.5758598575998168"^^xsd:decimal
#   ?u = "-2.226965310551135"^^xsd:decimal
#   ?u2 = "4.959374494398113"^^xsd:decimal
#   ?u2Over = "0.1286915215174237"^^xsd:decimal
#   ?v = "-5.227147834641157"^^xsd:decimal
#   ?v2 = "27.323074485193732"^^xsd:decimal
#   ?v2Over = "1.6847607928331318"^^xsd:decimal
#   ?x = 2.0
#   ?y = 1.0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :score _:sk_6 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :sigma1 "6.207810973771469"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :sigma1 "6.207810973771469"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :sigma2 "4.027130093686265"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :sigma2 "4.027130093686265"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :k "2.4476519360399265"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :k "2.4476519360399265"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :a "15.194560548521638"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :a "15.194560548521638"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :b "9.857012770495835"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :b "9.857012770495835"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :area "470.52568540824944"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :area "470.52568540824944"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :PCA1 :ellipse95 _:sk_7 .
# It holds because the following instance of the rule body is provable:
#   :PCA1 :lambda1 "38.53691708607748"^^xsd:decimal .
#   :PCA1 :lambda2 "16.217776791473543"^^xsd:decimal .
#   ("38.53691708607748"^^xsd:decimal 0.5) math:exponentiation "6.207810973771469"^^xsd:decimal .
#   ("16.217776791473543"^^xsd:decimal 0.5) math:exponentiation "4.027130093686265"^^xsd:decimal .
#   (5.991 0.5) math:exponentiation "2.4476519360399265"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "6.207810973771469"^^xsd:decimal) math:product "15.194560548521638"^^xsd:decimal .
#   ("2.4476519360399265"^^xsd:decimal "4.027130093686265"^^xsd:decimal) math:product "9.857012770495835"^^xsd:decimal .
#   (3.141592653589793 "15.194560548521638"^^xsd:decimal) math:product "47.73511979376087"^^xsd:decimal .
#   ("47.73511979376087"^^xsd:decimal "9.857012770495835"^^xsd:decimal) math:product "470.52568540824944"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :PCA1 :lambda1 ?l1 .
#     :PCA1 :lambda2 ?l2 .
#     (?l1 0.5) math:exponentiation ?sigma1 .
#     (?l2 0.5) math:exponentiation ?sigma2 .
#     (5.991 0.5) math:exponentiation ?k95 .
#     (?k95 ?sigma1) math:product ?a95 .
#     (?k95 ?sigma2) math:product ?b95 .
#     (3.141592653589793 ?a95) math:product ?piA .
#     (?piA ?b95) math:product ?area95 .
#   } => {
#     :PCA1 :sigma1 ?sigma1 .
#     :PCA1 :sigma2 ?sigma2 .
#     _:b11 :k ?k95 .
#     _:b11 :a ?a95 .
#     _:b11 :b ?b95 .
#     _:b11 :area ?area95 .
#     :PCA1 :ellipse95 _:b11 .
#   } .
# with substitution (on rule variables):
#   ?a95 = "15.194560548521638"^^xsd:decimal
#   ?area95 = "470.52568540824944"^^xsd:decimal
#   ?b95 = "9.857012770495835"^^xsd:decimal
#   ?k95 = "2.4476519360399265"^^xsd:decimal
#   ?l1 = "38.53691708607748"^^xsd:decimal
#   ?l2 = "16.217776791473543"^^xsd:decimal
#   ?piA = "47.73511979376087"^^xsd:decimal
#   ?sigma1 = "6.207810973771469"^^xsd:decimal
#   ?sigma2 = "4.027130093686265"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:PCA1 :ellipse95 _:sk_7 .

