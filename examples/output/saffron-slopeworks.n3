@prefix : <http://example.org/saffron-slopeworks#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :n 8 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#   } (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#   } (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)) log:collectAllIn ?_b1 .
#   (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0) math:sum "36"^^xsd:decimal .
#   (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1) math:sum "46"^^xsd:decimal .
#   (?x2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       (?x 2.0) math:exponentiation ?x2 .
#   } ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal) math:sum "204"^^xsd:decimal .
#   (?y2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#   } ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal) math:sum "379.72"^^xsd:decimal .
#   (?xy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x ?y) math:product ?xy .
#   } ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal) math:sum "266.00000000000006"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?x2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x 2.0) math:exponentiation ?x2 .
#     } ?x2s) log:collectAllIn ?_b1 .
#     ?x2s math:sum ?sumXX .
#     (?y2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#     } ?y2s) log:collectAllIn ?_b1 .
#     ?y2s math:sum ?sumYY .
#     (?xy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?y) math:product ?xy .
#     } ?xys) log:collectAllIn ?_b1 .
#     ?xys math:sum ?sumXY .
#   } => {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sumX .
#     :Reg1 :sumY ?sumY .
#     :Reg1 :sumXX ?sumXX .
#     :Reg1 :sumYY ?sumYY .
#     :Reg1 :sumXY ?sumXY .
#   } .
# with substitution (on rule variables):
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?sumX = "36"^^xsd:decimal
#   ?sumXX = "204"^^xsd:decimal
#   ?sumXY = "266.00000000000006"^^xsd:decimal
#   ?sumY = "46"^^xsd:decimal
#   ?sumYY = "379.72"^^xsd:decimal
#   ?x2s = ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)
#   ?xs = (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)
#   ?xys = ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)
#   ?y2s = ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)
#   ?ys = (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :n 8 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :sumX "36"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#   } (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#   } (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)) log:collectAllIn ?_b1 .
#   (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0) math:sum "36"^^xsd:decimal .
#   (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1) math:sum "46"^^xsd:decimal .
#   (?x2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       (?x 2.0) math:exponentiation ?x2 .
#   } ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal) math:sum "204"^^xsd:decimal .
#   (?y2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#   } ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal) math:sum "379.72"^^xsd:decimal .
#   (?xy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x ?y) math:product ?xy .
#   } ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal) math:sum "266.00000000000006"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?x2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x 2.0) math:exponentiation ?x2 .
#     } ?x2s) log:collectAllIn ?_b1 .
#     ?x2s math:sum ?sumXX .
#     (?y2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#     } ?y2s) log:collectAllIn ?_b1 .
#     ?y2s math:sum ?sumYY .
#     (?xy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?y) math:product ?xy .
#     } ?xys) log:collectAllIn ?_b1 .
#     ?xys math:sum ?sumXY .
#   } => {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sumX .
#     :Reg1 :sumY ?sumY .
#     :Reg1 :sumXX ?sumXX .
#     :Reg1 :sumYY ?sumYY .
#     :Reg1 :sumXY ?sumXY .
#   } .
# with substitution (on rule variables):
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?sumX = "36"^^xsd:decimal
#   ?sumXX = "204"^^xsd:decimal
#   ?sumXY = "266.00000000000006"^^xsd:decimal
#   ?sumY = "46"^^xsd:decimal
#   ?sumYY = "379.72"^^xsd:decimal
#   ?x2s = ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)
#   ?xs = (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)
#   ?xys = ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)
#   ?y2s = ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)
#   ?ys = (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :sumX "36"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :sumY "46"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#   } (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#   } (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)) log:collectAllIn ?_b1 .
#   (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0) math:sum "36"^^xsd:decimal .
#   (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1) math:sum "46"^^xsd:decimal .
#   (?x2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       (?x 2.0) math:exponentiation ?x2 .
#   } ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal) math:sum "204"^^xsd:decimal .
#   (?y2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#   } ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal) math:sum "379.72"^^xsd:decimal .
#   (?xy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x ?y) math:product ?xy .
#   } ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal) math:sum "266.00000000000006"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?x2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x 2.0) math:exponentiation ?x2 .
#     } ?x2s) log:collectAllIn ?_b1 .
#     ?x2s math:sum ?sumXX .
#     (?y2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#     } ?y2s) log:collectAllIn ?_b1 .
#     ?y2s math:sum ?sumYY .
#     (?xy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?y) math:product ?xy .
#     } ?xys) log:collectAllIn ?_b1 .
#     ?xys math:sum ?sumXY .
#   } => {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sumX .
#     :Reg1 :sumY ?sumY .
#     :Reg1 :sumXX ?sumXX .
#     :Reg1 :sumYY ?sumYY .
#     :Reg1 :sumXY ?sumXY .
#   } .
# with substitution (on rule variables):
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?sumX = "36"^^xsd:decimal
#   ?sumXX = "204"^^xsd:decimal
#   ?sumXY = "266.00000000000006"^^xsd:decimal
#   ?sumY = "46"^^xsd:decimal
#   ?sumYY = "379.72"^^xsd:decimal
#   ?x2s = ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)
#   ?xs = (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)
#   ?xys = ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)
#   ?y2s = ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)
#   ?ys = (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :sumY "46"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :sumXX "204"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#   } (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#   } (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)) log:collectAllIn ?_b1 .
#   (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0) math:sum "36"^^xsd:decimal .
#   (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1) math:sum "46"^^xsd:decimal .
#   (?x2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       (?x 2.0) math:exponentiation ?x2 .
#   } ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal) math:sum "204"^^xsd:decimal .
#   (?y2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#   } ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal) math:sum "379.72"^^xsd:decimal .
#   (?xy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x ?y) math:product ?xy .
#   } ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal) math:sum "266.00000000000006"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?x2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x 2.0) math:exponentiation ?x2 .
#     } ?x2s) log:collectAllIn ?_b1 .
#     ?x2s math:sum ?sumXX .
#     (?y2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#     } ?y2s) log:collectAllIn ?_b1 .
#     ?y2s math:sum ?sumYY .
#     (?xy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?y) math:product ?xy .
#     } ?xys) log:collectAllIn ?_b1 .
#     ?xys math:sum ?sumXY .
#   } => {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sumX .
#     :Reg1 :sumY ?sumY .
#     :Reg1 :sumXX ?sumXX .
#     :Reg1 :sumYY ?sumYY .
#     :Reg1 :sumXY ?sumXY .
#   } .
# with substitution (on rule variables):
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?sumX = "36"^^xsd:decimal
#   ?sumXX = "204"^^xsd:decimal
#   ?sumXY = "266.00000000000006"^^xsd:decimal
#   ?sumY = "46"^^xsd:decimal
#   ?sumYY = "379.72"^^xsd:decimal
#   ?x2s = ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)
#   ?xs = (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)
#   ?xys = ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)
#   ?y2s = ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)
#   ?ys = (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :sumXX "204"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :sumYY "379.72"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#   } (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#   } (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)) log:collectAllIn ?_b1 .
#   (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0) math:sum "36"^^xsd:decimal .
#   (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1) math:sum "46"^^xsd:decimal .
#   (?x2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       (?x 2.0) math:exponentiation ?x2 .
#   } ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal) math:sum "204"^^xsd:decimal .
#   (?y2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#   } ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal) math:sum "379.72"^^xsd:decimal .
#   (?xy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x ?y) math:product ?xy .
#   } ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal) math:sum "266.00000000000006"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?x2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x 2.0) math:exponentiation ?x2 .
#     } ?x2s) log:collectAllIn ?_b1 .
#     ?x2s math:sum ?sumXX .
#     (?y2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#     } ?y2s) log:collectAllIn ?_b1 .
#     ?y2s math:sum ?sumYY .
#     (?xy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?y) math:product ?xy .
#     } ?xys) log:collectAllIn ?_b1 .
#     ?xys math:sum ?sumXY .
#   } => {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sumX .
#     :Reg1 :sumY ?sumY .
#     :Reg1 :sumXX ?sumXX .
#     :Reg1 :sumYY ?sumYY .
#     :Reg1 :sumXY ?sumXY .
#   } .
# with substitution (on rule variables):
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?sumX = "36"^^xsd:decimal
#   ?sumXX = "204"^^xsd:decimal
#   ?sumXY = "266.00000000000006"^^xsd:decimal
#   ?sumY = "46"^^xsd:decimal
#   ?sumYY = "379.72"^^xsd:decimal
#   ?x2s = ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)
#   ?xs = (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)
#   ?xys = ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)
#   ?y2s = ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)
#   ?ys = (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :sumYY "379.72"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :sumXY "266.00000000000006"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?x {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#   } (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)) log:collectAllIn ?_b1 .
#   (?y {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#   } (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)) log:collectAllIn ?_b1 .
#   (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0) math:sum "36"^^xsd:decimal .
#   (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1) math:sum "46"^^xsd:decimal .
#   (?x2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       (?x 2.0) math:exponentiation ?x2 .
#   } ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal) math:sum "204"^^xsd:decimal .
#   (?y2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :y ?y .
#       (?y 2.0) math:exponentiation ?y2 .
#   } ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal) math:sum "379.72"^^xsd:decimal .
#   (?xy {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       (?x ?y) math:product ?xy .
#   } ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal) math:sum "266.00000000000006"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     ?pts list:length ?n .
#     (?x {
#         ?pts list:member ?p .
#         ?p :x ?x .
#     } ?xs) log:collectAllIn ?_b1 .
#     (?y {
#         ?pts list:member ?p .
#         ?p :y ?y .
#     } ?ys) log:collectAllIn ?_b1 .
#     ?xs math:sum ?sumX .
#     ?ys math:sum ?sumY .
#     (?x2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         (?x 2.0) math:exponentiation ?x2 .
#     } ?x2s) log:collectAllIn ?_b1 .
#     ?x2s math:sum ?sumXX .
#     (?y2 {
#         ?pts list:member ?p .
#         ?p :y ?y .
#         (?y 2.0) math:exponentiation ?y2 .
#     } ?y2s) log:collectAllIn ?_b1 .
#     ?y2s math:sum ?sumYY .
#     (?xy {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?x ?y) math:product ?xy .
#     } ?xys) log:collectAllIn ?_b1 .
#     ?xys math:sum ?sumXY .
#   } => {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sumX .
#     :Reg1 :sumY ?sumY .
#     :Reg1 :sumXX ?sumXX .
#     :Reg1 :sumYY ?sumYY .
#     :Reg1 :sumXY ?sumXY .
#   } .
# with substitution (on rule variables):
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?sumX = "36"^^xsd:decimal
#   ?sumXX = "204"^^xsd:decimal
#   ?sumXY = "266.00000000000006"^^xsd:decimal
#   ?sumY = "46"^^xsd:decimal
#   ?sumYY = "379.72"^^xsd:decimal
#   ?x2s = ("64"^^xsd:decimal "49"^^xsd:decimal "36"^^xsd:decimal "25"^^xsd:decimal "16"^^xsd:decimal "9"^^xsd:decimal "4"^^xsd:decimal "1"^^xsd:decimal)
#   ?xs = (8.0 7.0 6.0 5.0 4.0 3.0 2.0 1.0)
#   ?xys = ("120"^^xsd:decimal "49"^^xsd:decimal "35.400000000000006"^^xsd:decimal "25.5"^^xsd:decimal "16.8"^^xsd:decimal "11.399999999999999"^^xsd:decimal "5.8"^^xsd:decimal "2.1"^^xsd:decimal)
#   ?y2s = ("225"^^xsd:decimal "49"^^xsd:decimal "34.81"^^xsd:decimal "26.009999999999998"^^xsd:decimal "17.64"^^xsd:decimal "14.44"^^xsd:decimal "8.41"^^xsd:decimal "4.41"^^xsd:decimal)
#   ?ys = (15.0 7.0 5.9 5.1 4.2 3.8 2.9 2.1)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :sumXY "266.00000000000006"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :n 8 .
#   :Reg1 :sumX "36"^^xsd:decimal .
#   :Reg1 :sumY "46"^^xsd:decimal .
#   :Reg1 :sumXX "204"^^xsd:decimal .
#   :Reg1 :sumYY "379.72"^^xsd:decimal .
#   :Reg1 :sumXY "266.00000000000006"^^xsd:decimal .
#   (8 "266.00000000000006"^^xsd:decimal) math:product "2128.0000000000005"^^xsd:decimal .
#   ("36"^^xsd:decimal "46"^^xsd:decimal) math:product "1656"^^xsd:decimal .
#   ("2128.0000000000005"^^xsd:decimal "1656"^^xsd:decimal) math:difference "472.00000000000045"^^xsd:decimal .
#   (8 "204"^^xsd:decimal) math:product "1632"^^xsd:decimal .
#   ("36"^^xsd:decimal 2.0) math:exponentiation "1296"^^xsd:decimal .
#   ("1632"^^xsd:decimal "1296"^^xsd:decimal) math:difference "336"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "336"^^xsd:decimal) math:quotient "1.4047619047619062"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal "36"^^xsd:decimal) math:product "50.571428571428626"^^xsd:decimal .
#   ("46"^^xsd:decimal "50.571428571428626"^^xsd:decimal) math:difference "-4.571428571428626"^^xsd:decimal .
#   ("-4.571428571428626"^^xsd:decimal 8) math:quotient "-0.5714285714285783"^^xsd:decimal .
#   (8 "379.72"^^xsd:decimal) math:product "3037.76"^^xsd:decimal .
#   ("46"^^xsd:decimal 2.0) math:exponentiation "2116"^^xsd:decimal .
#   ("3037.76"^^xsd:decimal "2116"^^xsd:decimal) math:difference "921.7600000000002"^^xsd:decimal .
#   ("336"^^xsd:decimal "921.7600000000002"^^xsd:decimal) math:product "309711.3600000001"^^xsd:decimal .
#   ("309711.3600000001"^^xsd:decimal 0.5) math:exponentiation "556.5171695464571"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "556.5171695464571"^^xsd:decimal) math:quotient "0.8481319639871393"^^xsd:decimal .
#   ("0.8481319639871393"^^xsd:decimal 2.0) math:exponentiation "0.7193278283366822"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sx .
#     :Reg1 :sumY ?sy .
#     :Reg1 :sumXX ?sxx .
#     :Reg1 :sumYY ?syy .
#     :Reg1 :sumXY ?sxy .
#     (?n ?sxy) math:product ?n_sxy .
#     (?sx ?sy) math:product ?sx_sy .
#     (?n_sxy ?sx_sy) math:difference ?num .
#     (?n ?sxx) math:product ?n_sxx .
#     (?sx 2.0) math:exponentiation ?sx2 .
#     (?n_sxx ?sx2) math:difference ?denX .
#     (?num ?denX) math:quotient ?b .
#     (?b ?sx) math:product ?b_sx .
#     (?sy ?b_sx) math:difference ?tmpA .
#     (?tmpA ?n) math:quotient ?a .
#     (?n ?syy) math:product ?n_syy .
#     (?sy 2.0) math:exponentiation ?sy2 .
#     (?n_syy ?sy2) math:difference ?denY .
#     (?denX ?denY) math:product ?denXY .
#     (?denXY 0.5) math:exponentiation ?sqrtDen .
#     (?num ?sqrtDen) math:quotient ?r .
#     (?r 2.0) math:exponentiation ?r2 .
#   } => {
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :pearsonR ?r .
#     :Reg1 :rSquared ?r2 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?b_sx = "50.571428571428626"^^xsd:decimal
#   ?denX = "336"^^xsd:decimal
#   ?denXY = "309711.3600000001"^^xsd:decimal
#   ?denY = "921.7600000000002"^^xsd:decimal
#   ?n = 8
#   ?n_sxx = "1632"^^xsd:decimal
#   ?n_sxy = "2128.0000000000005"^^xsd:decimal
#   ?n_syy = "3037.76"^^xsd:decimal
#   ?num = "472.00000000000045"^^xsd:decimal
#   ?r = "0.8481319639871393"^^xsd:decimal
#   ?r2 = "0.7193278283366822"^^xsd:decimal
#   ?sqrtDen = "556.5171695464571"^^xsd:decimal
#   ?sx = "36"^^xsd:decimal
#   ?sx2 = "1296"^^xsd:decimal
#   ?sx_sy = "1656"^^xsd:decimal
#   ?sxx = "204"^^xsd:decimal
#   ?sxy = "266.00000000000006"^^xsd:decimal
#   ?sy = "46"^^xsd:decimal
#   ?sy2 = "2116"^^xsd:decimal
#   ?syy = "379.72"^^xsd:decimal
#   ?tmpA = "-4.571428571428626"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :slope "1.4047619047619062"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :n 8 .
#   :Reg1 :sumX "36"^^xsd:decimal .
#   :Reg1 :sumY "46"^^xsd:decimal .
#   :Reg1 :sumXX "204"^^xsd:decimal .
#   :Reg1 :sumYY "379.72"^^xsd:decimal .
#   :Reg1 :sumXY "266.00000000000006"^^xsd:decimal .
#   (8 "266.00000000000006"^^xsd:decimal) math:product "2128.0000000000005"^^xsd:decimal .
#   ("36"^^xsd:decimal "46"^^xsd:decimal) math:product "1656"^^xsd:decimal .
#   ("2128.0000000000005"^^xsd:decimal "1656"^^xsd:decimal) math:difference "472.00000000000045"^^xsd:decimal .
#   (8 "204"^^xsd:decimal) math:product "1632"^^xsd:decimal .
#   ("36"^^xsd:decimal 2.0) math:exponentiation "1296"^^xsd:decimal .
#   ("1632"^^xsd:decimal "1296"^^xsd:decimal) math:difference "336"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "336"^^xsd:decimal) math:quotient "1.4047619047619062"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal "36"^^xsd:decimal) math:product "50.571428571428626"^^xsd:decimal .
#   ("46"^^xsd:decimal "50.571428571428626"^^xsd:decimal) math:difference "-4.571428571428626"^^xsd:decimal .
#   ("-4.571428571428626"^^xsd:decimal 8) math:quotient "-0.5714285714285783"^^xsd:decimal .
#   (8 "379.72"^^xsd:decimal) math:product "3037.76"^^xsd:decimal .
#   ("46"^^xsd:decimal 2.0) math:exponentiation "2116"^^xsd:decimal .
#   ("3037.76"^^xsd:decimal "2116"^^xsd:decimal) math:difference "921.7600000000002"^^xsd:decimal .
#   ("336"^^xsd:decimal "921.7600000000002"^^xsd:decimal) math:product "309711.3600000001"^^xsd:decimal .
#   ("309711.3600000001"^^xsd:decimal 0.5) math:exponentiation "556.5171695464571"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "556.5171695464571"^^xsd:decimal) math:quotient "0.8481319639871393"^^xsd:decimal .
#   ("0.8481319639871393"^^xsd:decimal 2.0) math:exponentiation "0.7193278283366822"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sx .
#     :Reg1 :sumY ?sy .
#     :Reg1 :sumXX ?sxx .
#     :Reg1 :sumYY ?syy .
#     :Reg1 :sumXY ?sxy .
#     (?n ?sxy) math:product ?n_sxy .
#     (?sx ?sy) math:product ?sx_sy .
#     (?n_sxy ?sx_sy) math:difference ?num .
#     (?n ?sxx) math:product ?n_sxx .
#     (?sx 2.0) math:exponentiation ?sx2 .
#     (?n_sxx ?sx2) math:difference ?denX .
#     (?num ?denX) math:quotient ?b .
#     (?b ?sx) math:product ?b_sx .
#     (?sy ?b_sx) math:difference ?tmpA .
#     (?tmpA ?n) math:quotient ?a .
#     (?n ?syy) math:product ?n_syy .
#     (?sy 2.0) math:exponentiation ?sy2 .
#     (?n_syy ?sy2) math:difference ?denY .
#     (?denX ?denY) math:product ?denXY .
#     (?denXY 0.5) math:exponentiation ?sqrtDen .
#     (?num ?sqrtDen) math:quotient ?r .
#     (?r 2.0) math:exponentiation ?r2 .
#   } => {
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :pearsonR ?r .
#     :Reg1 :rSquared ?r2 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?b_sx = "50.571428571428626"^^xsd:decimal
#   ?denX = "336"^^xsd:decimal
#   ?denXY = "309711.3600000001"^^xsd:decimal
#   ?denY = "921.7600000000002"^^xsd:decimal
#   ?n = 8
#   ?n_sxx = "1632"^^xsd:decimal
#   ?n_sxy = "2128.0000000000005"^^xsd:decimal
#   ?n_syy = "3037.76"^^xsd:decimal
#   ?num = "472.00000000000045"^^xsd:decimal
#   ?r = "0.8481319639871393"^^xsd:decimal
#   ?r2 = "0.7193278283366822"^^xsd:decimal
#   ?sqrtDen = "556.5171695464571"^^xsd:decimal
#   ?sx = "36"^^xsd:decimal
#   ?sx2 = "1296"^^xsd:decimal
#   ?sx_sy = "1656"^^xsd:decimal
#   ?sxx = "204"^^xsd:decimal
#   ?sxy = "266.00000000000006"^^xsd:decimal
#   ?sy = "46"^^xsd:decimal
#   ?sy2 = "2116"^^xsd:decimal
#   ?syy = "379.72"^^xsd:decimal
#   ?tmpA = "-4.571428571428626"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :pearsonR "0.8481319639871393"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :n 8 .
#   :Reg1 :sumX "36"^^xsd:decimal .
#   :Reg1 :sumY "46"^^xsd:decimal .
#   :Reg1 :sumXX "204"^^xsd:decimal .
#   :Reg1 :sumYY "379.72"^^xsd:decimal .
#   :Reg1 :sumXY "266.00000000000006"^^xsd:decimal .
#   (8 "266.00000000000006"^^xsd:decimal) math:product "2128.0000000000005"^^xsd:decimal .
#   ("36"^^xsd:decimal "46"^^xsd:decimal) math:product "1656"^^xsd:decimal .
#   ("2128.0000000000005"^^xsd:decimal "1656"^^xsd:decimal) math:difference "472.00000000000045"^^xsd:decimal .
#   (8 "204"^^xsd:decimal) math:product "1632"^^xsd:decimal .
#   ("36"^^xsd:decimal 2.0) math:exponentiation "1296"^^xsd:decimal .
#   ("1632"^^xsd:decimal "1296"^^xsd:decimal) math:difference "336"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "336"^^xsd:decimal) math:quotient "1.4047619047619062"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal "36"^^xsd:decimal) math:product "50.571428571428626"^^xsd:decimal .
#   ("46"^^xsd:decimal "50.571428571428626"^^xsd:decimal) math:difference "-4.571428571428626"^^xsd:decimal .
#   ("-4.571428571428626"^^xsd:decimal 8) math:quotient "-0.5714285714285783"^^xsd:decimal .
#   (8 "379.72"^^xsd:decimal) math:product "3037.76"^^xsd:decimal .
#   ("46"^^xsd:decimal 2.0) math:exponentiation "2116"^^xsd:decimal .
#   ("3037.76"^^xsd:decimal "2116"^^xsd:decimal) math:difference "921.7600000000002"^^xsd:decimal .
#   ("336"^^xsd:decimal "921.7600000000002"^^xsd:decimal) math:product "309711.3600000001"^^xsd:decimal .
#   ("309711.3600000001"^^xsd:decimal 0.5) math:exponentiation "556.5171695464571"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "556.5171695464571"^^xsd:decimal) math:quotient "0.8481319639871393"^^xsd:decimal .
#   ("0.8481319639871393"^^xsd:decimal 2.0) math:exponentiation "0.7193278283366822"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sx .
#     :Reg1 :sumY ?sy .
#     :Reg1 :sumXX ?sxx .
#     :Reg1 :sumYY ?syy .
#     :Reg1 :sumXY ?sxy .
#     (?n ?sxy) math:product ?n_sxy .
#     (?sx ?sy) math:product ?sx_sy .
#     (?n_sxy ?sx_sy) math:difference ?num .
#     (?n ?sxx) math:product ?n_sxx .
#     (?sx 2.0) math:exponentiation ?sx2 .
#     (?n_sxx ?sx2) math:difference ?denX .
#     (?num ?denX) math:quotient ?b .
#     (?b ?sx) math:product ?b_sx .
#     (?sy ?b_sx) math:difference ?tmpA .
#     (?tmpA ?n) math:quotient ?a .
#     (?n ?syy) math:product ?n_syy .
#     (?sy 2.0) math:exponentiation ?sy2 .
#     (?n_syy ?sy2) math:difference ?denY .
#     (?denX ?denY) math:product ?denXY .
#     (?denXY 0.5) math:exponentiation ?sqrtDen .
#     (?num ?sqrtDen) math:quotient ?r .
#     (?r 2.0) math:exponentiation ?r2 .
#   } => {
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :pearsonR ?r .
#     :Reg1 :rSquared ?r2 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?b_sx = "50.571428571428626"^^xsd:decimal
#   ?denX = "336"^^xsd:decimal
#   ?denXY = "309711.3600000001"^^xsd:decimal
#   ?denY = "921.7600000000002"^^xsd:decimal
#   ?n = 8
#   ?n_sxx = "1632"^^xsd:decimal
#   ?n_sxy = "2128.0000000000005"^^xsd:decimal
#   ?n_syy = "3037.76"^^xsd:decimal
#   ?num = "472.00000000000045"^^xsd:decimal
#   ?r = "0.8481319639871393"^^xsd:decimal
#   ?r2 = "0.7193278283366822"^^xsd:decimal
#   ?sqrtDen = "556.5171695464571"^^xsd:decimal
#   ?sx = "36"^^xsd:decimal
#   ?sx2 = "1296"^^xsd:decimal
#   ?sx_sy = "1656"^^xsd:decimal
#   ?sxx = "204"^^xsd:decimal
#   ?sxy = "266.00000000000006"^^xsd:decimal
#   ?sy = "46"^^xsd:decimal
#   ?sy2 = "2116"^^xsd:decimal
#   ?syy = "379.72"^^xsd:decimal
#   ?tmpA = "-4.571428571428626"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :pearsonR "0.8481319639871393"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :rSquared "0.7193278283366822"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :n 8 .
#   :Reg1 :sumX "36"^^xsd:decimal .
#   :Reg1 :sumY "46"^^xsd:decimal .
#   :Reg1 :sumXX "204"^^xsd:decimal .
#   :Reg1 :sumYY "379.72"^^xsd:decimal .
#   :Reg1 :sumXY "266.00000000000006"^^xsd:decimal .
#   (8 "266.00000000000006"^^xsd:decimal) math:product "2128.0000000000005"^^xsd:decimal .
#   ("36"^^xsd:decimal "46"^^xsd:decimal) math:product "1656"^^xsd:decimal .
#   ("2128.0000000000005"^^xsd:decimal "1656"^^xsd:decimal) math:difference "472.00000000000045"^^xsd:decimal .
#   (8 "204"^^xsd:decimal) math:product "1632"^^xsd:decimal .
#   ("36"^^xsd:decimal 2.0) math:exponentiation "1296"^^xsd:decimal .
#   ("1632"^^xsd:decimal "1296"^^xsd:decimal) math:difference "336"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "336"^^xsd:decimal) math:quotient "1.4047619047619062"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal "36"^^xsd:decimal) math:product "50.571428571428626"^^xsd:decimal .
#   ("46"^^xsd:decimal "50.571428571428626"^^xsd:decimal) math:difference "-4.571428571428626"^^xsd:decimal .
#   ("-4.571428571428626"^^xsd:decimal 8) math:quotient "-0.5714285714285783"^^xsd:decimal .
#   (8 "379.72"^^xsd:decimal) math:product "3037.76"^^xsd:decimal .
#   ("46"^^xsd:decimal 2.0) math:exponentiation "2116"^^xsd:decimal .
#   ("3037.76"^^xsd:decimal "2116"^^xsd:decimal) math:difference "921.7600000000002"^^xsd:decimal .
#   ("336"^^xsd:decimal "921.7600000000002"^^xsd:decimal) math:product "309711.3600000001"^^xsd:decimal .
#   ("309711.3600000001"^^xsd:decimal 0.5) math:exponentiation "556.5171695464571"^^xsd:decimal .
#   ("472.00000000000045"^^xsd:decimal "556.5171695464571"^^xsd:decimal) math:quotient "0.8481319639871393"^^xsd:decimal .
#   ("0.8481319639871393"^^xsd:decimal 2.0) math:exponentiation "0.7193278283366822"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :n ?n .
#     :Reg1 :sumX ?sx .
#     :Reg1 :sumY ?sy .
#     :Reg1 :sumXX ?sxx .
#     :Reg1 :sumYY ?syy .
#     :Reg1 :sumXY ?sxy .
#     (?n ?sxy) math:product ?n_sxy .
#     (?sx ?sy) math:product ?sx_sy .
#     (?n_sxy ?sx_sy) math:difference ?num .
#     (?n ?sxx) math:product ?n_sxx .
#     (?sx 2.0) math:exponentiation ?sx2 .
#     (?n_sxx ?sx2) math:difference ?denX .
#     (?num ?denX) math:quotient ?b .
#     (?b ?sx) math:product ?b_sx .
#     (?sy ?b_sx) math:difference ?tmpA .
#     (?tmpA ?n) math:quotient ?a .
#     (?n ?syy) math:product ?n_syy .
#     (?sy 2.0) math:exponentiation ?sy2 .
#     (?n_syy ?sy2) math:difference ?denY .
#     (?denX ?denY) math:product ?denXY .
#     (?denXY 0.5) math:exponentiation ?sqrtDen .
#     (?num ?sqrtDen) math:quotient ?r .
#     (?r 2.0) math:exponentiation ?r2 .
#   } => {
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :pearsonR ?r .
#     :Reg1 :rSquared ?r2 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?b_sx = "50.571428571428626"^^xsd:decimal
#   ?denX = "336"^^xsd:decimal
#   ?denXY = "309711.3600000001"^^xsd:decimal
#   ?denY = "921.7600000000002"^^xsd:decimal
#   ?n = 8
#   ?n_sxx = "1632"^^xsd:decimal
#   ?n_sxy = "2128.0000000000005"^^xsd:decimal
#   ?n_syy = "3037.76"^^xsd:decimal
#   ?num = "472.00000000000045"^^xsd:decimal
#   ?r = "0.8481319639871393"^^xsd:decimal
#   ?r2 = "0.7193278283366822"^^xsd:decimal
#   ?sqrtDen = "556.5171695464571"^^xsd:decimal
#   ?sx = "36"^^xsd:decimal
#   ?sx2 = "1296"^^xsd:decimal
#   ?sx_sy = "1656"^^xsd:decimal
#   ?sxx = "204"^^xsd:decimal
#   ?sxy = "266.00000000000006"^^xsd:decimal
#   ?sy = "46"^^xsd:decimal
#   ?sy2 = "2116"^^xsd:decimal
#   ?syy = "379.72"^^xsd:decimal
#   ?tmpA = "-4.571428571428626"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :rSquared "0.7193278283366822"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :sse "32.33904761904761"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?e2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       ("1.4047619047619062"^^xsd:decimal ?x) math:product ?bx .
#       ("-0.5714285714285783"^^xsd:decimal ?bx) math:sum ?yhat .
#       (?y ?yhat) math:difference ?e .
#       (?e 2.0) math:exponentiation ?e2 .
#   } ("18.777777777777736"^^xsd:decimal "5.116213151927449"^^xsd:decimal "3.8304081632653135"^^xsd:decimal "1.8289342403628133"^^xsd:decimal "0.7184580498866192"^^xsd:decimal "0.02469387755102107"^^xsd:decimal "0.43811791383220466"^^xsd:decimal "1.6044444444444583"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("18.777777777777736"^^xsd:decimal "5.116213151927449"^^xsd:decimal "3.8304081632653135"^^xsd:decimal "1.8289342403628133"^^xsd:decimal "0.7184580498866192"^^xsd:decimal "0.02469387755102107"^^xsd:decimal "0.43811791383220466"^^xsd:decimal "1.6044444444444583"^^xsd:decimal) math:sum "32.33904761904761"^^xsd:decimal .
#   ("32.33904761904761"^^xsd:decimal 8) math:quotient "4.0423809523809515"^^xsd:decimal .
#   ("4.0423809523809515"^^xsd:decimal 0.5) math:exponentiation "2.010567321026817"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     ?pts list:length ?n .
#     (?e2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?b ?x) math:product ?bx .
#         (?a ?bx) math:sum ?yhat .
#         (?y ?yhat) math:difference ?e .
#         (?e 2.0) math:exponentiation ?e2 .
#     } ?e2s) log:collectAllIn ?_b1 .
#     ?e2s math:sum ?sse .
#     (?sse ?n) math:quotient ?mse .
#     (?mse 0.5) math:exponentiation ?rmse .
#   } => {
#     :Reg1 :sse ?sse .
#     :Reg1 :rmse ?rmse .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?e2s = ("18.777777777777736"^^xsd:decimal "5.116213151927449"^^xsd:decimal "3.8304081632653135"^^xsd:decimal "1.8289342403628133"^^xsd:decimal "0.7184580498866192"^^xsd:decimal "0.02469387755102107"^^xsd:decimal "0.43811791383220466"^^xsd:decimal "1.6044444444444583"^^xsd:decimal)
#   ?mse = "4.0423809523809515"^^xsd:decimal
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?sse = "32.33904761904761"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :sse "32.33904761904761"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:length 8 .
#   (?e2 {
#       (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member ?p .
#       ?p :x ?x .
#       ?p :y ?y .
#       ("1.4047619047619062"^^xsd:decimal ?x) math:product ?bx .
#       ("-0.5714285714285783"^^xsd:decimal ?bx) math:sum ?yhat .
#       (?y ?yhat) math:difference ?e .
#       (?e 2.0) math:exponentiation ?e2 .
#   } ("18.777777777777736"^^xsd:decimal "5.116213151927449"^^xsd:decimal "3.8304081632653135"^^xsd:decimal "1.8289342403628133"^^xsd:decimal "0.7184580498866192"^^xsd:decimal "0.02469387755102107"^^xsd:decimal "0.43811791383220466"^^xsd:decimal "1.6044444444444583"^^xsd:decimal)) log:collectAllIn ?_b1 .
#   ("18.777777777777736"^^xsd:decimal "5.116213151927449"^^xsd:decimal "3.8304081632653135"^^xsd:decimal "1.8289342403628133"^^xsd:decimal "0.7184580498866192"^^xsd:decimal "0.02469387755102107"^^xsd:decimal "0.43811791383220466"^^xsd:decimal "1.6044444444444583"^^xsd:decimal) math:sum "32.33904761904761"^^xsd:decimal .
#   ("32.33904761904761"^^xsd:decimal 8) math:quotient "4.0423809523809515"^^xsd:decimal .
#   ("4.0423809523809515"^^xsd:decimal 0.5) math:exponentiation "2.010567321026817"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     ?pts list:length ?n .
#     (?e2 {
#         ?pts list:member ?p .
#         ?p :x ?x .
#         ?p :y ?y .
#         (?b ?x) math:product ?bx .
#         (?a ?bx) math:sum ?yhat .
#         (?y ?yhat) math:difference ?e .
#         (?e 2.0) math:exponentiation ?e2 .
#     } ?e2s) log:collectAllIn ?_b1 .
#     ?e2s math:sum ?sse .
#     (?sse ?n) math:quotient ?mse .
#     (?mse 0.5) math:exponentiation ?rmse .
#   } => {
#     :Reg1 :sse ?sse .
#     :Reg1 :rmse ?rmse .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?e2s = ("18.777777777777736"^^xsd:decimal "5.116213151927449"^^xsd:decimal "3.8304081632653135"^^xsd:decimal "1.8289342403628133"^^xsd:decimal "0.7184580498866192"^^xsd:decimal "0.02469387755102107"^^xsd:decimal "0.43811791383220466"^^xsd:decimal "1.6044444444444583"^^xsd:decimal)
#   ?mse = "4.0423809523809515"^^xsd:decimal
#   ?n = 8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?sse = "32.33904761904761"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :rmse "2.010567321026817"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :point _:b8 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member _:b8 .
#   _:b8 :x 8.0 .
#   _:b8 :y 15.0 .
#   ("1.4047619047619062"^^xsd:decimal 8.0) math:product "11.23809523809525"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.23809523809525"^^xsd:decimal) math:sum "10.666666666666671"^^xsd:decimal .
#   (15.0 "10.666666666666671"^^xsd:decimal) math:difference "4.333333333333329"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:absoluteValue "4.333333333333329"^^xsd:decimal .
#   (2.0 "2.010567321026817"^^xsd:decimal) math:product "4.021134642053634"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:greaterThan "4.021134642053634"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :rmse ?rmse .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?b ?x) math:product ?bx .
#     (?a ?bx) math:sum ?yhat .
#     (?y ?yhat) math:difference ?e .
#     ?e math:absoluteValue ?ae .
#     (2.0 ?rmse) math:product ?thr .
#     ?ae math:greaterThan ?thr .
#   } => {
#     _:b9 :point ?p .
#     _:b9 :x ?x .
#     _:b9 :y ?y .
#     _:b9 :yhat ?yhat .
#     _:b9 :residual ?e .
#     :Reg1 :highResidual _:b9 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?ae = "4.333333333333329"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx = "11.23809523809525"^^xsd:decimal
#   ?e = "4.333333333333329"^^xsd:decimal
#   ?p = _:b8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?thr = "4.021134642053634"^^xsd:decimal
#   ?x = 8.0
#   ?y = 15.0
#   ?yhat = "10.666666666666671"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :point _:b8 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :x 8.0 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member _:b8 .
#   _:b8 :x 8.0 .
#   _:b8 :y 15.0 .
#   ("1.4047619047619062"^^xsd:decimal 8.0) math:product "11.23809523809525"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.23809523809525"^^xsd:decimal) math:sum "10.666666666666671"^^xsd:decimal .
#   (15.0 "10.666666666666671"^^xsd:decimal) math:difference "4.333333333333329"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:absoluteValue "4.333333333333329"^^xsd:decimal .
#   (2.0 "2.010567321026817"^^xsd:decimal) math:product "4.021134642053634"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:greaterThan "4.021134642053634"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :rmse ?rmse .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?b ?x) math:product ?bx .
#     (?a ?bx) math:sum ?yhat .
#     (?y ?yhat) math:difference ?e .
#     ?e math:absoluteValue ?ae .
#     (2.0 ?rmse) math:product ?thr .
#     ?ae math:greaterThan ?thr .
#   } => {
#     _:b9 :point ?p .
#     _:b9 :x ?x .
#     _:b9 :y ?y .
#     _:b9 :yhat ?yhat .
#     _:b9 :residual ?e .
#     :Reg1 :highResidual _:b9 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?ae = "4.333333333333329"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx = "11.23809523809525"^^xsd:decimal
#   ?e = "4.333333333333329"^^xsd:decimal
#   ?p = _:b8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?thr = "4.021134642053634"^^xsd:decimal
#   ?x = 8.0
#   ?y = 15.0
#   ?yhat = "10.666666666666671"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :x 8.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :y 15.0 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member _:b8 .
#   _:b8 :x 8.0 .
#   _:b8 :y 15.0 .
#   ("1.4047619047619062"^^xsd:decimal 8.0) math:product "11.23809523809525"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.23809523809525"^^xsd:decimal) math:sum "10.666666666666671"^^xsd:decimal .
#   (15.0 "10.666666666666671"^^xsd:decimal) math:difference "4.333333333333329"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:absoluteValue "4.333333333333329"^^xsd:decimal .
#   (2.0 "2.010567321026817"^^xsd:decimal) math:product "4.021134642053634"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:greaterThan "4.021134642053634"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :rmse ?rmse .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?b ?x) math:product ?bx .
#     (?a ?bx) math:sum ?yhat .
#     (?y ?yhat) math:difference ?e .
#     ?e math:absoluteValue ?ae .
#     (2.0 ?rmse) math:product ?thr .
#     ?ae math:greaterThan ?thr .
#   } => {
#     _:b9 :point ?p .
#     _:b9 :x ?x .
#     _:b9 :y ?y .
#     _:b9 :yhat ?yhat .
#     _:b9 :residual ?e .
#     :Reg1 :highResidual _:b9 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?ae = "4.333333333333329"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx = "11.23809523809525"^^xsd:decimal
#   ?e = "4.333333333333329"^^xsd:decimal
#   ?p = _:b8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?thr = "4.021134642053634"^^xsd:decimal
#   ?x = 8.0
#   ?y = 15.0
#   ?yhat = "10.666666666666671"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :y 15.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :yhat "10.666666666666671"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member _:b8 .
#   _:b8 :x 8.0 .
#   _:b8 :y 15.0 .
#   ("1.4047619047619062"^^xsd:decimal 8.0) math:product "11.23809523809525"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.23809523809525"^^xsd:decimal) math:sum "10.666666666666671"^^xsd:decimal .
#   (15.0 "10.666666666666671"^^xsd:decimal) math:difference "4.333333333333329"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:absoluteValue "4.333333333333329"^^xsd:decimal .
#   (2.0 "2.010567321026817"^^xsd:decimal) math:product "4.021134642053634"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:greaterThan "4.021134642053634"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :rmse ?rmse .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?b ?x) math:product ?bx .
#     (?a ?bx) math:sum ?yhat .
#     (?y ?yhat) math:difference ?e .
#     ?e math:absoluteValue ?ae .
#     (2.0 ?rmse) math:product ?thr .
#     ?ae math:greaterThan ?thr .
#   } => {
#     _:b9 :point ?p .
#     _:b9 :x ?x .
#     _:b9 :y ?y .
#     _:b9 :yhat ?yhat .
#     _:b9 :residual ?e .
#     :Reg1 :highResidual _:b9 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?ae = "4.333333333333329"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx = "11.23809523809525"^^xsd:decimal
#   ?e = "4.333333333333329"^^xsd:decimal
#   ?p = _:b8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?thr = "4.021134642053634"^^xsd:decimal
#   ?x = 8.0
#   ?y = 15.0
#   ?yhat = "10.666666666666671"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :yhat "10.666666666666671"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :residual "4.333333333333329"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member _:b8 .
#   _:b8 :x 8.0 .
#   _:b8 :y 15.0 .
#   ("1.4047619047619062"^^xsd:decimal 8.0) math:product "11.23809523809525"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.23809523809525"^^xsd:decimal) math:sum "10.666666666666671"^^xsd:decimal .
#   (15.0 "10.666666666666671"^^xsd:decimal) math:difference "4.333333333333329"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:absoluteValue "4.333333333333329"^^xsd:decimal .
#   (2.0 "2.010567321026817"^^xsd:decimal) math:product "4.021134642053634"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:greaterThan "4.021134642053634"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :rmse ?rmse .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?b ?x) math:product ?bx .
#     (?a ?bx) math:sum ?yhat .
#     (?y ?yhat) math:difference ?e .
#     ?e math:absoluteValue ?ae .
#     (2.0 ?rmse) math:product ?thr .
#     ?ae math:greaterThan ?thr .
#   } => {
#     _:b9 :point ?p .
#     _:b9 :x ?x .
#     _:b9 :y ?y .
#     _:b9 :yhat ?yhat .
#     _:b9 :residual ?e .
#     :Reg1 :highResidual _:b9 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?ae = "4.333333333333329"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx = "11.23809523809525"^^xsd:decimal
#   ?e = "4.333333333333329"^^xsd:decimal
#   ?p = _:b8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?thr = "4.021134642053634"^^xsd:decimal
#   ?x = 8.0
#   ?y = 15.0
#   ?yhat = "10.666666666666671"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :residual "4.333333333333329"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :highResidual _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :points (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   :Reg1 :rmse "2.010567321026817"^^xsd:decimal .
#   (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8) list:member _:b8 .
#   _:b8 :x 8.0 .
#   _:b8 :y 15.0 .
#   ("1.4047619047619062"^^xsd:decimal 8.0) math:product "11.23809523809525"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.23809523809525"^^xsd:decimal) math:sum "10.666666666666671"^^xsd:decimal .
#   (15.0 "10.666666666666671"^^xsd:decimal) math:difference "4.333333333333329"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:absoluteValue "4.333333333333329"^^xsd:decimal .
#   (2.0 "2.010567321026817"^^xsd:decimal) math:product "4.021134642053634"^^xsd:decimal .
#   "4.333333333333329"^^xsd:decimal math:greaterThan "4.021134642053634"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :points ?pts .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     :Reg1 :rmse ?rmse .
#     ?pts list:member ?p .
#     ?p :x ?x .
#     ?p :y ?y .
#     (?b ?x) math:product ?bx .
#     (?a ?bx) math:sum ?yhat .
#     (?y ?yhat) math:difference ?e .
#     ?e math:absoluteValue ?ae .
#     (2.0 ?rmse) math:product ?thr .
#     ?ae math:greaterThan ?thr .
#   } => {
#     _:b9 :point ?p .
#     _:b9 :x ?x .
#     _:b9 :y ?y .
#     _:b9 :yhat ?yhat .
#     _:b9 :residual ?e .
#     :Reg1 :highResidual _:b9 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?ae = "4.333333333333329"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx = "11.23809523809525"^^xsd:decimal
#   ?e = "4.333333333333329"^^xsd:decimal
#   ?p = _:b8
#   ?pts = (_:b1 _:b2 _:b3 _:b4 _:b5 _:b6 _:b7 _:b8)
#   ?rmse = "2.010567321026817"^^xsd:decimal
#   ?thr = "4.021134642053634"^^xsd:decimal
#   ?x = 8.0
#   ?y = 15.0
#   ?yhat = "10.666666666666671"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :highResidual _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :x 8.5 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :predictX 8.5 .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal 8.5) math:product "11.940476190476202"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.940476190476202"^^xsd:decimal) math:sum "11.369047619047624"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :predictX ?x0 .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     (?b ?x0) math:product ?bx0 .
#     (?a ?bx0) math:sum ?y0 .
#   } => {
#     _:b10 :x ?x0 .
#     _:b10 :y ?y0 .
#     :Reg1 :prediction _:b10 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx0 = "11.940476190476202"^^xsd:decimal
#   ?x0 = 8.5
#   ?y0 = "11.369047619047624"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :x 8.5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :y "11.369047619047624"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :predictX 8.5 .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal 8.5) math:product "11.940476190476202"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.940476190476202"^^xsd:decimal) math:sum "11.369047619047624"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :predictX ?x0 .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     (?b ?x0) math:product ?bx0 .
#     (?a ?bx0) math:sum ?y0 .
#   } => {
#     _:b10 :x ?x0 .
#     _:b10 :y ?y0 .
#     :Reg1 :prediction _:b10 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx0 = "11.940476190476202"^^xsd:decimal
#   ?x0 = 8.5
#   ?y0 = "11.369047619047624"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :y "11.369047619047624"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Reg1 :prediction _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :Reg1 :predictX 8.5 .
#   :Reg1 :slope "1.4047619047619062"^^xsd:decimal .
#   :Reg1 :intercept "-0.5714285714285783"^^xsd:decimal .
#   ("1.4047619047619062"^^xsd:decimal 8.5) math:product "11.940476190476202"^^xsd:decimal .
#   ("-0.5714285714285783"^^xsd:decimal "11.940476190476202"^^xsd:decimal) math:sum "11.369047619047624"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :Reg1 :predictX ?x0 .
#     :Reg1 :slope ?b .
#     :Reg1 :intercept ?a .
#     (?b ?x0) math:product ?bx0 .
#     (?a ?bx0) math:sum ?y0 .
#   } => {
#     _:b10 :x ?x0 .
#     _:b10 :y ?y0 .
#     :Reg1 :prediction _:b10 .
#   } .
# with substitution (on rule variables):
#   ?a = "-0.5714285714285783"^^xsd:decimal
#   ?b = "1.4047619047619062"^^xsd:decimal
#   ?bx0 = "11.940476190476202"^^xsd:decimal
#   ?x0 = 8.5
#   ?y0 = "11.369047619047624"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Reg1 :prediction _:sk_1 .

