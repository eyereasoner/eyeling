@prefix : <http://example.org/topaz-markov#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :rowOk _:b3 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b3 .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.25 0.25) math:sum "0.5"^^xsd:decimal .
#   ("0.5"^^xsd:decimal 0.50) math:sum "1"^^xsd:decimal .
#   "1"^^xsd:decimal math:equalTo 1.0 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?r .
#     ?r :pA ?a .
#     ?r :pB ?b .
#     ?r :pC ?c .
#     (?a ?b) math:sum ?ab .
#     (?ab ?c) math:sum ?sum .
#     ?sum math:equalTo 1.0 .
#   } => {
#     :MC1 :rowOk ?r .
#   } .
# with substitution (on rule variables):
#   ?a = 0.25
#   ?ab = "0.5"^^xsd:decimal
#   ?b = 0.25
#   ?c = 0.50
#   ?r = _:b3
#   ?sum = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :rowOk _:b3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :rowOk _:b2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b2 .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   (0.10 0.70) math:sum "0.7999999999999999"^^xsd:decimal .
#   ("0.7999999999999999"^^xsd:decimal 0.20) math:sum "1"^^xsd:decimal .
#   "1"^^xsd:decimal math:equalTo 1.0 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?r .
#     ?r :pA ?a .
#     ?r :pB ?b .
#     ?r :pC ?c .
#     (?a ?b) math:sum ?ab .
#     (?ab ?c) math:sum ?sum .
#     ?sum math:equalTo 1.0 .
#   } => {
#     :MC1 :rowOk ?r .
#   } .
# with substitution (on rule variables):
#   ?a = 0.10
#   ?ab = "0.7999999999999999"^^xsd:decimal
#   ?b = 0.70
#   ?c = 0.20
#   ?r = _:b2
#   ?sum = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :rowOk _:b2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :rowOk _:b1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   (0.80 0.15) math:sum "0.9500000000000001"^^xsd:decimal .
#   ("0.9500000000000001"^^xsd:decimal 0.05) math:sum "1"^^xsd:decimal .
#   "1"^^xsd:decimal math:equalTo 1.0 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?r .
#     ?r :pA ?a .
#     ?r :pB ?b .
#     ?r :pC ?c .
#     (?a ?b) math:sum ?ab .
#     (?ab ?c) math:sum ?sum .
#     ?sum math:equalTo 1.0 .
#   } => {
#     :MC1 :rowOk ?r .
#   } .
# with substitution (on rule variables):
#   ?a = 0.80
#   ?ab = "0.9500000000000001"^^xsd:decimal
#   ?b = 0.15
#   ?c = 0.05
#   ?r = _:b1
#   ?sum = "1"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :rowOk _:b1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :pA "0.535"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product "0.48"^^xsd:decimal .
#   (0.30 0.10) math:product "0.03"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.48"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.51"^^xsd:decimal .
#   ("0.51"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.535"^^xsd:decimal .
#   (0.60 0.15) math:product "0.09"^^xsd:decimal .
#   (0.30 0.70) math:product "0.21"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.21"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.325"^^xsd:decimal .
#   (0.60 0.05) math:product "0.03"^^xsd:decimal .
#   (0.30 0.20) math:product "0.06"^^xsd:decimal .
#   (0.10 0.50) math:product "0.05"^^xsd:decimal .
#   ("0.03"^^xsd:decimal "0.06"^^xsd:decimal) math:sum "0.09"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.05"^^xsd:decimal) math:sum "0.14"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = "0.535"^^xsd:decimal
#   ?pi1B = "0.325"^^xsd:decimal
#   ?pi1C = "0.14"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.51"^^xsd:decimal
#   ?s2 = "0.3"^^xsd:decimal
#   ?s3 = "0.09"^^xsd:decimal
#   ?tAA = "0.48"^^xsd:decimal
#   ?tAB = "0.09"^^xsd:decimal
#   ?tAC = "0.03"^^xsd:decimal
#   ?tBA = "0.03"^^xsd:decimal
#   ?tBB = "0.21"^^xsd:decimal
#   ?tBC = "0.06"^^xsd:decimal
#   ?tCA = "0.025"^^xsd:decimal
#   ?tCB = "0.025"^^xsd:decimal
#   ?tCC = "0.05"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :pA "0.535"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :pB "0.325"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product "0.48"^^xsd:decimal .
#   (0.30 0.10) math:product "0.03"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.48"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.51"^^xsd:decimal .
#   ("0.51"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.535"^^xsd:decimal .
#   (0.60 0.15) math:product "0.09"^^xsd:decimal .
#   (0.30 0.70) math:product "0.21"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.21"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.325"^^xsd:decimal .
#   (0.60 0.05) math:product "0.03"^^xsd:decimal .
#   (0.30 0.20) math:product "0.06"^^xsd:decimal .
#   (0.10 0.50) math:product "0.05"^^xsd:decimal .
#   ("0.03"^^xsd:decimal "0.06"^^xsd:decimal) math:sum "0.09"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.05"^^xsd:decimal) math:sum "0.14"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = "0.535"^^xsd:decimal
#   ?pi1B = "0.325"^^xsd:decimal
#   ?pi1C = "0.14"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.51"^^xsd:decimal
#   ?s2 = "0.3"^^xsd:decimal
#   ?s3 = "0.09"^^xsd:decimal
#   ?tAA = "0.48"^^xsd:decimal
#   ?tAB = "0.09"^^xsd:decimal
#   ?tAC = "0.03"^^xsd:decimal
#   ?tBA = "0.03"^^xsd:decimal
#   ?tBB = "0.21"^^xsd:decimal
#   ?tBC = "0.06"^^xsd:decimal
#   ?tCA = "0.025"^^xsd:decimal
#   ?tCB = "0.025"^^xsd:decimal
#   ?tCC = "0.05"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :pB "0.325"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :pC "0.14"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product "0.48"^^xsd:decimal .
#   (0.30 0.10) math:product "0.03"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.48"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.51"^^xsd:decimal .
#   ("0.51"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.535"^^xsd:decimal .
#   (0.60 0.15) math:product "0.09"^^xsd:decimal .
#   (0.30 0.70) math:product "0.21"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.21"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.325"^^xsd:decimal .
#   (0.60 0.05) math:product "0.03"^^xsd:decimal .
#   (0.30 0.20) math:product "0.06"^^xsd:decimal .
#   (0.10 0.50) math:product "0.05"^^xsd:decimal .
#   ("0.03"^^xsd:decimal "0.06"^^xsd:decimal) math:sum "0.09"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.05"^^xsd:decimal) math:sum "0.14"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = "0.535"^^xsd:decimal
#   ?pi1B = "0.325"^^xsd:decimal
#   ?pi1C = "0.14"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.51"^^xsd:decimal
#   ?s2 = "0.3"^^xsd:decimal
#   ?s3 = "0.09"^^xsd:decimal
#   ?tAA = "0.48"^^xsd:decimal
#   ?tAB = "0.09"^^xsd:decimal
#   ?tAC = "0.03"^^xsd:decimal
#   ?tBA = "0.03"^^xsd:decimal
#   ?tBB = "0.21"^^xsd:decimal
#   ?tBC = "0.06"^^xsd:decimal
#   ?tCA = "0.025"^^xsd:decimal
#   ?tCB = "0.025"^^xsd:decimal
#   ?tCC = "0.05"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :pC "0.14"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :pi1 _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product "0.48"^^xsd:decimal .
#   (0.30 0.10) math:product "0.03"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.48"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.51"^^xsd:decimal .
#   ("0.51"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.535"^^xsd:decimal .
#   (0.60 0.15) math:product "0.09"^^xsd:decimal .
#   (0.30 0.70) math:product "0.21"^^xsd:decimal .
#   (0.10 0.25) math:product "0.025"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.21"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.325"^^xsd:decimal .
#   (0.60 0.05) math:product "0.03"^^xsd:decimal .
#   (0.30 0.20) math:product "0.06"^^xsd:decimal .
#   (0.10 0.50) math:product "0.05"^^xsd:decimal .
#   ("0.03"^^xsd:decimal "0.06"^^xsd:decimal) math:sum "0.09"^^xsd:decimal .
#   ("0.09"^^xsd:decimal "0.05"^^xsd:decimal) math:sum "0.14"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = "0.535"^^xsd:decimal
#   ?pi1B = "0.325"^^xsd:decimal
#   ?pi1C = "0.14"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.51"^^xsd:decimal
#   ?s2 = "0.3"^^xsd:decimal
#   ?s3 = "0.09"^^xsd:decimal
#   ?tAA = "0.48"^^xsd:decimal
#   ?tAB = "0.09"^^xsd:decimal
#   ?tAC = "0.03"^^xsd:decimal
#   ?tBA = "0.03"^^xsd:decimal
#   ?tBB = "0.21"^^xsd:decimal
#   ?tBC = "0.06"^^xsd:decimal
#   ?tCA = "0.025"^^xsd:decimal
#   ?tCB = "0.025"^^xsd:decimal
#   ?tCC = "0.05"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :pi1 _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.80) math:product "0.42800000000000005"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.10) math:product "0.0325"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.42800000000000005"^^xsd:decimal "0.0325"^^xsd:decimal) math:sum "0.4605"^^xsd:decimal .
#   ("0.4605"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.49550000000000005"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.15) math:product "0.08025"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.70) math:product "0.22749999999999998"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.08025"^^xsd:decimal "0.22749999999999998"^^xsd:decimal) math:sum "0.30774999999999997"^^xsd:decimal .
#   ("0.30774999999999997"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.34275"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.05) math:product "0.026750000000000003"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.20) math:product "0.065"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.50) math:product "0.07"^^xsd:decimal .
#   ("0.026750000000000003"^^xsd:decimal "0.065"^^xsd:decimal) math:sum "0.09175"^^xsd:decimal .
#   ("0.09175"^^xsd:decimal "0.07"^^xsd:decimal) math:sum "0.16175"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.535"^^xsd:decimal
#   ?pB = "0.325"^^xsd:decimal
#   ?pC = "0.14"^^xsd:decimal
#   ?pi = _:sk_0
#   ?pi2A = "0.49550000000000005"^^xsd:decimal
#   ?pi2B = "0.34275"^^xsd:decimal
#   ?pi2C = "0.16175"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4605"^^xsd:decimal
#   ?s2 = "0.30774999999999997"^^xsd:decimal
#   ?s3 = "0.09175"^^xsd:decimal
#   ?tAA = "0.42800000000000005"^^xsd:decimal
#   ?tAB = "0.08025"^^xsd:decimal
#   ?tAC = "0.026750000000000003"^^xsd:decimal
#   ?tBA = "0.0325"^^xsd:decimal
#   ?tBB = "0.22749999999999998"^^xsd:decimal
#   ?tBC = "0.065"^^xsd:decimal
#   ?tCA = "0.035"^^xsd:decimal
#   ?tCB = "0.035"^^xsd:decimal
#   ?tCC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :pA "0.49550000000000005"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.80) math:product "0.42800000000000005"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.10) math:product "0.0325"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.42800000000000005"^^xsd:decimal "0.0325"^^xsd:decimal) math:sum "0.4605"^^xsd:decimal .
#   ("0.4605"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.49550000000000005"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.15) math:product "0.08025"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.70) math:product "0.22749999999999998"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.08025"^^xsd:decimal "0.22749999999999998"^^xsd:decimal) math:sum "0.30774999999999997"^^xsd:decimal .
#   ("0.30774999999999997"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.34275"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.05) math:product "0.026750000000000003"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.20) math:product "0.065"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.50) math:product "0.07"^^xsd:decimal .
#   ("0.026750000000000003"^^xsd:decimal "0.065"^^xsd:decimal) math:sum "0.09175"^^xsd:decimal .
#   ("0.09175"^^xsd:decimal "0.07"^^xsd:decimal) math:sum "0.16175"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.535"^^xsd:decimal
#   ?pB = "0.325"^^xsd:decimal
#   ?pC = "0.14"^^xsd:decimal
#   ?pi = _:sk_0
#   ?pi2A = "0.49550000000000005"^^xsd:decimal
#   ?pi2B = "0.34275"^^xsd:decimal
#   ?pi2C = "0.16175"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4605"^^xsd:decimal
#   ?s2 = "0.30774999999999997"^^xsd:decimal
#   ?s3 = "0.09175"^^xsd:decimal
#   ?tAA = "0.42800000000000005"^^xsd:decimal
#   ?tAB = "0.08025"^^xsd:decimal
#   ?tAC = "0.026750000000000003"^^xsd:decimal
#   ?tBA = "0.0325"^^xsd:decimal
#   ?tBB = "0.22749999999999998"^^xsd:decimal
#   ?tBC = "0.065"^^xsd:decimal
#   ?tCA = "0.035"^^xsd:decimal
#   ?tCB = "0.035"^^xsd:decimal
#   ?tCC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :pB "0.34275"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.80) math:product "0.42800000000000005"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.10) math:product "0.0325"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.42800000000000005"^^xsd:decimal "0.0325"^^xsd:decimal) math:sum "0.4605"^^xsd:decimal .
#   ("0.4605"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.49550000000000005"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.15) math:product "0.08025"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.70) math:product "0.22749999999999998"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.08025"^^xsd:decimal "0.22749999999999998"^^xsd:decimal) math:sum "0.30774999999999997"^^xsd:decimal .
#   ("0.30774999999999997"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.34275"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.05) math:product "0.026750000000000003"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.20) math:product "0.065"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.50) math:product "0.07"^^xsd:decimal .
#   ("0.026750000000000003"^^xsd:decimal "0.065"^^xsd:decimal) math:sum "0.09175"^^xsd:decimal .
#   ("0.09175"^^xsd:decimal "0.07"^^xsd:decimal) math:sum "0.16175"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.535"^^xsd:decimal
#   ?pB = "0.325"^^xsd:decimal
#   ?pC = "0.14"^^xsd:decimal
#   ?pi = _:sk_0
#   ?pi2A = "0.49550000000000005"^^xsd:decimal
#   ?pi2B = "0.34275"^^xsd:decimal
#   ?pi2C = "0.16175"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4605"^^xsd:decimal
#   ?s2 = "0.30774999999999997"^^xsd:decimal
#   ?s3 = "0.09175"^^xsd:decimal
#   ?tAA = "0.42800000000000005"^^xsd:decimal
#   ?tAB = "0.08025"^^xsd:decimal
#   ?tAC = "0.026750000000000003"^^xsd:decimal
#   ?tBA = "0.0325"^^xsd:decimal
#   ?tBB = "0.22749999999999998"^^xsd:decimal
#   ?tBC = "0.065"^^xsd:decimal
#   ?tCA = "0.035"^^xsd:decimal
#   ?tCB = "0.035"^^xsd:decimal
#   ?tCC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :pC "0.16175"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :pi2 _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.80) math:product "0.42800000000000005"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.10) math:product "0.0325"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.42800000000000005"^^xsd:decimal "0.0325"^^xsd:decimal) math:sum "0.4605"^^xsd:decimal .
#   ("0.4605"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.49550000000000005"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.15) math:product "0.08025"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.70) math:product "0.22749999999999998"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.25) math:product "0.035"^^xsd:decimal .
#   ("0.08025"^^xsd:decimal "0.22749999999999998"^^xsd:decimal) math:sum "0.30774999999999997"^^xsd:decimal .
#   ("0.30774999999999997"^^xsd:decimal "0.035"^^xsd:decimal) math:sum "0.34275"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 0.05) math:product "0.026750000000000003"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 0.20) math:product "0.065"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 0.50) math:product "0.07"^^xsd:decimal .
#   ("0.026750000000000003"^^xsd:decimal "0.065"^^xsd:decimal) math:sum "0.09175"^^xsd:decimal .
#   ("0.09175"^^xsd:decimal "0.07"^^xsd:decimal) math:sum "0.16175"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.535"^^xsd:decimal
#   ?pB = "0.325"^^xsd:decimal
#   ?pC = "0.14"^^xsd:decimal
#   ?pi = _:sk_0
#   ?pi2A = "0.49550000000000005"^^xsd:decimal
#   ?pi2B = "0.34275"^^xsd:decimal
#   ?pi2C = "0.16175"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4605"^^xsd:decimal
#   ?s2 = "0.30774999999999997"^^xsd:decimal
#   ?s3 = "0.09175"^^xsd:decimal
#   ?tAA = "0.42800000000000005"^^xsd:decimal
#   ?tAB = "0.08025"^^xsd:decimal
#   ?tAC = "0.026750000000000003"^^xsd:decimal
#   ?tBA = "0.0325"^^xsd:decimal
#   ?tBB = "0.22749999999999998"^^xsd:decimal
#   ?tBC = "0.065"^^xsd:decimal
#   ?tCA = "0.035"^^xsd:decimal
#   ?tCB = "0.035"^^xsd:decimal
#   ?tCC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :pi2 _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :pA "0.4711125000000001"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.80) math:product "0.3964000000000001"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.10) math:product "0.034275"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.3964000000000001"^^xsd:decimal "0.034275"^^xsd:decimal) math:sum "0.4306750000000001"^^xsd:decimal .
#   ("0.4306750000000001"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.4711125000000001"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.15) math:product "0.074325"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.70) math:product "0.23992499999999997"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.074325"^^xsd:decimal "0.23992499999999997"^^xsd:decimal) math:sum "0.31425"^^xsd:decimal .
#   ("0.31425"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.3546875"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.05) math:product "0.024775000000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.20) math:product "0.06855"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.50) math:product "0.080875"^^xsd:decimal .
#   ("0.024775000000000005"^^xsd:decimal "0.06855"^^xsd:decimal) math:sum "0.093325"^^xsd:decimal .
#   ("0.093325"^^xsd:decimal "0.080875"^^xsd:decimal) math:sum "0.17420000000000002"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.49550000000000005"^^xsd:decimal
#   ?pB = "0.34275"^^xsd:decimal
#   ?pC = "0.16175"^^xsd:decimal
#   ?pi = _:sk_1
#   ?pi3A = "0.4711125000000001"^^xsd:decimal
#   ?pi3B = "0.3546875"^^xsd:decimal
#   ?pi3C = "0.17420000000000002"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4306750000000001"^^xsd:decimal
#   ?s2 = "0.31425"^^xsd:decimal
#   ?s3 = "0.093325"^^xsd:decimal
#   ?tAA = "0.3964000000000001"^^xsd:decimal
#   ?tAB = "0.074325"^^xsd:decimal
#   ?tAC = "0.024775000000000005"^^xsd:decimal
#   ?tBA = "0.034275"^^xsd:decimal
#   ?tBB = "0.23992499999999997"^^xsd:decimal
#   ?tBC = "0.06855"^^xsd:decimal
#   ?tCA = "0.0404375"^^xsd:decimal
#   ?tCB = "0.0404375"^^xsd:decimal
#   ?tCC = "0.080875"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :pA "0.4711125000000001"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :pB "0.3546875"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.80) math:product "0.3964000000000001"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.10) math:product "0.034275"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.3964000000000001"^^xsd:decimal "0.034275"^^xsd:decimal) math:sum "0.4306750000000001"^^xsd:decimal .
#   ("0.4306750000000001"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.4711125000000001"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.15) math:product "0.074325"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.70) math:product "0.23992499999999997"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.074325"^^xsd:decimal "0.23992499999999997"^^xsd:decimal) math:sum "0.31425"^^xsd:decimal .
#   ("0.31425"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.3546875"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.05) math:product "0.024775000000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.20) math:product "0.06855"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.50) math:product "0.080875"^^xsd:decimal .
#   ("0.024775000000000005"^^xsd:decimal "0.06855"^^xsd:decimal) math:sum "0.093325"^^xsd:decimal .
#   ("0.093325"^^xsd:decimal "0.080875"^^xsd:decimal) math:sum "0.17420000000000002"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.49550000000000005"^^xsd:decimal
#   ?pB = "0.34275"^^xsd:decimal
#   ?pC = "0.16175"^^xsd:decimal
#   ?pi = _:sk_1
#   ?pi3A = "0.4711125000000001"^^xsd:decimal
#   ?pi3B = "0.3546875"^^xsd:decimal
#   ?pi3C = "0.17420000000000002"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4306750000000001"^^xsd:decimal
#   ?s2 = "0.31425"^^xsd:decimal
#   ?s3 = "0.093325"^^xsd:decimal
#   ?tAA = "0.3964000000000001"^^xsd:decimal
#   ?tAB = "0.074325"^^xsd:decimal
#   ?tAC = "0.024775000000000005"^^xsd:decimal
#   ?tBA = "0.034275"^^xsd:decimal
#   ?tBB = "0.23992499999999997"^^xsd:decimal
#   ?tBC = "0.06855"^^xsd:decimal
#   ?tCA = "0.0404375"^^xsd:decimal
#   ?tCB = "0.0404375"^^xsd:decimal
#   ?tCC = "0.080875"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :pB "0.3546875"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :pC "0.17420000000000002"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.80) math:product "0.3964000000000001"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.10) math:product "0.034275"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.3964000000000001"^^xsd:decimal "0.034275"^^xsd:decimal) math:sum "0.4306750000000001"^^xsd:decimal .
#   ("0.4306750000000001"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.4711125000000001"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.15) math:product "0.074325"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.70) math:product "0.23992499999999997"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.074325"^^xsd:decimal "0.23992499999999997"^^xsd:decimal) math:sum "0.31425"^^xsd:decimal .
#   ("0.31425"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.3546875"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.05) math:product "0.024775000000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.20) math:product "0.06855"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.50) math:product "0.080875"^^xsd:decimal .
#   ("0.024775000000000005"^^xsd:decimal "0.06855"^^xsd:decimal) math:sum "0.093325"^^xsd:decimal .
#   ("0.093325"^^xsd:decimal "0.080875"^^xsd:decimal) math:sum "0.17420000000000002"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.49550000000000005"^^xsd:decimal
#   ?pB = "0.34275"^^xsd:decimal
#   ?pC = "0.16175"^^xsd:decimal
#   ?pi = _:sk_1
#   ?pi3A = "0.4711125000000001"^^xsd:decimal
#   ?pi3B = "0.3546875"^^xsd:decimal
#   ?pi3C = "0.17420000000000002"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4306750000000001"^^xsd:decimal
#   ?s2 = "0.31425"^^xsd:decimal
#   ?s3 = "0.093325"^^xsd:decimal
#   ?tAA = "0.3964000000000001"^^xsd:decimal
#   ?tAB = "0.074325"^^xsd:decimal
#   ?tAC = "0.024775000000000005"^^xsd:decimal
#   ?tBA = "0.034275"^^xsd:decimal
#   ?tBB = "0.23992499999999997"^^xsd:decimal
#   ?tBC = "0.06855"^^xsd:decimal
#   ?tCA = "0.0404375"^^xsd:decimal
#   ?tCB = "0.0404375"^^xsd:decimal
#   ?tCC = "0.080875"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :pC "0.17420000000000002"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :pi3 _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.80) math:product "0.3964000000000001"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.10) math:product "0.034275"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.3964000000000001"^^xsd:decimal "0.034275"^^xsd:decimal) math:sum "0.4306750000000001"^^xsd:decimal .
#   ("0.4306750000000001"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.4711125000000001"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.15) math:product "0.074325"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.70) math:product "0.23992499999999997"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.25) math:product "0.0404375"^^xsd:decimal .
#   ("0.074325"^^xsd:decimal "0.23992499999999997"^^xsd:decimal) math:sum "0.31425"^^xsd:decimal .
#   ("0.31425"^^xsd:decimal "0.0404375"^^xsd:decimal) math:sum "0.3546875"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 0.05) math:product "0.024775000000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 0.20) math:product "0.06855"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 0.50) math:product "0.080875"^^xsd:decimal .
#   ("0.024775000000000005"^^xsd:decimal "0.06855"^^xsd:decimal) math:sum "0.093325"^^xsd:decimal .
#   ("0.093325"^^xsd:decimal "0.080875"^^xsd:decimal) math:sum "0.17420000000000002"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = "0.49550000000000005"^^xsd:decimal
#   ?pB = "0.34275"^^xsd:decimal
#   ?pC = "0.16175"^^xsd:decimal
#   ?pi = _:sk_1
#   ?pi3A = "0.4711125000000001"^^xsd:decimal
#   ?pi3B = "0.3546875"^^xsd:decimal
#   ?pi3C = "0.17420000000000002"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = "0.4306750000000001"^^xsd:decimal
#   ?s2 = "0.31425"^^xsd:decimal
#   ?s3 = "0.093325"^^xsd:decimal
#   ?tAA = "0.3964000000000001"^^xsd:decimal
#   ?tAB = "0.074325"^^xsd:decimal
#   ?tAC = "0.024775000000000005"^^xsd:decimal
#   ?tBA = "0.034275"^^xsd:decimal
#   ?tBB = "0.23992499999999997"^^xsd:decimal
#   ?tBC = "0.06855"^^xsd:decimal
#   ?tCA = "0.0404375"^^xsd:decimal
#   ?tCB = "0.0404375"^^xsd:decimal
#   ?tCC = "0.080875"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :pi3 _:sk_2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :pA "0.6675000000000001"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product "0.6400000000000001"^^xsd:decimal .
#   (0.15 0.10) math:product "0.015"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.6400000000000001"^^xsd:decimal "0.015"^^xsd:decimal) math:sum "0.6550000000000001"^^xsd:decimal .
#   ("0.6550000000000001"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.6675000000000001"^^xsd:decimal .
#   (0.80 0.15) math:product "0.12"^^xsd:decimal .
#   (0.15 0.70) math:product "0.105"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.12"^^xsd:decimal "0.105"^^xsd:decimal) math:sum "0.22499999999999998"^^xsd:decimal .
#   ("0.22499999999999998"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.2375"^^xsd:decimal .
#   (0.80 0.05) math:product "0.04000000000000001"^^xsd:decimal .
#   (0.15 0.20) math:product "0.03"^^xsd:decimal .
#   (0.05 0.50) math:product "0.025"^^xsd:decimal .
#   ("0.04000000000000001"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.07"^^xsd:decimal .
#   ("0.07"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.095"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = "0.6400000000000001"^^xsd:decimal
#   ?AA_AB = "0.12"^^xsd:decimal
#   ?AA_AC = "0.04000000000000001"^^xsd:decimal
#   ?AB = 0.15
#   ?AB_BA = "0.015"^^xsd:decimal
#   ?AB_BB = "0.105"^^xsd:decimal
#   ?AB_BC = "0.03"^^xsd:decimal
#   ?AC = 0.05
#   ?AC_CA = "0.0125"^^xsd:decimal
#   ?AC_CB = "0.0125"^^xsd:decimal
#   ?AC_CC = "0.025"^^xsd:decimal
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = "0.6675000000000001"^^xsd:decimal
#   ?P2AB = "0.2375"^^xsd:decimal
#   ?P2AC = "0.095"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = "0.6550000000000001"^^xsd:decimal
#   ?sAB = "0.22499999999999998"^^xsd:decimal
#   ?sAC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :pA "0.6675000000000001"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :pB "0.2375"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product "0.6400000000000001"^^xsd:decimal .
#   (0.15 0.10) math:product "0.015"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.6400000000000001"^^xsd:decimal "0.015"^^xsd:decimal) math:sum "0.6550000000000001"^^xsd:decimal .
#   ("0.6550000000000001"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.6675000000000001"^^xsd:decimal .
#   (0.80 0.15) math:product "0.12"^^xsd:decimal .
#   (0.15 0.70) math:product "0.105"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.12"^^xsd:decimal "0.105"^^xsd:decimal) math:sum "0.22499999999999998"^^xsd:decimal .
#   ("0.22499999999999998"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.2375"^^xsd:decimal .
#   (0.80 0.05) math:product "0.04000000000000001"^^xsd:decimal .
#   (0.15 0.20) math:product "0.03"^^xsd:decimal .
#   (0.05 0.50) math:product "0.025"^^xsd:decimal .
#   ("0.04000000000000001"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.07"^^xsd:decimal .
#   ("0.07"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.095"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = "0.6400000000000001"^^xsd:decimal
#   ?AA_AB = "0.12"^^xsd:decimal
#   ?AA_AC = "0.04000000000000001"^^xsd:decimal
#   ?AB = 0.15
#   ?AB_BA = "0.015"^^xsd:decimal
#   ?AB_BB = "0.105"^^xsd:decimal
#   ?AB_BC = "0.03"^^xsd:decimal
#   ?AC = 0.05
#   ?AC_CA = "0.0125"^^xsd:decimal
#   ?AC_CB = "0.0125"^^xsd:decimal
#   ?AC_CC = "0.025"^^xsd:decimal
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = "0.6675000000000001"^^xsd:decimal
#   ?P2AB = "0.2375"^^xsd:decimal
#   ?P2AC = "0.095"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = "0.6550000000000001"^^xsd:decimal
#   ?sAB = "0.22499999999999998"^^xsd:decimal
#   ?sAC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :pB "0.2375"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :pC "0.095"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product "0.6400000000000001"^^xsd:decimal .
#   (0.15 0.10) math:product "0.015"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.6400000000000001"^^xsd:decimal "0.015"^^xsd:decimal) math:sum "0.6550000000000001"^^xsd:decimal .
#   ("0.6550000000000001"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.6675000000000001"^^xsd:decimal .
#   (0.80 0.15) math:product "0.12"^^xsd:decimal .
#   (0.15 0.70) math:product "0.105"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.12"^^xsd:decimal "0.105"^^xsd:decimal) math:sum "0.22499999999999998"^^xsd:decimal .
#   ("0.22499999999999998"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.2375"^^xsd:decimal .
#   (0.80 0.05) math:product "0.04000000000000001"^^xsd:decimal .
#   (0.15 0.20) math:product "0.03"^^xsd:decimal .
#   (0.05 0.50) math:product "0.025"^^xsd:decimal .
#   ("0.04000000000000001"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.07"^^xsd:decimal .
#   ("0.07"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.095"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = "0.6400000000000001"^^xsd:decimal
#   ?AA_AB = "0.12"^^xsd:decimal
#   ?AA_AC = "0.04000000000000001"^^xsd:decimal
#   ?AB = 0.15
#   ?AB_BA = "0.015"^^xsd:decimal
#   ?AB_BB = "0.105"^^xsd:decimal
#   ?AB_BC = "0.03"^^xsd:decimal
#   ?AC = 0.05
#   ?AC_CA = "0.0125"^^xsd:decimal
#   ?AC_CB = "0.0125"^^xsd:decimal
#   ?AC_CC = "0.025"^^xsd:decimal
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = "0.6675000000000001"^^xsd:decimal
#   ?P2AB = "0.2375"^^xsd:decimal
#   ?P2AC = "0.095"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = "0.6550000000000001"^^xsd:decimal
#   ?sAB = "0.22499999999999998"^^xsd:decimal
#   ?sAC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :pC "0.095"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :P2rowA _:sk_3 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product "0.6400000000000001"^^xsd:decimal .
#   (0.15 0.10) math:product "0.015"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.6400000000000001"^^xsd:decimal "0.015"^^xsd:decimal) math:sum "0.6550000000000001"^^xsd:decimal .
#   ("0.6550000000000001"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.6675000000000001"^^xsd:decimal .
#   (0.80 0.15) math:product "0.12"^^xsd:decimal .
#   (0.15 0.70) math:product "0.105"^^xsd:decimal .
#   (0.05 0.25) math:product "0.0125"^^xsd:decimal .
#   ("0.12"^^xsd:decimal "0.105"^^xsd:decimal) math:sum "0.22499999999999998"^^xsd:decimal .
#   ("0.22499999999999998"^^xsd:decimal "0.0125"^^xsd:decimal) math:sum "0.2375"^^xsd:decimal .
#   (0.80 0.05) math:product "0.04000000000000001"^^xsd:decimal .
#   (0.15 0.20) math:product "0.03"^^xsd:decimal .
#   (0.05 0.50) math:product "0.025"^^xsd:decimal .
#   ("0.04000000000000001"^^xsd:decimal "0.03"^^xsd:decimal) math:sum "0.07"^^xsd:decimal .
#   ("0.07"^^xsd:decimal "0.025"^^xsd:decimal) math:sum "0.095"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = "0.6400000000000001"^^xsd:decimal
#   ?AA_AB = "0.12"^^xsd:decimal
#   ?AA_AC = "0.04000000000000001"^^xsd:decimal
#   ?AB = 0.15
#   ?AB_BA = "0.015"^^xsd:decimal
#   ?AB_BB = "0.105"^^xsd:decimal
#   ?AB_BC = "0.03"^^xsd:decimal
#   ?AC = 0.05
#   ?AC_CA = "0.0125"^^xsd:decimal
#   ?AC_CB = "0.0125"^^xsd:decimal
#   ?AC_CC = "0.025"^^xsd:decimal
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = "0.6675000000000001"^^xsd:decimal
#   ?P2AB = "0.2375"^^xsd:decimal
#   ?P2AC = "0.095"^^xsd:decimal
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = "0.6550000000000001"^^xsd:decimal
#   ?sAB = "0.22499999999999998"^^xsd:decimal
#   ?sAC = "0.07"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :P2rowA _:sk_3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :t 0 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#   } => {
#     _:b9 :t 0 .
#     _:b9 :pi ?pi .
#     :MC1 :metrics _:b9 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :t 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :pi _:b4 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#   } => {
#     _:b9 :t 0 .
#     _:b9 :pi ?pi .
#     :MC1 :metrics _:b9 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :pi _:b4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_4 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#   } => {
#     _:b9 :t 0 .
#     _:b9 :pi ?pi .
#     :MC1 :metrics _:b9 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :t 1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#   } => {
#     _:b10 :t 1 .
#     _:b10 :pi ?pi .
#     :MC1 :metrics _:b10 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :t 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :pi _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#   } => {
#     _:b10 :t 1 .
#     _:b10 :pi ?pi .
#     :MC1 :metrics _:b10 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :pi _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_5 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#   } => {
#     _:b10 :t 1 .
#     _:b10 :pi ?pi .
#     :MC1 :metrics _:b10 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :t 2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#   } => {
#     _:b11 :t 2 .
#     _:b11 :pi ?pi .
#     :MC1 :metrics _:b11 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :t 2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :pi _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#   } => {
#     _:b11 :t 2 .
#     _:b11 :pi ?pi .
#     :MC1 :metrics _:b11 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :pi _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_6 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#   } => {
#     _:b11 :t 2 .
#     _:b11 :pi ?pi .
#     :MC1 :metrics _:b11 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_6 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :t 3 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi3 _:sk_2 .
# via the schematic forward rule:
#   {
#     :MC1 :pi3 ?pi .
#   } => {
#     _:b12 :t 3 .
#     _:b12 :pi ?pi .
#     :MC1 :metrics _:b12 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :t 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :pi _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi3 _:sk_2 .
# via the schematic forward rule:
#   {
#     :MC1 :pi3 ?pi .
#   } => {
#     _:b12 :t 3 .
#     _:b12 :pi ?pi .
#     :MC1 :metrics _:b12 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :pi _:sk_2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_7 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi3 _:sk_2 .
# via the schematic forward rule:
#   {
#     :MC1 :pi3 ?pi .
#   } => {
#     _:b12 :t 3 .
#     _:b12 :pi ?pi .
#     :MC1 :metrics _:b12 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_7 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :sumSq "0.3780958503125001"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA "0.4711125000000001"^^xsd:decimal .
#   _:sk_2 :pB "0.3546875"^^xsd:decimal .
#   _:sk_2 :pC "0.17420000000000002"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal 2.0) math:exponentiation "0.2219469876562501"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal 2.0) math:exponentiation "0.12580322265625"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal 2.0) math:exponentiation "0.030345640000000007"^^xsd:decimal .
#   ("0.2219469876562501"^^xsd:decimal "0.12580322265625"^^xsd:decimal) math:sum "0.3477502103125001"^^xsd:decimal .
#   ("0.3477502103125001"^^xsd:decimal "0.030345640000000007"^^xsd:decimal) math:sum "0.3780958503125001"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:difference "0.6219041496875"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:quotient "2.644831989490204"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.13777916666666679"^^xsd:decimal .
#   "0.13777916666666679"^^xsd:decimal math:absoluteValue "0.13777916666666679"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.021354166666666674"^^xsd:decimal .
#   "0.021354166666666674"^^xsd:decimal math:absoluteValue "0.021354166666666674"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1591333333333333"^^xsd:decimal .
#   "-0.1591333333333333"^^xsd:decimal math:absoluteValue "0.1591333333333333"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal "0.021354166666666674"^^xsd:decimal) math:sum "0.15913333333333346"^^xsd:decimal .
#   ("0.15913333333333346"^^xsd:decimal "0.1591333333333333"^^xsd:decimal) math:sum "0.31826666666666675"^^xsd:decimal .
#   (0.5 "0.31826666666666675"^^xsd:decimal) math:product "0.15913333333333338"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal 2.0) math:exponentiation "0.018983098767361144"^^xsd:decimal .
#   ("0.021354166666666674"^^xsd:decimal 2.0) math:exponentiation "0.0004560004340277781"^^xsd:decimal .
#   ("-0.1591333333333333"^^xsd:decimal 2.0) math:exponentiation "0.025323417777777767"^^xsd:decimal .
#   ("0.018983098767361144"^^xsd:decimal "0.0004560004340277781"^^xsd:decimal) math:sum "0.01943909920138892"^^xsd:decimal .
#   ("0.01943909920138892"^^xsd:decimal "0.025323417777777767"^^xsd:decimal) math:sum "0.04476251697916669"^^xsd:decimal .
#   ("0.04476251697916669"^^xsd:decimal 0.5) math:exponentiation "0.2115715410426617"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.4711125000000001"^^xsd:decimal
#   ?a2 = "0.2219469876562501"^^xsd:decimal
#   ?ab2 = "0.3477502103125001"^^xsd:decimal
#   ?ada = "0.13777916666666679"^^xsd:decimal
#   ?adb = "0.021354166666666674"^^xsd:decimal
#   ?adc = "0.1591333333333333"^^xsd:decimal
#   ?b = "0.3546875"^^xsd:decimal
#   ?b2 = "0.12580322265625"^^xsd:decimal
#   ?c = "0.17420000000000002"^^xsd:decimal
#   ?c2 = "0.030345640000000007"^^xsd:decimal
#   ?da = "0.13777916666666679"^^xsd:decimal
#   ?da2 = "0.018983098767361144"^^xsd:decimal
#   ?db = "0.021354166666666674"^^xsd:decimal
#   ?db2 = "0.0004560004340277781"^^xsd:decimal
#   ?dc = "-0.1591333333333333"^^xsd:decimal
#   ?dc2 = "0.025323417777777767"^^xsd:decimal
#   ?effN = "2.644831989490204"^^xsd:decimal
#   ?gini = "0.6219041496875"^^xsd:decimal
#   ?l2 = "0.2115715410426617"^^xsd:decimal
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = "0.15913333333333346"^^xsd:decimal
#   ?s2 = "0.01943909920138892"^^xsd:decimal
#   ?s3 = "0.04476251697916669"^^xsd:decimal
#   ?sAbs = "0.31826666666666675"^^xsd:decimal
#   ?sumSq = "0.3780958503125001"^^xsd:decimal
#   ?tv = "0.15913333333333338"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :sumSq "0.3780958503125001"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :gini "0.6219041496875"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA "0.4711125000000001"^^xsd:decimal .
#   _:sk_2 :pB "0.3546875"^^xsd:decimal .
#   _:sk_2 :pC "0.17420000000000002"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal 2.0) math:exponentiation "0.2219469876562501"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal 2.0) math:exponentiation "0.12580322265625"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal 2.0) math:exponentiation "0.030345640000000007"^^xsd:decimal .
#   ("0.2219469876562501"^^xsd:decimal "0.12580322265625"^^xsd:decimal) math:sum "0.3477502103125001"^^xsd:decimal .
#   ("0.3477502103125001"^^xsd:decimal "0.030345640000000007"^^xsd:decimal) math:sum "0.3780958503125001"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:difference "0.6219041496875"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:quotient "2.644831989490204"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.13777916666666679"^^xsd:decimal .
#   "0.13777916666666679"^^xsd:decimal math:absoluteValue "0.13777916666666679"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.021354166666666674"^^xsd:decimal .
#   "0.021354166666666674"^^xsd:decimal math:absoluteValue "0.021354166666666674"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1591333333333333"^^xsd:decimal .
#   "-0.1591333333333333"^^xsd:decimal math:absoluteValue "0.1591333333333333"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal "0.021354166666666674"^^xsd:decimal) math:sum "0.15913333333333346"^^xsd:decimal .
#   ("0.15913333333333346"^^xsd:decimal "0.1591333333333333"^^xsd:decimal) math:sum "0.31826666666666675"^^xsd:decimal .
#   (0.5 "0.31826666666666675"^^xsd:decimal) math:product "0.15913333333333338"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal 2.0) math:exponentiation "0.018983098767361144"^^xsd:decimal .
#   ("0.021354166666666674"^^xsd:decimal 2.0) math:exponentiation "0.0004560004340277781"^^xsd:decimal .
#   ("-0.1591333333333333"^^xsd:decimal 2.0) math:exponentiation "0.025323417777777767"^^xsd:decimal .
#   ("0.018983098767361144"^^xsd:decimal "0.0004560004340277781"^^xsd:decimal) math:sum "0.01943909920138892"^^xsd:decimal .
#   ("0.01943909920138892"^^xsd:decimal "0.025323417777777767"^^xsd:decimal) math:sum "0.04476251697916669"^^xsd:decimal .
#   ("0.04476251697916669"^^xsd:decimal 0.5) math:exponentiation "0.2115715410426617"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.4711125000000001"^^xsd:decimal
#   ?a2 = "0.2219469876562501"^^xsd:decimal
#   ?ab2 = "0.3477502103125001"^^xsd:decimal
#   ?ada = "0.13777916666666679"^^xsd:decimal
#   ?adb = "0.021354166666666674"^^xsd:decimal
#   ?adc = "0.1591333333333333"^^xsd:decimal
#   ?b = "0.3546875"^^xsd:decimal
#   ?b2 = "0.12580322265625"^^xsd:decimal
#   ?c = "0.17420000000000002"^^xsd:decimal
#   ?c2 = "0.030345640000000007"^^xsd:decimal
#   ?da = "0.13777916666666679"^^xsd:decimal
#   ?da2 = "0.018983098767361144"^^xsd:decimal
#   ?db = "0.021354166666666674"^^xsd:decimal
#   ?db2 = "0.0004560004340277781"^^xsd:decimal
#   ?dc = "-0.1591333333333333"^^xsd:decimal
#   ?dc2 = "0.025323417777777767"^^xsd:decimal
#   ?effN = "2.644831989490204"^^xsd:decimal
#   ?gini = "0.6219041496875"^^xsd:decimal
#   ?l2 = "0.2115715410426617"^^xsd:decimal
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = "0.15913333333333346"^^xsd:decimal
#   ?s2 = "0.01943909920138892"^^xsd:decimal
#   ?s3 = "0.04476251697916669"^^xsd:decimal
#   ?sAbs = "0.31826666666666675"^^xsd:decimal
#   ?sumSq = "0.3780958503125001"^^xsd:decimal
#   ?tv = "0.15913333333333338"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :gini "0.6219041496875"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :effectiveStates "2.644831989490204"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA "0.4711125000000001"^^xsd:decimal .
#   _:sk_2 :pB "0.3546875"^^xsd:decimal .
#   _:sk_2 :pC "0.17420000000000002"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal 2.0) math:exponentiation "0.2219469876562501"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal 2.0) math:exponentiation "0.12580322265625"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal 2.0) math:exponentiation "0.030345640000000007"^^xsd:decimal .
#   ("0.2219469876562501"^^xsd:decimal "0.12580322265625"^^xsd:decimal) math:sum "0.3477502103125001"^^xsd:decimal .
#   ("0.3477502103125001"^^xsd:decimal "0.030345640000000007"^^xsd:decimal) math:sum "0.3780958503125001"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:difference "0.6219041496875"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:quotient "2.644831989490204"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.13777916666666679"^^xsd:decimal .
#   "0.13777916666666679"^^xsd:decimal math:absoluteValue "0.13777916666666679"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.021354166666666674"^^xsd:decimal .
#   "0.021354166666666674"^^xsd:decimal math:absoluteValue "0.021354166666666674"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1591333333333333"^^xsd:decimal .
#   "-0.1591333333333333"^^xsd:decimal math:absoluteValue "0.1591333333333333"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal "0.021354166666666674"^^xsd:decimal) math:sum "0.15913333333333346"^^xsd:decimal .
#   ("0.15913333333333346"^^xsd:decimal "0.1591333333333333"^^xsd:decimal) math:sum "0.31826666666666675"^^xsd:decimal .
#   (0.5 "0.31826666666666675"^^xsd:decimal) math:product "0.15913333333333338"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal 2.0) math:exponentiation "0.018983098767361144"^^xsd:decimal .
#   ("0.021354166666666674"^^xsd:decimal 2.0) math:exponentiation "0.0004560004340277781"^^xsd:decimal .
#   ("-0.1591333333333333"^^xsd:decimal 2.0) math:exponentiation "0.025323417777777767"^^xsd:decimal .
#   ("0.018983098767361144"^^xsd:decimal "0.0004560004340277781"^^xsd:decimal) math:sum "0.01943909920138892"^^xsd:decimal .
#   ("0.01943909920138892"^^xsd:decimal "0.025323417777777767"^^xsd:decimal) math:sum "0.04476251697916669"^^xsd:decimal .
#   ("0.04476251697916669"^^xsd:decimal 0.5) math:exponentiation "0.2115715410426617"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.4711125000000001"^^xsd:decimal
#   ?a2 = "0.2219469876562501"^^xsd:decimal
#   ?ab2 = "0.3477502103125001"^^xsd:decimal
#   ?ada = "0.13777916666666679"^^xsd:decimal
#   ?adb = "0.021354166666666674"^^xsd:decimal
#   ?adc = "0.1591333333333333"^^xsd:decimal
#   ?b = "0.3546875"^^xsd:decimal
#   ?b2 = "0.12580322265625"^^xsd:decimal
#   ?c = "0.17420000000000002"^^xsd:decimal
#   ?c2 = "0.030345640000000007"^^xsd:decimal
#   ?da = "0.13777916666666679"^^xsd:decimal
#   ?da2 = "0.018983098767361144"^^xsd:decimal
#   ?db = "0.021354166666666674"^^xsd:decimal
#   ?db2 = "0.0004560004340277781"^^xsd:decimal
#   ?dc = "-0.1591333333333333"^^xsd:decimal
#   ?dc2 = "0.025323417777777767"^^xsd:decimal
#   ?effN = "2.644831989490204"^^xsd:decimal
#   ?gini = "0.6219041496875"^^xsd:decimal
#   ?l2 = "0.2115715410426617"^^xsd:decimal
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = "0.15913333333333346"^^xsd:decimal
#   ?s2 = "0.01943909920138892"^^xsd:decimal
#   ?s3 = "0.04476251697916669"^^xsd:decimal
#   ?sAbs = "0.31826666666666675"^^xsd:decimal
#   ?sumSq = "0.3780958503125001"^^xsd:decimal
#   ?tv = "0.15913333333333338"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :effectiveStates "2.644831989490204"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :tvToUniform "0.15913333333333338"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA "0.4711125000000001"^^xsd:decimal .
#   _:sk_2 :pB "0.3546875"^^xsd:decimal .
#   _:sk_2 :pC "0.17420000000000002"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal 2.0) math:exponentiation "0.2219469876562501"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal 2.0) math:exponentiation "0.12580322265625"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal 2.0) math:exponentiation "0.030345640000000007"^^xsd:decimal .
#   ("0.2219469876562501"^^xsd:decimal "0.12580322265625"^^xsd:decimal) math:sum "0.3477502103125001"^^xsd:decimal .
#   ("0.3477502103125001"^^xsd:decimal "0.030345640000000007"^^xsd:decimal) math:sum "0.3780958503125001"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:difference "0.6219041496875"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:quotient "2.644831989490204"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.13777916666666679"^^xsd:decimal .
#   "0.13777916666666679"^^xsd:decimal math:absoluteValue "0.13777916666666679"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.021354166666666674"^^xsd:decimal .
#   "0.021354166666666674"^^xsd:decimal math:absoluteValue "0.021354166666666674"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1591333333333333"^^xsd:decimal .
#   "-0.1591333333333333"^^xsd:decimal math:absoluteValue "0.1591333333333333"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal "0.021354166666666674"^^xsd:decimal) math:sum "0.15913333333333346"^^xsd:decimal .
#   ("0.15913333333333346"^^xsd:decimal "0.1591333333333333"^^xsd:decimal) math:sum "0.31826666666666675"^^xsd:decimal .
#   (0.5 "0.31826666666666675"^^xsd:decimal) math:product "0.15913333333333338"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal 2.0) math:exponentiation "0.018983098767361144"^^xsd:decimal .
#   ("0.021354166666666674"^^xsd:decimal 2.0) math:exponentiation "0.0004560004340277781"^^xsd:decimal .
#   ("-0.1591333333333333"^^xsd:decimal 2.0) math:exponentiation "0.025323417777777767"^^xsd:decimal .
#   ("0.018983098767361144"^^xsd:decimal "0.0004560004340277781"^^xsd:decimal) math:sum "0.01943909920138892"^^xsd:decimal .
#   ("0.01943909920138892"^^xsd:decimal "0.025323417777777767"^^xsd:decimal) math:sum "0.04476251697916669"^^xsd:decimal .
#   ("0.04476251697916669"^^xsd:decimal 0.5) math:exponentiation "0.2115715410426617"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.4711125000000001"^^xsd:decimal
#   ?a2 = "0.2219469876562501"^^xsd:decimal
#   ?ab2 = "0.3477502103125001"^^xsd:decimal
#   ?ada = "0.13777916666666679"^^xsd:decimal
#   ?adb = "0.021354166666666674"^^xsd:decimal
#   ?adc = "0.1591333333333333"^^xsd:decimal
#   ?b = "0.3546875"^^xsd:decimal
#   ?b2 = "0.12580322265625"^^xsd:decimal
#   ?c = "0.17420000000000002"^^xsd:decimal
#   ?c2 = "0.030345640000000007"^^xsd:decimal
#   ?da = "0.13777916666666679"^^xsd:decimal
#   ?da2 = "0.018983098767361144"^^xsd:decimal
#   ?db = "0.021354166666666674"^^xsd:decimal
#   ?db2 = "0.0004560004340277781"^^xsd:decimal
#   ?dc = "-0.1591333333333333"^^xsd:decimal
#   ?dc2 = "0.025323417777777767"^^xsd:decimal
#   ?effN = "2.644831989490204"^^xsd:decimal
#   ?gini = "0.6219041496875"^^xsd:decimal
#   ?l2 = "0.2115715410426617"^^xsd:decimal
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = "0.15913333333333346"^^xsd:decimal
#   ?s2 = "0.01943909920138892"^^xsd:decimal
#   ?s3 = "0.04476251697916669"^^xsd:decimal
#   ?sAbs = "0.31826666666666675"^^xsd:decimal
#   ?sumSq = "0.3780958503125001"^^xsd:decimal
#   ?tv = "0.15913333333333338"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :tvToUniform "0.15913333333333338"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :l2ToUniform "0.2115715410426617"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA "0.4711125000000001"^^xsd:decimal .
#   _:sk_2 :pB "0.3546875"^^xsd:decimal .
#   _:sk_2 :pC "0.17420000000000002"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal 2.0) math:exponentiation "0.2219469876562501"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal 2.0) math:exponentiation "0.12580322265625"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal 2.0) math:exponentiation "0.030345640000000007"^^xsd:decimal .
#   ("0.2219469876562501"^^xsd:decimal "0.12580322265625"^^xsd:decimal) math:sum "0.3477502103125001"^^xsd:decimal .
#   ("0.3477502103125001"^^xsd:decimal "0.030345640000000007"^^xsd:decimal) math:sum "0.3780958503125001"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:difference "0.6219041496875"^^xsd:decimal .
#   (1.0 "0.3780958503125001"^^xsd:decimal) math:quotient "2.644831989490204"^^xsd:decimal .
#   ("0.4711125000000001"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.13777916666666679"^^xsd:decimal .
#   "0.13777916666666679"^^xsd:decimal math:absoluteValue "0.13777916666666679"^^xsd:decimal .
#   ("0.3546875"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.021354166666666674"^^xsd:decimal .
#   "0.021354166666666674"^^xsd:decimal math:absoluteValue "0.021354166666666674"^^xsd:decimal .
#   ("0.17420000000000002"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1591333333333333"^^xsd:decimal .
#   "-0.1591333333333333"^^xsd:decimal math:absoluteValue "0.1591333333333333"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal "0.021354166666666674"^^xsd:decimal) math:sum "0.15913333333333346"^^xsd:decimal .
#   ("0.15913333333333346"^^xsd:decimal "0.1591333333333333"^^xsd:decimal) math:sum "0.31826666666666675"^^xsd:decimal .
#   (0.5 "0.31826666666666675"^^xsd:decimal) math:product "0.15913333333333338"^^xsd:decimal .
#   ("0.13777916666666679"^^xsd:decimal 2.0) math:exponentiation "0.018983098767361144"^^xsd:decimal .
#   ("0.021354166666666674"^^xsd:decimal 2.0) math:exponentiation "0.0004560004340277781"^^xsd:decimal .
#   ("-0.1591333333333333"^^xsd:decimal 2.0) math:exponentiation "0.025323417777777767"^^xsd:decimal .
#   ("0.018983098767361144"^^xsd:decimal "0.0004560004340277781"^^xsd:decimal) math:sum "0.01943909920138892"^^xsd:decimal .
#   ("0.01943909920138892"^^xsd:decimal "0.025323417777777767"^^xsd:decimal) math:sum "0.04476251697916669"^^xsd:decimal .
#   ("0.04476251697916669"^^xsd:decimal 0.5) math:exponentiation "0.2115715410426617"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.4711125000000001"^^xsd:decimal
#   ?a2 = "0.2219469876562501"^^xsd:decimal
#   ?ab2 = "0.3477502103125001"^^xsd:decimal
#   ?ada = "0.13777916666666679"^^xsd:decimal
#   ?adb = "0.021354166666666674"^^xsd:decimal
#   ?adc = "0.1591333333333333"^^xsd:decimal
#   ?b = "0.3546875"^^xsd:decimal
#   ?b2 = "0.12580322265625"^^xsd:decimal
#   ?c = "0.17420000000000002"^^xsd:decimal
#   ?c2 = "0.030345640000000007"^^xsd:decimal
#   ?da = "0.13777916666666679"^^xsd:decimal
#   ?da2 = "0.018983098767361144"^^xsd:decimal
#   ?db = "0.021354166666666674"^^xsd:decimal
#   ?db2 = "0.0004560004340277781"^^xsd:decimal
#   ?dc = "-0.1591333333333333"^^xsd:decimal
#   ?dc2 = "0.025323417777777767"^^xsd:decimal
#   ?effN = "2.644831989490204"^^xsd:decimal
#   ?gini = "0.6219041496875"^^xsd:decimal
#   ?l2 = "0.2115715410426617"^^xsd:decimal
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = "0.15913333333333346"^^xsd:decimal
#   ?s2 = "0.01943909920138892"^^xsd:decimal
#   ?s3 = "0.04476251697916669"^^xsd:decimal
#   ?sAbs = "0.31826666666666675"^^xsd:decimal
#   ?sumSq = "0.3780958503125001"^^xsd:decimal
#   ?tv = "0.15913333333333338"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :l2ToUniform "0.2115715410426617"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :sumSq "0.3891608750000001"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 2.0) math:exponentiation "0.24552025000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 2.0) math:exponentiation "0.1174775625"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 2.0) math:exponentiation "0.0261630625"^^xsd:decimal .
#   ("0.24552025000000005"^^xsd:decimal "0.1174775625"^^xsd:decimal) math:sum "0.36299781250000007"^^xsd:decimal .
#   ("0.36299781250000007"^^xsd:decimal "0.0261630625"^^xsd:decimal) math:sum "0.3891608750000001"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:difference "0.6108391249999999"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:quotient "2.569631389589202"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.16216666666666674"^^xsd:decimal .
#   "0.16216666666666674"^^xsd:decimal math:absoluteValue "0.16216666666666674"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.009416666666666684"^^xsd:decimal .
#   "0.009416666666666684"^^xsd:decimal math:absoluteValue "0.009416666666666684"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1715833333333333"^^xsd:decimal .
#   "-0.1715833333333333"^^xsd:decimal math:absoluteValue "0.1715833333333333"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal "0.009416666666666684"^^xsd:decimal) math:sum "0.17158333333333342"^^xsd:decimal .
#   ("0.17158333333333342"^^xsd:decimal "0.1715833333333333"^^xsd:decimal) math:sum "0.34316666666666673"^^xsd:decimal .
#   (0.5 "0.34316666666666673"^^xsd:decimal) math:product "0.17158333333333337"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal 2.0) math:exponentiation "0.026298027777777802"^^xsd:decimal .
#   ("0.009416666666666684"^^xsd:decimal 2.0) math:exponentiation "0.00008867361111111145"^^xsd:decimal .
#   ("-0.1715833333333333"^^xsd:decimal 2.0) math:exponentiation "0.02944084027777777"^^xsd:decimal .
#   ("0.026298027777777802"^^xsd:decimal "0.00008867361111111145"^^xsd:decimal) math:sum "0.026386701388888913"^^xsd:decimal .
#   ("0.026386701388888913"^^xsd:decimal "0.02944084027777777"^^xsd:decimal) math:sum "0.05582754166666668"^^xsd:decimal .
#   ("0.05582754166666668"^^xsd:decimal 0.5) math:exponentiation "0.23627852561472165"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.49550000000000005"^^xsd:decimal
#   ?a2 = "0.24552025000000005"^^xsd:decimal
#   ?ab2 = "0.36299781250000007"^^xsd:decimal
#   ?ada = "0.16216666666666674"^^xsd:decimal
#   ?adb = "0.009416666666666684"^^xsd:decimal
#   ?adc = "0.1715833333333333"^^xsd:decimal
#   ?b = "0.34275"^^xsd:decimal
#   ?b2 = "0.1174775625"^^xsd:decimal
#   ?c = "0.16175"^^xsd:decimal
#   ?c2 = "0.0261630625"^^xsd:decimal
#   ?da = "0.16216666666666674"^^xsd:decimal
#   ?da2 = "0.026298027777777802"^^xsd:decimal
#   ?db = "0.009416666666666684"^^xsd:decimal
#   ?db2 = "0.00008867361111111145"^^xsd:decimal
#   ?dc = "-0.1715833333333333"^^xsd:decimal
#   ?dc2 = "0.02944084027777777"^^xsd:decimal
#   ?effN = "2.569631389589202"^^xsd:decimal
#   ?gini = "0.6108391249999999"^^xsd:decimal
#   ?l2 = "0.23627852561472165"^^xsd:decimal
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = "0.17158333333333342"^^xsd:decimal
#   ?s2 = "0.026386701388888913"^^xsd:decimal
#   ?s3 = "0.05582754166666668"^^xsd:decimal
#   ?sAbs = "0.34316666666666673"^^xsd:decimal
#   ?sumSq = "0.3891608750000001"^^xsd:decimal
#   ?tv = "0.17158333333333337"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :sumSq "0.3891608750000001"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :gini "0.6108391249999999"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 2.0) math:exponentiation "0.24552025000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 2.0) math:exponentiation "0.1174775625"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 2.0) math:exponentiation "0.0261630625"^^xsd:decimal .
#   ("0.24552025000000005"^^xsd:decimal "0.1174775625"^^xsd:decimal) math:sum "0.36299781250000007"^^xsd:decimal .
#   ("0.36299781250000007"^^xsd:decimal "0.0261630625"^^xsd:decimal) math:sum "0.3891608750000001"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:difference "0.6108391249999999"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:quotient "2.569631389589202"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.16216666666666674"^^xsd:decimal .
#   "0.16216666666666674"^^xsd:decimal math:absoluteValue "0.16216666666666674"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.009416666666666684"^^xsd:decimal .
#   "0.009416666666666684"^^xsd:decimal math:absoluteValue "0.009416666666666684"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1715833333333333"^^xsd:decimal .
#   "-0.1715833333333333"^^xsd:decimal math:absoluteValue "0.1715833333333333"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal "0.009416666666666684"^^xsd:decimal) math:sum "0.17158333333333342"^^xsd:decimal .
#   ("0.17158333333333342"^^xsd:decimal "0.1715833333333333"^^xsd:decimal) math:sum "0.34316666666666673"^^xsd:decimal .
#   (0.5 "0.34316666666666673"^^xsd:decimal) math:product "0.17158333333333337"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal 2.0) math:exponentiation "0.026298027777777802"^^xsd:decimal .
#   ("0.009416666666666684"^^xsd:decimal 2.0) math:exponentiation "0.00008867361111111145"^^xsd:decimal .
#   ("-0.1715833333333333"^^xsd:decimal 2.0) math:exponentiation "0.02944084027777777"^^xsd:decimal .
#   ("0.026298027777777802"^^xsd:decimal "0.00008867361111111145"^^xsd:decimal) math:sum "0.026386701388888913"^^xsd:decimal .
#   ("0.026386701388888913"^^xsd:decimal "0.02944084027777777"^^xsd:decimal) math:sum "0.05582754166666668"^^xsd:decimal .
#   ("0.05582754166666668"^^xsd:decimal 0.5) math:exponentiation "0.23627852561472165"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.49550000000000005"^^xsd:decimal
#   ?a2 = "0.24552025000000005"^^xsd:decimal
#   ?ab2 = "0.36299781250000007"^^xsd:decimal
#   ?ada = "0.16216666666666674"^^xsd:decimal
#   ?adb = "0.009416666666666684"^^xsd:decimal
#   ?adc = "0.1715833333333333"^^xsd:decimal
#   ?b = "0.34275"^^xsd:decimal
#   ?b2 = "0.1174775625"^^xsd:decimal
#   ?c = "0.16175"^^xsd:decimal
#   ?c2 = "0.0261630625"^^xsd:decimal
#   ?da = "0.16216666666666674"^^xsd:decimal
#   ?da2 = "0.026298027777777802"^^xsd:decimal
#   ?db = "0.009416666666666684"^^xsd:decimal
#   ?db2 = "0.00008867361111111145"^^xsd:decimal
#   ?dc = "-0.1715833333333333"^^xsd:decimal
#   ?dc2 = "0.02944084027777777"^^xsd:decimal
#   ?effN = "2.569631389589202"^^xsd:decimal
#   ?gini = "0.6108391249999999"^^xsd:decimal
#   ?l2 = "0.23627852561472165"^^xsd:decimal
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = "0.17158333333333342"^^xsd:decimal
#   ?s2 = "0.026386701388888913"^^xsd:decimal
#   ?s3 = "0.05582754166666668"^^xsd:decimal
#   ?sAbs = "0.34316666666666673"^^xsd:decimal
#   ?sumSq = "0.3891608750000001"^^xsd:decimal
#   ?tv = "0.17158333333333337"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :gini "0.6108391249999999"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :effectiveStates "2.569631389589202"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 2.0) math:exponentiation "0.24552025000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 2.0) math:exponentiation "0.1174775625"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 2.0) math:exponentiation "0.0261630625"^^xsd:decimal .
#   ("0.24552025000000005"^^xsd:decimal "0.1174775625"^^xsd:decimal) math:sum "0.36299781250000007"^^xsd:decimal .
#   ("0.36299781250000007"^^xsd:decimal "0.0261630625"^^xsd:decimal) math:sum "0.3891608750000001"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:difference "0.6108391249999999"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:quotient "2.569631389589202"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.16216666666666674"^^xsd:decimal .
#   "0.16216666666666674"^^xsd:decimal math:absoluteValue "0.16216666666666674"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.009416666666666684"^^xsd:decimal .
#   "0.009416666666666684"^^xsd:decimal math:absoluteValue "0.009416666666666684"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1715833333333333"^^xsd:decimal .
#   "-0.1715833333333333"^^xsd:decimal math:absoluteValue "0.1715833333333333"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal "0.009416666666666684"^^xsd:decimal) math:sum "0.17158333333333342"^^xsd:decimal .
#   ("0.17158333333333342"^^xsd:decimal "0.1715833333333333"^^xsd:decimal) math:sum "0.34316666666666673"^^xsd:decimal .
#   (0.5 "0.34316666666666673"^^xsd:decimal) math:product "0.17158333333333337"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal 2.0) math:exponentiation "0.026298027777777802"^^xsd:decimal .
#   ("0.009416666666666684"^^xsd:decimal 2.0) math:exponentiation "0.00008867361111111145"^^xsd:decimal .
#   ("-0.1715833333333333"^^xsd:decimal 2.0) math:exponentiation "0.02944084027777777"^^xsd:decimal .
#   ("0.026298027777777802"^^xsd:decimal "0.00008867361111111145"^^xsd:decimal) math:sum "0.026386701388888913"^^xsd:decimal .
#   ("0.026386701388888913"^^xsd:decimal "0.02944084027777777"^^xsd:decimal) math:sum "0.05582754166666668"^^xsd:decimal .
#   ("0.05582754166666668"^^xsd:decimal 0.5) math:exponentiation "0.23627852561472165"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.49550000000000005"^^xsd:decimal
#   ?a2 = "0.24552025000000005"^^xsd:decimal
#   ?ab2 = "0.36299781250000007"^^xsd:decimal
#   ?ada = "0.16216666666666674"^^xsd:decimal
#   ?adb = "0.009416666666666684"^^xsd:decimal
#   ?adc = "0.1715833333333333"^^xsd:decimal
#   ?b = "0.34275"^^xsd:decimal
#   ?b2 = "0.1174775625"^^xsd:decimal
#   ?c = "0.16175"^^xsd:decimal
#   ?c2 = "0.0261630625"^^xsd:decimal
#   ?da = "0.16216666666666674"^^xsd:decimal
#   ?da2 = "0.026298027777777802"^^xsd:decimal
#   ?db = "0.009416666666666684"^^xsd:decimal
#   ?db2 = "0.00008867361111111145"^^xsd:decimal
#   ?dc = "-0.1715833333333333"^^xsd:decimal
#   ?dc2 = "0.02944084027777777"^^xsd:decimal
#   ?effN = "2.569631389589202"^^xsd:decimal
#   ?gini = "0.6108391249999999"^^xsd:decimal
#   ?l2 = "0.23627852561472165"^^xsd:decimal
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = "0.17158333333333342"^^xsd:decimal
#   ?s2 = "0.026386701388888913"^^xsd:decimal
#   ?s3 = "0.05582754166666668"^^xsd:decimal
#   ?sAbs = "0.34316666666666673"^^xsd:decimal
#   ?sumSq = "0.3891608750000001"^^xsd:decimal
#   ?tv = "0.17158333333333337"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :effectiveStates "2.569631389589202"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :tvToUniform "0.17158333333333337"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 2.0) math:exponentiation "0.24552025000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 2.0) math:exponentiation "0.1174775625"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 2.0) math:exponentiation "0.0261630625"^^xsd:decimal .
#   ("0.24552025000000005"^^xsd:decimal "0.1174775625"^^xsd:decimal) math:sum "0.36299781250000007"^^xsd:decimal .
#   ("0.36299781250000007"^^xsd:decimal "0.0261630625"^^xsd:decimal) math:sum "0.3891608750000001"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:difference "0.6108391249999999"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:quotient "2.569631389589202"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.16216666666666674"^^xsd:decimal .
#   "0.16216666666666674"^^xsd:decimal math:absoluteValue "0.16216666666666674"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.009416666666666684"^^xsd:decimal .
#   "0.009416666666666684"^^xsd:decimal math:absoluteValue "0.009416666666666684"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1715833333333333"^^xsd:decimal .
#   "-0.1715833333333333"^^xsd:decimal math:absoluteValue "0.1715833333333333"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal "0.009416666666666684"^^xsd:decimal) math:sum "0.17158333333333342"^^xsd:decimal .
#   ("0.17158333333333342"^^xsd:decimal "0.1715833333333333"^^xsd:decimal) math:sum "0.34316666666666673"^^xsd:decimal .
#   (0.5 "0.34316666666666673"^^xsd:decimal) math:product "0.17158333333333337"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal 2.0) math:exponentiation "0.026298027777777802"^^xsd:decimal .
#   ("0.009416666666666684"^^xsd:decimal 2.0) math:exponentiation "0.00008867361111111145"^^xsd:decimal .
#   ("-0.1715833333333333"^^xsd:decimal 2.0) math:exponentiation "0.02944084027777777"^^xsd:decimal .
#   ("0.026298027777777802"^^xsd:decimal "0.00008867361111111145"^^xsd:decimal) math:sum "0.026386701388888913"^^xsd:decimal .
#   ("0.026386701388888913"^^xsd:decimal "0.02944084027777777"^^xsd:decimal) math:sum "0.05582754166666668"^^xsd:decimal .
#   ("0.05582754166666668"^^xsd:decimal 0.5) math:exponentiation "0.23627852561472165"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.49550000000000005"^^xsd:decimal
#   ?a2 = "0.24552025000000005"^^xsd:decimal
#   ?ab2 = "0.36299781250000007"^^xsd:decimal
#   ?ada = "0.16216666666666674"^^xsd:decimal
#   ?adb = "0.009416666666666684"^^xsd:decimal
#   ?adc = "0.1715833333333333"^^xsd:decimal
#   ?b = "0.34275"^^xsd:decimal
#   ?b2 = "0.1174775625"^^xsd:decimal
#   ?c = "0.16175"^^xsd:decimal
#   ?c2 = "0.0261630625"^^xsd:decimal
#   ?da = "0.16216666666666674"^^xsd:decimal
#   ?da2 = "0.026298027777777802"^^xsd:decimal
#   ?db = "0.009416666666666684"^^xsd:decimal
#   ?db2 = "0.00008867361111111145"^^xsd:decimal
#   ?dc = "-0.1715833333333333"^^xsd:decimal
#   ?dc2 = "0.02944084027777777"^^xsd:decimal
#   ?effN = "2.569631389589202"^^xsd:decimal
#   ?gini = "0.6108391249999999"^^xsd:decimal
#   ?l2 = "0.23627852561472165"^^xsd:decimal
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = "0.17158333333333342"^^xsd:decimal
#   ?s2 = "0.026386701388888913"^^xsd:decimal
#   ?s3 = "0.05582754166666668"^^xsd:decimal
#   ?sAbs = "0.34316666666666673"^^xsd:decimal
#   ?sumSq = "0.3891608750000001"^^xsd:decimal
#   ?tv = "0.17158333333333337"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :tvToUniform "0.17158333333333337"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :l2ToUniform "0.23627852561472165"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA "0.49550000000000005"^^xsd:decimal .
#   _:sk_1 :pB "0.34275"^^xsd:decimal .
#   _:sk_1 :pC "0.16175"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal 2.0) math:exponentiation "0.24552025000000005"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal 2.0) math:exponentiation "0.1174775625"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal 2.0) math:exponentiation "0.0261630625"^^xsd:decimal .
#   ("0.24552025000000005"^^xsd:decimal "0.1174775625"^^xsd:decimal) math:sum "0.36299781250000007"^^xsd:decimal .
#   ("0.36299781250000007"^^xsd:decimal "0.0261630625"^^xsd:decimal) math:sum "0.3891608750000001"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:difference "0.6108391249999999"^^xsd:decimal .
#   (1.0 "0.3891608750000001"^^xsd:decimal) math:quotient "2.569631389589202"^^xsd:decimal .
#   ("0.49550000000000005"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.16216666666666674"^^xsd:decimal .
#   "0.16216666666666674"^^xsd:decimal math:absoluteValue "0.16216666666666674"^^xsd:decimal .
#   ("0.34275"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.009416666666666684"^^xsd:decimal .
#   "0.009416666666666684"^^xsd:decimal math:absoluteValue "0.009416666666666684"^^xsd:decimal .
#   ("0.16175"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1715833333333333"^^xsd:decimal .
#   "-0.1715833333333333"^^xsd:decimal math:absoluteValue "0.1715833333333333"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal "0.009416666666666684"^^xsd:decimal) math:sum "0.17158333333333342"^^xsd:decimal .
#   ("0.17158333333333342"^^xsd:decimal "0.1715833333333333"^^xsd:decimal) math:sum "0.34316666666666673"^^xsd:decimal .
#   (0.5 "0.34316666666666673"^^xsd:decimal) math:product "0.17158333333333337"^^xsd:decimal .
#   ("0.16216666666666674"^^xsd:decimal 2.0) math:exponentiation "0.026298027777777802"^^xsd:decimal .
#   ("0.009416666666666684"^^xsd:decimal 2.0) math:exponentiation "0.00008867361111111145"^^xsd:decimal .
#   ("-0.1715833333333333"^^xsd:decimal 2.0) math:exponentiation "0.02944084027777777"^^xsd:decimal .
#   ("0.026298027777777802"^^xsd:decimal "0.00008867361111111145"^^xsd:decimal) math:sum "0.026386701388888913"^^xsd:decimal .
#   ("0.026386701388888913"^^xsd:decimal "0.02944084027777777"^^xsd:decimal) math:sum "0.05582754166666668"^^xsd:decimal .
#   ("0.05582754166666668"^^xsd:decimal 0.5) math:exponentiation "0.23627852561472165"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.49550000000000005"^^xsd:decimal
#   ?a2 = "0.24552025000000005"^^xsd:decimal
#   ?ab2 = "0.36299781250000007"^^xsd:decimal
#   ?ada = "0.16216666666666674"^^xsd:decimal
#   ?adb = "0.009416666666666684"^^xsd:decimal
#   ?adc = "0.1715833333333333"^^xsd:decimal
#   ?b = "0.34275"^^xsd:decimal
#   ?b2 = "0.1174775625"^^xsd:decimal
#   ?c = "0.16175"^^xsd:decimal
#   ?c2 = "0.0261630625"^^xsd:decimal
#   ?da = "0.16216666666666674"^^xsd:decimal
#   ?da2 = "0.026298027777777802"^^xsd:decimal
#   ?db = "0.009416666666666684"^^xsd:decimal
#   ?db2 = "0.00008867361111111145"^^xsd:decimal
#   ?dc = "-0.1715833333333333"^^xsd:decimal
#   ?dc2 = "0.02944084027777777"^^xsd:decimal
#   ?effN = "2.569631389589202"^^xsd:decimal
#   ?gini = "0.6108391249999999"^^xsd:decimal
#   ?l2 = "0.23627852561472165"^^xsd:decimal
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = "0.17158333333333342"^^xsd:decimal
#   ?s2 = "0.026386701388888913"^^xsd:decimal
#   ?s3 = "0.05582754166666668"^^xsd:decimal
#   ?sAbs = "0.34316666666666673"^^xsd:decimal
#   ?sumSq = "0.3891608750000001"^^xsd:decimal
#   ?tv = "0.17158333333333337"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :l2ToUniform "0.23627852561472165"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :sumSq "0.41145000000000004"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 2.0) math:exponentiation "0.286225"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 2.0) math:exponentiation "0.10562500000000001"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 2.0) math:exponentiation "0.019600000000000003"^^xsd:decimal .
#   ("0.286225"^^xsd:decimal "0.10562500000000001"^^xsd:decimal) math:sum "0.39185000000000003"^^xsd:decimal .
#   ("0.39185000000000003"^^xsd:decimal "0.019600000000000003"^^xsd:decimal) math:sum "0.41145000000000004"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:difference "0.5885499999999999"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:quotient "2.4304289707133306"^^xsd:decimal .
#   ("0.535"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.20166666666666672"^^xsd:decimal .
#   "0.20166666666666672"^^xsd:decimal math:absoluteValue "0.20166666666666672"^^xsd:decimal .
#   ("0.325"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.008333333333333304"^^xsd:decimal .
#   "-0.008333333333333304"^^xsd:decimal math:absoluteValue "0.008333333333333304"^^xsd:decimal .
#   ("0.14"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1933333333333333"^^xsd:decimal .
#   "-0.1933333333333333"^^xsd:decimal math:absoluteValue "0.1933333333333333"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal "0.008333333333333304"^^xsd:decimal) math:sum "0.21000000000000002"^^xsd:decimal .
#   ("0.21000000000000002"^^xsd:decimal "0.1933333333333333"^^xsd:decimal) math:sum "0.4033333333333333"^^xsd:decimal .
#   (0.5 "0.4033333333333333"^^xsd:decimal) math:product "0.20166666666666666"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal 2.0) math:exponentiation "0.040669444444444466"^^xsd:decimal .
#   ("-0.008333333333333304"^^xsd:decimal 2.0) math:exponentiation "0.00006944444444444396"^^xsd:decimal .
#   ("-0.1933333333333333"^^xsd:decimal 2.0) math:exponentiation "0.03737777777777777"^^xsd:decimal .
#   ("0.040669444444444466"^^xsd:decimal "0.00006944444444444396"^^xsd:decimal) math:sum "0.04073888888888891"^^xsd:decimal .
#   ("0.04073888888888891"^^xsd:decimal "0.03737777777777777"^^xsd:decimal) math:sum "0.07811666666666667"^^xsd:decimal .
#   ("0.07811666666666667"^^xsd:decimal 0.5) math:exponentiation "0.2794935896700793"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.535"^^xsd:decimal
#   ?a2 = "0.286225"^^xsd:decimal
#   ?ab2 = "0.39185000000000003"^^xsd:decimal
#   ?ada = "0.20166666666666672"^^xsd:decimal
#   ?adb = "0.008333333333333304"^^xsd:decimal
#   ?adc = "0.1933333333333333"^^xsd:decimal
#   ?b = "0.325"^^xsd:decimal
#   ?b2 = "0.10562500000000001"^^xsd:decimal
#   ?c = "0.14"^^xsd:decimal
#   ?c2 = "0.019600000000000003"^^xsd:decimal
#   ?da = "0.20166666666666672"^^xsd:decimal
#   ?da2 = "0.040669444444444466"^^xsd:decimal
#   ?db = "-0.008333333333333304"^^xsd:decimal
#   ?db2 = "0.00006944444444444396"^^xsd:decimal
#   ?dc = "-0.1933333333333333"^^xsd:decimal
#   ?dc2 = "0.03737777777777777"^^xsd:decimal
#   ?effN = "2.4304289707133306"^^xsd:decimal
#   ?gini = "0.5885499999999999"^^xsd:decimal
#   ?l2 = "0.2794935896700793"^^xsd:decimal
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = "0.21000000000000002"^^xsd:decimal
#   ?s2 = "0.04073888888888891"^^xsd:decimal
#   ?s3 = "0.07811666666666667"^^xsd:decimal
#   ?sAbs = "0.4033333333333333"^^xsd:decimal
#   ?sumSq = "0.41145000000000004"^^xsd:decimal
#   ?tv = "0.20166666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :sumSq "0.41145000000000004"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :gini "0.5885499999999999"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 2.0) math:exponentiation "0.286225"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 2.0) math:exponentiation "0.10562500000000001"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 2.0) math:exponentiation "0.019600000000000003"^^xsd:decimal .
#   ("0.286225"^^xsd:decimal "0.10562500000000001"^^xsd:decimal) math:sum "0.39185000000000003"^^xsd:decimal .
#   ("0.39185000000000003"^^xsd:decimal "0.019600000000000003"^^xsd:decimal) math:sum "0.41145000000000004"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:difference "0.5885499999999999"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:quotient "2.4304289707133306"^^xsd:decimal .
#   ("0.535"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.20166666666666672"^^xsd:decimal .
#   "0.20166666666666672"^^xsd:decimal math:absoluteValue "0.20166666666666672"^^xsd:decimal .
#   ("0.325"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.008333333333333304"^^xsd:decimal .
#   "-0.008333333333333304"^^xsd:decimal math:absoluteValue "0.008333333333333304"^^xsd:decimal .
#   ("0.14"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1933333333333333"^^xsd:decimal .
#   "-0.1933333333333333"^^xsd:decimal math:absoluteValue "0.1933333333333333"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal "0.008333333333333304"^^xsd:decimal) math:sum "0.21000000000000002"^^xsd:decimal .
#   ("0.21000000000000002"^^xsd:decimal "0.1933333333333333"^^xsd:decimal) math:sum "0.4033333333333333"^^xsd:decimal .
#   (0.5 "0.4033333333333333"^^xsd:decimal) math:product "0.20166666666666666"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal 2.0) math:exponentiation "0.040669444444444466"^^xsd:decimal .
#   ("-0.008333333333333304"^^xsd:decimal 2.0) math:exponentiation "0.00006944444444444396"^^xsd:decimal .
#   ("-0.1933333333333333"^^xsd:decimal 2.0) math:exponentiation "0.03737777777777777"^^xsd:decimal .
#   ("0.040669444444444466"^^xsd:decimal "0.00006944444444444396"^^xsd:decimal) math:sum "0.04073888888888891"^^xsd:decimal .
#   ("0.04073888888888891"^^xsd:decimal "0.03737777777777777"^^xsd:decimal) math:sum "0.07811666666666667"^^xsd:decimal .
#   ("0.07811666666666667"^^xsd:decimal 0.5) math:exponentiation "0.2794935896700793"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.535"^^xsd:decimal
#   ?a2 = "0.286225"^^xsd:decimal
#   ?ab2 = "0.39185000000000003"^^xsd:decimal
#   ?ada = "0.20166666666666672"^^xsd:decimal
#   ?adb = "0.008333333333333304"^^xsd:decimal
#   ?adc = "0.1933333333333333"^^xsd:decimal
#   ?b = "0.325"^^xsd:decimal
#   ?b2 = "0.10562500000000001"^^xsd:decimal
#   ?c = "0.14"^^xsd:decimal
#   ?c2 = "0.019600000000000003"^^xsd:decimal
#   ?da = "0.20166666666666672"^^xsd:decimal
#   ?da2 = "0.040669444444444466"^^xsd:decimal
#   ?db = "-0.008333333333333304"^^xsd:decimal
#   ?db2 = "0.00006944444444444396"^^xsd:decimal
#   ?dc = "-0.1933333333333333"^^xsd:decimal
#   ?dc2 = "0.03737777777777777"^^xsd:decimal
#   ?effN = "2.4304289707133306"^^xsd:decimal
#   ?gini = "0.5885499999999999"^^xsd:decimal
#   ?l2 = "0.2794935896700793"^^xsd:decimal
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = "0.21000000000000002"^^xsd:decimal
#   ?s2 = "0.04073888888888891"^^xsd:decimal
#   ?s3 = "0.07811666666666667"^^xsd:decimal
#   ?sAbs = "0.4033333333333333"^^xsd:decimal
#   ?sumSq = "0.41145000000000004"^^xsd:decimal
#   ?tv = "0.20166666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :gini "0.5885499999999999"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :effectiveStates "2.4304289707133306"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 2.0) math:exponentiation "0.286225"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 2.0) math:exponentiation "0.10562500000000001"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 2.0) math:exponentiation "0.019600000000000003"^^xsd:decimal .
#   ("0.286225"^^xsd:decimal "0.10562500000000001"^^xsd:decimal) math:sum "0.39185000000000003"^^xsd:decimal .
#   ("0.39185000000000003"^^xsd:decimal "0.019600000000000003"^^xsd:decimal) math:sum "0.41145000000000004"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:difference "0.5885499999999999"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:quotient "2.4304289707133306"^^xsd:decimal .
#   ("0.535"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.20166666666666672"^^xsd:decimal .
#   "0.20166666666666672"^^xsd:decimal math:absoluteValue "0.20166666666666672"^^xsd:decimal .
#   ("0.325"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.008333333333333304"^^xsd:decimal .
#   "-0.008333333333333304"^^xsd:decimal math:absoluteValue "0.008333333333333304"^^xsd:decimal .
#   ("0.14"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1933333333333333"^^xsd:decimal .
#   "-0.1933333333333333"^^xsd:decimal math:absoluteValue "0.1933333333333333"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal "0.008333333333333304"^^xsd:decimal) math:sum "0.21000000000000002"^^xsd:decimal .
#   ("0.21000000000000002"^^xsd:decimal "0.1933333333333333"^^xsd:decimal) math:sum "0.4033333333333333"^^xsd:decimal .
#   (0.5 "0.4033333333333333"^^xsd:decimal) math:product "0.20166666666666666"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal 2.0) math:exponentiation "0.040669444444444466"^^xsd:decimal .
#   ("-0.008333333333333304"^^xsd:decimal 2.0) math:exponentiation "0.00006944444444444396"^^xsd:decimal .
#   ("-0.1933333333333333"^^xsd:decimal 2.0) math:exponentiation "0.03737777777777777"^^xsd:decimal .
#   ("0.040669444444444466"^^xsd:decimal "0.00006944444444444396"^^xsd:decimal) math:sum "0.04073888888888891"^^xsd:decimal .
#   ("0.04073888888888891"^^xsd:decimal "0.03737777777777777"^^xsd:decimal) math:sum "0.07811666666666667"^^xsd:decimal .
#   ("0.07811666666666667"^^xsd:decimal 0.5) math:exponentiation "0.2794935896700793"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.535"^^xsd:decimal
#   ?a2 = "0.286225"^^xsd:decimal
#   ?ab2 = "0.39185000000000003"^^xsd:decimal
#   ?ada = "0.20166666666666672"^^xsd:decimal
#   ?adb = "0.008333333333333304"^^xsd:decimal
#   ?adc = "0.1933333333333333"^^xsd:decimal
#   ?b = "0.325"^^xsd:decimal
#   ?b2 = "0.10562500000000001"^^xsd:decimal
#   ?c = "0.14"^^xsd:decimal
#   ?c2 = "0.019600000000000003"^^xsd:decimal
#   ?da = "0.20166666666666672"^^xsd:decimal
#   ?da2 = "0.040669444444444466"^^xsd:decimal
#   ?db = "-0.008333333333333304"^^xsd:decimal
#   ?db2 = "0.00006944444444444396"^^xsd:decimal
#   ?dc = "-0.1933333333333333"^^xsd:decimal
#   ?dc2 = "0.03737777777777777"^^xsd:decimal
#   ?effN = "2.4304289707133306"^^xsd:decimal
#   ?gini = "0.5885499999999999"^^xsd:decimal
#   ?l2 = "0.2794935896700793"^^xsd:decimal
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = "0.21000000000000002"^^xsd:decimal
#   ?s2 = "0.04073888888888891"^^xsd:decimal
#   ?s3 = "0.07811666666666667"^^xsd:decimal
#   ?sAbs = "0.4033333333333333"^^xsd:decimal
#   ?sumSq = "0.41145000000000004"^^xsd:decimal
#   ?tv = "0.20166666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :effectiveStates "2.4304289707133306"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :tvToUniform "0.20166666666666666"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 2.0) math:exponentiation "0.286225"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 2.0) math:exponentiation "0.10562500000000001"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 2.0) math:exponentiation "0.019600000000000003"^^xsd:decimal .
#   ("0.286225"^^xsd:decimal "0.10562500000000001"^^xsd:decimal) math:sum "0.39185000000000003"^^xsd:decimal .
#   ("0.39185000000000003"^^xsd:decimal "0.019600000000000003"^^xsd:decimal) math:sum "0.41145000000000004"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:difference "0.5885499999999999"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:quotient "2.4304289707133306"^^xsd:decimal .
#   ("0.535"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.20166666666666672"^^xsd:decimal .
#   "0.20166666666666672"^^xsd:decimal math:absoluteValue "0.20166666666666672"^^xsd:decimal .
#   ("0.325"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.008333333333333304"^^xsd:decimal .
#   "-0.008333333333333304"^^xsd:decimal math:absoluteValue "0.008333333333333304"^^xsd:decimal .
#   ("0.14"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1933333333333333"^^xsd:decimal .
#   "-0.1933333333333333"^^xsd:decimal math:absoluteValue "0.1933333333333333"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal "0.008333333333333304"^^xsd:decimal) math:sum "0.21000000000000002"^^xsd:decimal .
#   ("0.21000000000000002"^^xsd:decimal "0.1933333333333333"^^xsd:decimal) math:sum "0.4033333333333333"^^xsd:decimal .
#   (0.5 "0.4033333333333333"^^xsd:decimal) math:product "0.20166666666666666"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal 2.0) math:exponentiation "0.040669444444444466"^^xsd:decimal .
#   ("-0.008333333333333304"^^xsd:decimal 2.0) math:exponentiation "0.00006944444444444396"^^xsd:decimal .
#   ("-0.1933333333333333"^^xsd:decimal 2.0) math:exponentiation "0.03737777777777777"^^xsd:decimal .
#   ("0.040669444444444466"^^xsd:decimal "0.00006944444444444396"^^xsd:decimal) math:sum "0.04073888888888891"^^xsd:decimal .
#   ("0.04073888888888891"^^xsd:decimal "0.03737777777777777"^^xsd:decimal) math:sum "0.07811666666666667"^^xsd:decimal .
#   ("0.07811666666666667"^^xsd:decimal 0.5) math:exponentiation "0.2794935896700793"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.535"^^xsd:decimal
#   ?a2 = "0.286225"^^xsd:decimal
#   ?ab2 = "0.39185000000000003"^^xsd:decimal
#   ?ada = "0.20166666666666672"^^xsd:decimal
#   ?adb = "0.008333333333333304"^^xsd:decimal
#   ?adc = "0.1933333333333333"^^xsd:decimal
#   ?b = "0.325"^^xsd:decimal
#   ?b2 = "0.10562500000000001"^^xsd:decimal
#   ?c = "0.14"^^xsd:decimal
#   ?c2 = "0.019600000000000003"^^xsd:decimal
#   ?da = "0.20166666666666672"^^xsd:decimal
#   ?da2 = "0.040669444444444466"^^xsd:decimal
#   ?db = "-0.008333333333333304"^^xsd:decimal
#   ?db2 = "0.00006944444444444396"^^xsd:decimal
#   ?dc = "-0.1933333333333333"^^xsd:decimal
#   ?dc2 = "0.03737777777777777"^^xsd:decimal
#   ?effN = "2.4304289707133306"^^xsd:decimal
#   ?gini = "0.5885499999999999"^^xsd:decimal
#   ?l2 = "0.2794935896700793"^^xsd:decimal
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = "0.21000000000000002"^^xsd:decimal
#   ?s2 = "0.04073888888888891"^^xsd:decimal
#   ?s3 = "0.07811666666666667"^^xsd:decimal
#   ?sAbs = "0.4033333333333333"^^xsd:decimal
#   ?sumSq = "0.41145000000000004"^^xsd:decimal
#   ?tv = "0.20166666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :tvToUniform "0.20166666666666666"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :l2ToUniform "0.2794935896700793"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA "0.535"^^xsd:decimal .
#   _:sk_0 :pB "0.325"^^xsd:decimal .
#   _:sk_0 :pC "0.14"^^xsd:decimal .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   ("0.535"^^xsd:decimal 2.0) math:exponentiation "0.286225"^^xsd:decimal .
#   ("0.325"^^xsd:decimal 2.0) math:exponentiation "0.10562500000000001"^^xsd:decimal .
#   ("0.14"^^xsd:decimal 2.0) math:exponentiation "0.019600000000000003"^^xsd:decimal .
#   ("0.286225"^^xsd:decimal "0.10562500000000001"^^xsd:decimal) math:sum "0.39185000000000003"^^xsd:decimal .
#   ("0.39185000000000003"^^xsd:decimal "0.019600000000000003"^^xsd:decimal) math:sum "0.41145000000000004"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:difference "0.5885499999999999"^^xsd:decimal .
#   (1.0 "0.41145000000000004"^^xsd:decimal) math:quotient "2.4304289707133306"^^xsd:decimal .
#   ("0.535"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "0.20166666666666672"^^xsd:decimal .
#   "0.20166666666666672"^^xsd:decimal math:absoluteValue "0.20166666666666672"^^xsd:decimal .
#   ("0.325"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.008333333333333304"^^xsd:decimal .
#   "-0.008333333333333304"^^xsd:decimal math:absoluteValue "0.008333333333333304"^^xsd:decimal .
#   ("0.14"^^xsd:decimal "0.3333333333333333"^^xsd:decimal) math:difference "-0.1933333333333333"^^xsd:decimal .
#   "-0.1933333333333333"^^xsd:decimal math:absoluteValue "0.1933333333333333"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal "0.008333333333333304"^^xsd:decimal) math:sum "0.21000000000000002"^^xsd:decimal .
#   ("0.21000000000000002"^^xsd:decimal "0.1933333333333333"^^xsd:decimal) math:sum "0.4033333333333333"^^xsd:decimal .
#   (0.5 "0.4033333333333333"^^xsd:decimal) math:product "0.20166666666666666"^^xsd:decimal .
#   ("0.20166666666666672"^^xsd:decimal 2.0) math:exponentiation "0.040669444444444466"^^xsd:decimal .
#   ("-0.008333333333333304"^^xsd:decimal 2.0) math:exponentiation "0.00006944444444444396"^^xsd:decimal .
#   ("-0.1933333333333333"^^xsd:decimal 2.0) math:exponentiation "0.03737777777777777"^^xsd:decimal .
#   ("0.040669444444444466"^^xsd:decimal "0.00006944444444444396"^^xsd:decimal) math:sum "0.04073888888888891"^^xsd:decimal .
#   ("0.04073888888888891"^^xsd:decimal "0.03737777777777777"^^xsd:decimal) math:sum "0.07811666666666667"^^xsd:decimal .
#   ("0.07811666666666667"^^xsd:decimal 0.5) math:exponentiation "0.2794935896700793"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = "0.535"^^xsd:decimal
#   ?a2 = "0.286225"^^xsd:decimal
#   ?ab2 = "0.39185000000000003"^^xsd:decimal
#   ?ada = "0.20166666666666672"^^xsd:decimal
#   ?adb = "0.008333333333333304"^^xsd:decimal
#   ?adc = "0.1933333333333333"^^xsd:decimal
#   ?b = "0.325"^^xsd:decimal
#   ?b2 = "0.10562500000000001"^^xsd:decimal
#   ?c = "0.14"^^xsd:decimal
#   ?c2 = "0.019600000000000003"^^xsd:decimal
#   ?da = "0.20166666666666672"^^xsd:decimal
#   ?da2 = "0.040669444444444466"^^xsd:decimal
#   ?db = "-0.008333333333333304"^^xsd:decimal
#   ?db2 = "0.00006944444444444396"^^xsd:decimal
#   ?dc = "-0.1933333333333333"^^xsd:decimal
#   ?dc2 = "0.03737777777777777"^^xsd:decimal
#   ?effN = "2.4304289707133306"^^xsd:decimal
#   ?gini = "0.5885499999999999"^^xsd:decimal
#   ?l2 = "0.2794935896700793"^^xsd:decimal
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = "0.21000000000000002"^^xsd:decimal
#   ?s2 = "0.04073888888888891"^^xsd:decimal
#   ?s3 = "0.07811666666666667"^^xsd:decimal
#   ?sAbs = "0.4033333333333333"^^xsd:decimal
#   ?sumSq = "0.41145000000000004"^^xsd:decimal
#   ?tv = "0.20166666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :l2ToUniform "0.2794935896700793"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :sumSq "0.45999999999999996"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   (0.60 2.0) math:exponentiation "0.36"^^xsd:decimal .
#   (0.30 2.0) math:exponentiation "0.09"^^xsd:decimal .
#   (0.10 2.0) math:exponentiation "0.010000000000000002"^^xsd:decimal .
#   ("0.36"^^xsd:decimal "0.09"^^xsd:decimal) math:sum "0.44999999999999996"^^xsd:decimal .
#   ("0.44999999999999996"^^xsd:decimal "0.010000000000000002"^^xsd:decimal) math:sum "0.45999999999999996"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:difference "0.54"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:quotient "2.173913043478261"^^xsd:decimal .
#   (0.60 "0.3333333333333333"^^xsd:decimal) math:difference "0.26666666666666666"^^xsd:decimal .
#   "0.26666666666666666"^^xsd:decimal math:absoluteValue "0.26666666666666666"^^xsd:decimal .
#   (0.30 "0.3333333333333333"^^xsd:decimal) math:difference "-0.033333333333333326"^^xsd:decimal .
#   "-0.033333333333333326"^^xsd:decimal math:absoluteValue "0.033333333333333326"^^xsd:decimal .
#   (0.10 "0.3333333333333333"^^xsd:decimal) math:difference "-0.2333333333333333"^^xsd:decimal .
#   "-0.2333333333333333"^^xsd:decimal math:absoluteValue "0.2333333333333333"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal "0.033333333333333326"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.2333333333333333"^^xsd:decimal) math:sum "0.5333333333333333"^^xsd:decimal .
#   (0.5 "0.5333333333333333"^^xsd:decimal) math:product "0.26666666666666666"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal 2.0) math:exponentiation "0.07111111111111111"^^xsd:decimal .
#   ("-0.033333333333333326"^^xsd:decimal 2.0) math:exponentiation "0.0011111111111111107"^^xsd:decimal .
#   ("-0.2333333333333333"^^xsd:decimal 2.0) math:exponentiation "0.054444444444444434"^^xsd:decimal .
#   ("0.07111111111111111"^^xsd:decimal "0.0011111111111111107"^^xsd:decimal) math:sum "0.07222222222222222"^^xsd:decimal .
#   ("0.07222222222222222"^^xsd:decimal "0.054444444444444434"^^xsd:decimal) math:sum "0.12666666666666665"^^xsd:decimal .
#   ("0.12666666666666665"^^xsd:decimal 0.5) math:exponentiation "0.3559026084010437"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = "0.36"^^xsd:decimal
#   ?ab2 = "0.44999999999999996"^^xsd:decimal
#   ?ada = "0.26666666666666666"^^xsd:decimal
#   ?adb = "0.033333333333333326"^^xsd:decimal
#   ?adc = "0.2333333333333333"^^xsd:decimal
#   ?b = 0.30
#   ?b2 = "0.09"^^xsd:decimal
#   ?c = 0.10
#   ?c2 = "0.010000000000000002"^^xsd:decimal
#   ?da = "0.26666666666666666"^^xsd:decimal
#   ?da2 = "0.07111111111111111"^^xsd:decimal
#   ?db = "-0.033333333333333326"^^xsd:decimal
#   ?db2 = "0.0011111111111111107"^^xsd:decimal
#   ?dc = "-0.2333333333333333"^^xsd:decimal
#   ?dc2 = "0.054444444444444434"^^xsd:decimal
#   ?effN = "2.173913043478261"^^xsd:decimal
#   ?gini = "0.54"^^xsd:decimal
#   ?l2 = "0.3559026084010437"^^xsd:decimal
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = "0.3"^^xsd:decimal
#   ?s2 = "0.07222222222222222"^^xsd:decimal
#   ?s3 = "0.12666666666666665"^^xsd:decimal
#   ?sAbs = "0.5333333333333333"^^xsd:decimal
#   ?sumSq = "0.45999999999999996"^^xsd:decimal
#   ?tv = "0.26666666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :sumSq "0.45999999999999996"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :gini "0.54"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   (0.60 2.0) math:exponentiation "0.36"^^xsd:decimal .
#   (0.30 2.0) math:exponentiation "0.09"^^xsd:decimal .
#   (0.10 2.0) math:exponentiation "0.010000000000000002"^^xsd:decimal .
#   ("0.36"^^xsd:decimal "0.09"^^xsd:decimal) math:sum "0.44999999999999996"^^xsd:decimal .
#   ("0.44999999999999996"^^xsd:decimal "0.010000000000000002"^^xsd:decimal) math:sum "0.45999999999999996"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:difference "0.54"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:quotient "2.173913043478261"^^xsd:decimal .
#   (0.60 "0.3333333333333333"^^xsd:decimal) math:difference "0.26666666666666666"^^xsd:decimal .
#   "0.26666666666666666"^^xsd:decimal math:absoluteValue "0.26666666666666666"^^xsd:decimal .
#   (0.30 "0.3333333333333333"^^xsd:decimal) math:difference "-0.033333333333333326"^^xsd:decimal .
#   "-0.033333333333333326"^^xsd:decimal math:absoluteValue "0.033333333333333326"^^xsd:decimal .
#   (0.10 "0.3333333333333333"^^xsd:decimal) math:difference "-0.2333333333333333"^^xsd:decimal .
#   "-0.2333333333333333"^^xsd:decimal math:absoluteValue "0.2333333333333333"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal "0.033333333333333326"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.2333333333333333"^^xsd:decimal) math:sum "0.5333333333333333"^^xsd:decimal .
#   (0.5 "0.5333333333333333"^^xsd:decimal) math:product "0.26666666666666666"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal 2.0) math:exponentiation "0.07111111111111111"^^xsd:decimal .
#   ("-0.033333333333333326"^^xsd:decimal 2.0) math:exponentiation "0.0011111111111111107"^^xsd:decimal .
#   ("-0.2333333333333333"^^xsd:decimal 2.0) math:exponentiation "0.054444444444444434"^^xsd:decimal .
#   ("0.07111111111111111"^^xsd:decimal "0.0011111111111111107"^^xsd:decimal) math:sum "0.07222222222222222"^^xsd:decimal .
#   ("0.07222222222222222"^^xsd:decimal "0.054444444444444434"^^xsd:decimal) math:sum "0.12666666666666665"^^xsd:decimal .
#   ("0.12666666666666665"^^xsd:decimal 0.5) math:exponentiation "0.3559026084010437"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = "0.36"^^xsd:decimal
#   ?ab2 = "0.44999999999999996"^^xsd:decimal
#   ?ada = "0.26666666666666666"^^xsd:decimal
#   ?adb = "0.033333333333333326"^^xsd:decimal
#   ?adc = "0.2333333333333333"^^xsd:decimal
#   ?b = 0.30
#   ?b2 = "0.09"^^xsd:decimal
#   ?c = 0.10
#   ?c2 = "0.010000000000000002"^^xsd:decimal
#   ?da = "0.26666666666666666"^^xsd:decimal
#   ?da2 = "0.07111111111111111"^^xsd:decimal
#   ?db = "-0.033333333333333326"^^xsd:decimal
#   ?db2 = "0.0011111111111111107"^^xsd:decimal
#   ?dc = "-0.2333333333333333"^^xsd:decimal
#   ?dc2 = "0.054444444444444434"^^xsd:decimal
#   ?effN = "2.173913043478261"^^xsd:decimal
#   ?gini = "0.54"^^xsd:decimal
#   ?l2 = "0.3559026084010437"^^xsd:decimal
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = "0.3"^^xsd:decimal
#   ?s2 = "0.07222222222222222"^^xsd:decimal
#   ?s3 = "0.12666666666666665"^^xsd:decimal
#   ?sAbs = "0.5333333333333333"^^xsd:decimal
#   ?sumSq = "0.45999999999999996"^^xsd:decimal
#   ?tv = "0.26666666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :gini "0.54"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :effectiveStates "2.173913043478261"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   (0.60 2.0) math:exponentiation "0.36"^^xsd:decimal .
#   (0.30 2.0) math:exponentiation "0.09"^^xsd:decimal .
#   (0.10 2.0) math:exponentiation "0.010000000000000002"^^xsd:decimal .
#   ("0.36"^^xsd:decimal "0.09"^^xsd:decimal) math:sum "0.44999999999999996"^^xsd:decimal .
#   ("0.44999999999999996"^^xsd:decimal "0.010000000000000002"^^xsd:decimal) math:sum "0.45999999999999996"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:difference "0.54"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:quotient "2.173913043478261"^^xsd:decimal .
#   (0.60 "0.3333333333333333"^^xsd:decimal) math:difference "0.26666666666666666"^^xsd:decimal .
#   "0.26666666666666666"^^xsd:decimal math:absoluteValue "0.26666666666666666"^^xsd:decimal .
#   (0.30 "0.3333333333333333"^^xsd:decimal) math:difference "-0.033333333333333326"^^xsd:decimal .
#   "-0.033333333333333326"^^xsd:decimal math:absoluteValue "0.033333333333333326"^^xsd:decimal .
#   (0.10 "0.3333333333333333"^^xsd:decimal) math:difference "-0.2333333333333333"^^xsd:decimal .
#   "-0.2333333333333333"^^xsd:decimal math:absoluteValue "0.2333333333333333"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal "0.033333333333333326"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.2333333333333333"^^xsd:decimal) math:sum "0.5333333333333333"^^xsd:decimal .
#   (0.5 "0.5333333333333333"^^xsd:decimal) math:product "0.26666666666666666"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal 2.0) math:exponentiation "0.07111111111111111"^^xsd:decimal .
#   ("-0.033333333333333326"^^xsd:decimal 2.0) math:exponentiation "0.0011111111111111107"^^xsd:decimal .
#   ("-0.2333333333333333"^^xsd:decimal 2.0) math:exponentiation "0.054444444444444434"^^xsd:decimal .
#   ("0.07111111111111111"^^xsd:decimal "0.0011111111111111107"^^xsd:decimal) math:sum "0.07222222222222222"^^xsd:decimal .
#   ("0.07222222222222222"^^xsd:decimal "0.054444444444444434"^^xsd:decimal) math:sum "0.12666666666666665"^^xsd:decimal .
#   ("0.12666666666666665"^^xsd:decimal 0.5) math:exponentiation "0.3559026084010437"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = "0.36"^^xsd:decimal
#   ?ab2 = "0.44999999999999996"^^xsd:decimal
#   ?ada = "0.26666666666666666"^^xsd:decimal
#   ?adb = "0.033333333333333326"^^xsd:decimal
#   ?adc = "0.2333333333333333"^^xsd:decimal
#   ?b = 0.30
#   ?b2 = "0.09"^^xsd:decimal
#   ?c = 0.10
#   ?c2 = "0.010000000000000002"^^xsd:decimal
#   ?da = "0.26666666666666666"^^xsd:decimal
#   ?da2 = "0.07111111111111111"^^xsd:decimal
#   ?db = "-0.033333333333333326"^^xsd:decimal
#   ?db2 = "0.0011111111111111107"^^xsd:decimal
#   ?dc = "-0.2333333333333333"^^xsd:decimal
#   ?dc2 = "0.054444444444444434"^^xsd:decimal
#   ?effN = "2.173913043478261"^^xsd:decimal
#   ?gini = "0.54"^^xsd:decimal
#   ?l2 = "0.3559026084010437"^^xsd:decimal
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = "0.3"^^xsd:decimal
#   ?s2 = "0.07222222222222222"^^xsd:decimal
#   ?s3 = "0.12666666666666665"^^xsd:decimal
#   ?sAbs = "0.5333333333333333"^^xsd:decimal
#   ?sumSq = "0.45999999999999996"^^xsd:decimal
#   ?tv = "0.26666666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :effectiveStates "2.173913043478261"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :tvToUniform "0.26666666666666666"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   (0.60 2.0) math:exponentiation "0.36"^^xsd:decimal .
#   (0.30 2.0) math:exponentiation "0.09"^^xsd:decimal .
#   (0.10 2.0) math:exponentiation "0.010000000000000002"^^xsd:decimal .
#   ("0.36"^^xsd:decimal "0.09"^^xsd:decimal) math:sum "0.44999999999999996"^^xsd:decimal .
#   ("0.44999999999999996"^^xsd:decimal "0.010000000000000002"^^xsd:decimal) math:sum "0.45999999999999996"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:difference "0.54"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:quotient "2.173913043478261"^^xsd:decimal .
#   (0.60 "0.3333333333333333"^^xsd:decimal) math:difference "0.26666666666666666"^^xsd:decimal .
#   "0.26666666666666666"^^xsd:decimal math:absoluteValue "0.26666666666666666"^^xsd:decimal .
#   (0.30 "0.3333333333333333"^^xsd:decimal) math:difference "-0.033333333333333326"^^xsd:decimal .
#   "-0.033333333333333326"^^xsd:decimal math:absoluteValue "0.033333333333333326"^^xsd:decimal .
#   (0.10 "0.3333333333333333"^^xsd:decimal) math:difference "-0.2333333333333333"^^xsd:decimal .
#   "-0.2333333333333333"^^xsd:decimal math:absoluteValue "0.2333333333333333"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal "0.033333333333333326"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.2333333333333333"^^xsd:decimal) math:sum "0.5333333333333333"^^xsd:decimal .
#   (0.5 "0.5333333333333333"^^xsd:decimal) math:product "0.26666666666666666"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal 2.0) math:exponentiation "0.07111111111111111"^^xsd:decimal .
#   ("-0.033333333333333326"^^xsd:decimal 2.0) math:exponentiation "0.0011111111111111107"^^xsd:decimal .
#   ("-0.2333333333333333"^^xsd:decimal 2.0) math:exponentiation "0.054444444444444434"^^xsd:decimal .
#   ("0.07111111111111111"^^xsd:decimal "0.0011111111111111107"^^xsd:decimal) math:sum "0.07222222222222222"^^xsd:decimal .
#   ("0.07222222222222222"^^xsd:decimal "0.054444444444444434"^^xsd:decimal) math:sum "0.12666666666666665"^^xsd:decimal .
#   ("0.12666666666666665"^^xsd:decimal 0.5) math:exponentiation "0.3559026084010437"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = "0.36"^^xsd:decimal
#   ?ab2 = "0.44999999999999996"^^xsd:decimal
#   ?ada = "0.26666666666666666"^^xsd:decimal
#   ?adb = "0.033333333333333326"^^xsd:decimal
#   ?adc = "0.2333333333333333"^^xsd:decimal
#   ?b = 0.30
#   ?b2 = "0.09"^^xsd:decimal
#   ?c = 0.10
#   ?c2 = "0.010000000000000002"^^xsd:decimal
#   ?da = "0.26666666666666666"^^xsd:decimal
#   ?da2 = "0.07111111111111111"^^xsd:decimal
#   ?db = "-0.033333333333333326"^^xsd:decimal
#   ?db2 = "0.0011111111111111107"^^xsd:decimal
#   ?dc = "-0.2333333333333333"^^xsd:decimal
#   ?dc2 = "0.054444444444444434"^^xsd:decimal
#   ?effN = "2.173913043478261"^^xsd:decimal
#   ?gini = "0.54"^^xsd:decimal
#   ?l2 = "0.3559026084010437"^^xsd:decimal
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = "0.3"^^xsd:decimal
#   ?s2 = "0.07222222222222222"^^xsd:decimal
#   ?s3 = "0.12666666666666665"^^xsd:decimal
#   ?sAbs = "0.5333333333333333"^^xsd:decimal
#   ?sumSq = "0.45999999999999996"^^xsd:decimal
#   ?tv = "0.26666666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :tvToUniform "0.26666666666666666"^^xsd:decimal .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :l2ToUniform "0.3559026084010437"^^xsd:decimal .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient "0.3333333333333333"^^xsd:decimal .
#   (0.60 2.0) math:exponentiation "0.36"^^xsd:decimal .
#   (0.30 2.0) math:exponentiation "0.09"^^xsd:decimal .
#   (0.10 2.0) math:exponentiation "0.010000000000000002"^^xsd:decimal .
#   ("0.36"^^xsd:decimal "0.09"^^xsd:decimal) math:sum "0.44999999999999996"^^xsd:decimal .
#   ("0.44999999999999996"^^xsd:decimal "0.010000000000000002"^^xsd:decimal) math:sum "0.45999999999999996"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:difference "0.54"^^xsd:decimal .
#   (1.0 "0.45999999999999996"^^xsd:decimal) math:quotient "2.173913043478261"^^xsd:decimal .
#   (0.60 "0.3333333333333333"^^xsd:decimal) math:difference "0.26666666666666666"^^xsd:decimal .
#   "0.26666666666666666"^^xsd:decimal math:absoluteValue "0.26666666666666666"^^xsd:decimal .
#   (0.30 "0.3333333333333333"^^xsd:decimal) math:difference "-0.033333333333333326"^^xsd:decimal .
#   "-0.033333333333333326"^^xsd:decimal math:absoluteValue "0.033333333333333326"^^xsd:decimal .
#   (0.10 "0.3333333333333333"^^xsd:decimal) math:difference "-0.2333333333333333"^^xsd:decimal .
#   "-0.2333333333333333"^^xsd:decimal math:absoluteValue "0.2333333333333333"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal "0.033333333333333326"^^xsd:decimal) math:sum "0.3"^^xsd:decimal .
#   ("0.3"^^xsd:decimal "0.2333333333333333"^^xsd:decimal) math:sum "0.5333333333333333"^^xsd:decimal .
#   (0.5 "0.5333333333333333"^^xsd:decimal) math:product "0.26666666666666666"^^xsd:decimal .
#   ("0.26666666666666666"^^xsd:decimal 2.0) math:exponentiation "0.07111111111111111"^^xsd:decimal .
#   ("-0.033333333333333326"^^xsd:decimal 2.0) math:exponentiation "0.0011111111111111107"^^xsd:decimal .
#   ("-0.2333333333333333"^^xsd:decimal 2.0) math:exponentiation "0.054444444444444434"^^xsd:decimal .
#   ("0.07111111111111111"^^xsd:decimal "0.0011111111111111107"^^xsd:decimal) math:sum "0.07222222222222222"^^xsd:decimal .
#   ("0.07222222222222222"^^xsd:decimal "0.054444444444444434"^^xsd:decimal) math:sum "0.12666666666666665"^^xsd:decimal .
#   ("0.12666666666666665"^^xsd:decimal 0.5) math:exponentiation "0.3559026084010437"^^xsd:decimal .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = "0.36"^^xsd:decimal
#   ?ab2 = "0.44999999999999996"^^xsd:decimal
#   ?ada = "0.26666666666666666"^^xsd:decimal
#   ?adb = "0.033333333333333326"^^xsd:decimal
#   ?adc = "0.2333333333333333"^^xsd:decimal
#   ?b = 0.30
#   ?b2 = "0.09"^^xsd:decimal
#   ?c = 0.10
#   ?c2 = "0.010000000000000002"^^xsd:decimal
#   ?da = "0.26666666666666666"^^xsd:decimal
#   ?da2 = "0.07111111111111111"^^xsd:decimal
#   ?db = "-0.033333333333333326"^^xsd:decimal
#   ?db2 = "0.0011111111111111107"^^xsd:decimal
#   ?dc = "-0.2333333333333333"^^xsd:decimal
#   ?dc2 = "0.054444444444444434"^^xsd:decimal
#   ?effN = "2.173913043478261"^^xsd:decimal
#   ?gini = "0.54"^^xsd:decimal
#   ?l2 = "0.3559026084010437"^^xsd:decimal
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = "0.3"^^xsd:decimal
#   ?s2 = "0.07222222222222222"^^xsd:decimal
#   ?s3 = "0.12666666666666665"^^xsd:decimal
#   ?sAbs = "0.5333333333333333"^^xsd:decimal
#   ?sumSq = "0.45999999999999996"^^xsd:decimal
#   ?tv = "0.26666666666666666"^^xsd:decimal
#   ?u = "0.3333333333333333"^^xsd:decimal
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :l2ToUniform "0.3559026084010437"^^xsd:decimal .

