@prefix : <http://example.org/topaz-markov#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :rowOk _:b3 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b3 .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.25 0.25) math:sum 0.5 .
#   (0.5 0.50) math:sum 1 .
#   1 math:equalTo 1.0 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?r .
#     ?r :pA ?a .
#     ?r :pB ?b .
#     ?r :pC ?c .
#     (?a ?b) math:sum ?ab .
#     (?ab ?c) math:sum ?sum .
#     ?sum math:equalTo 1.0 .
#   } => {
#     :MC1 :rowOk ?r .
#   } .
# with substitution (on rule variables):
#   ?a = 0.25
#   ?ab = 0.5
#   ?b = 0.25
#   ?c = 0.50
#   ?r = _:b3
#   ?sum = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :rowOk _:b3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :rowOk _:b2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b2 .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   (0.10 0.70) math:sum 0.7999999999999999 .
#   (0.7999999999999999 0.20) math:sum 1 .
#   1 math:equalTo 1.0 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?r .
#     ?r :pA ?a .
#     ?r :pB ?b .
#     ?r :pC ?c .
#     (?a ?b) math:sum ?ab .
#     (?ab ?c) math:sum ?sum .
#     ?sum math:equalTo 1.0 .
#   } => {
#     :MC1 :rowOk ?r .
#   } .
# with substitution (on rule variables):
#   ?a = 0.10
#   ?ab = 0.7999999999999999
#   ?b = 0.70
#   ?c = 0.20
#   ?r = _:b2
#   ?sum = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :rowOk _:b2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :rowOk _:b1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   (0.80 0.15) math:sum 0.9500000000000001 .
#   (0.9500000000000001 0.05) math:sum 1 .
#   1 math:equalTo 1.0 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?r .
#     ?r :pA ?a .
#     ?r :pB ?b .
#     ?r :pC ?c .
#     (?a ?b) math:sum ?ab .
#     (?ab ?c) math:sum ?sum .
#     ?sum math:equalTo 1.0 .
#   } => {
#     :MC1 :rowOk ?r .
#   } .
# with substitution (on rule variables):
#   ?a = 0.80
#   ?ab = 0.9500000000000001
#   ?b = 0.15
#   ?c = 0.05
#   ?r = _:b1
#   ?sum = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :rowOk _:b1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :pA 0.535 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product 0.48 .
#   (0.30 0.10) math:product 0.03 .
#   (0.10 0.25) math:product 0.025 .
#   (0.48 0.03) math:sum 0.51 .
#   (0.51 0.025) math:sum 0.535 .
#   (0.60 0.15) math:product 0.09 .
#   (0.30 0.70) math:product 0.21 .
#   (0.10 0.25) math:product 0.025 .
#   (0.09 0.21) math:sum 0.3 .
#   (0.3 0.025) math:sum 0.325 .
#   (0.60 0.05) math:product 0.03 .
#   (0.30 0.20) math:product 0.06 .
#   (0.10 0.50) math:product 0.05 .
#   (0.03 0.06) math:sum 0.09 .
#   (0.09 0.05) math:sum 0.14 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = 0.535
#   ?pi1B = 0.325
#   ?pi1C = 0.14
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.51
#   ?s2 = 0.3
#   ?s3 = 0.09
#   ?tAA = 0.48
#   ?tAB = 0.09
#   ?tAC = 0.03
#   ?tBA = 0.03
#   ?tBB = 0.21
#   ?tBC = 0.06
#   ?tCA = 0.025
#   ?tCB = 0.025
#   ?tCC = 0.05
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :pA 0.535 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :pB 0.325 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product 0.48 .
#   (0.30 0.10) math:product 0.03 .
#   (0.10 0.25) math:product 0.025 .
#   (0.48 0.03) math:sum 0.51 .
#   (0.51 0.025) math:sum 0.535 .
#   (0.60 0.15) math:product 0.09 .
#   (0.30 0.70) math:product 0.21 .
#   (0.10 0.25) math:product 0.025 .
#   (0.09 0.21) math:sum 0.3 .
#   (0.3 0.025) math:sum 0.325 .
#   (0.60 0.05) math:product 0.03 .
#   (0.30 0.20) math:product 0.06 .
#   (0.10 0.50) math:product 0.05 .
#   (0.03 0.06) math:sum 0.09 .
#   (0.09 0.05) math:sum 0.14 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = 0.535
#   ?pi1B = 0.325
#   ?pi1C = 0.14
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.51
#   ?s2 = 0.3
#   ?s3 = 0.09
#   ?tAA = 0.48
#   ?tAB = 0.09
#   ?tAC = 0.03
#   ?tBA = 0.03
#   ?tBB = 0.21
#   ?tBC = 0.06
#   ?tCA = 0.025
#   ?tCB = 0.025
#   ?tCC = 0.05
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :pB 0.325 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :pC 0.14 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product 0.48 .
#   (0.30 0.10) math:product 0.03 .
#   (0.10 0.25) math:product 0.025 .
#   (0.48 0.03) math:sum 0.51 .
#   (0.51 0.025) math:sum 0.535 .
#   (0.60 0.15) math:product 0.09 .
#   (0.30 0.70) math:product 0.21 .
#   (0.10 0.25) math:product 0.025 .
#   (0.09 0.21) math:sum 0.3 .
#   (0.3 0.025) math:sum 0.325 .
#   (0.60 0.05) math:product 0.03 .
#   (0.30 0.20) math:product 0.06 .
#   (0.10 0.50) math:product 0.05 .
#   (0.03 0.06) math:sum 0.09 .
#   (0.09 0.05) math:sum 0.14 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = 0.535
#   ?pi1B = 0.325
#   ?pi1C = 0.14
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.51
#   ?s2 = 0.3
#   ?s3 = 0.09
#   ?tAA = 0.48
#   ?tAB = 0.09
#   ?tAC = 0.03
#   ?tBA = 0.03
#   ?tBB = 0.21
#   ?tBC = 0.06
#   ?tCA = 0.025
#   ?tCB = 0.025
#   ?tCC = 0.05
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :pC 0.14 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :pi1 _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (0.60 0.80) math:product 0.48 .
#   (0.30 0.10) math:product 0.03 .
#   (0.10 0.25) math:product 0.025 .
#   (0.48 0.03) math:sum 0.51 .
#   (0.51 0.025) math:sum 0.535 .
#   (0.60 0.15) math:product 0.09 .
#   (0.30 0.70) math:product 0.21 .
#   (0.10 0.25) math:product 0.025 .
#   (0.09 0.21) math:sum 0.3 .
#   (0.3 0.025) math:sum 0.325 .
#   (0.60 0.05) math:product 0.03 .
#   (0.30 0.20) math:product 0.06 .
#   (0.10 0.50) math:product 0.05 .
#   (0.03 0.06) math:sum 0.09 .
#   (0.09 0.05) math:sum 0.14 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi1A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi1B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi1C .
#   } => {
#     _:b5 :pA ?pi1A .
#     _:b5 :pB ?pi1B .
#     _:b5 :pC ?pi1C .
#     :MC1 :pi1 _:b5 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.60
#   ?pB = 0.30
#   ?pC = 0.10
#   ?pi = _:b4
#   ?pi1A = 0.535
#   ?pi1B = 0.325
#   ?pi1C = 0.14
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.51
#   ?s2 = 0.3
#   ?s3 = 0.09
#   ?tAA = 0.48
#   ?tAB = 0.09
#   ?tAC = 0.03
#   ?tBA = 0.03
#   ?tBB = 0.21
#   ?tBC = 0.06
#   ?tCA = 0.025
#   ?tCB = 0.025
#   ?tCC = 0.05
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :pi1 _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :pA 0.49550000000000005 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (0.535 0.80) math:product 0.42800000000000005 .
#   (0.325 0.10) math:product 0.0325 .
#   (0.14 0.25) math:product 0.035 .
#   (0.42800000000000005 0.0325) math:sum 0.4605 .
#   (0.4605 0.035) math:sum 0.49550000000000005 .
#   (0.535 0.15) math:product 0.08025 .
#   (0.325 0.70) math:product 0.22749999999999998 .
#   (0.14 0.25) math:product 0.035 .
#   (0.08025 0.22749999999999998) math:sum 0.30774999999999997 .
#   (0.30774999999999997 0.035) math:sum 0.34275 .
#   (0.535 0.05) math:product 0.026750000000000003 .
#   (0.325 0.20) math:product 0.065 .
#   (0.14 0.50) math:product 0.07 .
#   (0.026750000000000003 0.065) math:sum 0.09175 .
#   (0.09175 0.07) math:sum 0.16175 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.535
#   ?pB = 0.325
#   ?pC = 0.14
#   ?pi = _:sk_0
#   ?pi2A = 0.49550000000000005
#   ?pi2B = 0.34275
#   ?pi2C = 0.16175
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4605
#   ?s2 = 0.30774999999999997
#   ?s3 = 0.09175
#   ?tAA = 0.42800000000000005
#   ?tAB = 0.08025
#   ?tAC = 0.026750000000000003
#   ?tBA = 0.0325
#   ?tBB = 0.22749999999999998
#   ?tBC = 0.065
#   ?tCA = 0.035
#   ?tCB = 0.035
#   ?tCC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :pA 0.49550000000000005 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :pB 0.34275 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (0.535 0.80) math:product 0.42800000000000005 .
#   (0.325 0.10) math:product 0.0325 .
#   (0.14 0.25) math:product 0.035 .
#   (0.42800000000000005 0.0325) math:sum 0.4605 .
#   (0.4605 0.035) math:sum 0.49550000000000005 .
#   (0.535 0.15) math:product 0.08025 .
#   (0.325 0.70) math:product 0.22749999999999998 .
#   (0.14 0.25) math:product 0.035 .
#   (0.08025 0.22749999999999998) math:sum 0.30774999999999997 .
#   (0.30774999999999997 0.035) math:sum 0.34275 .
#   (0.535 0.05) math:product 0.026750000000000003 .
#   (0.325 0.20) math:product 0.065 .
#   (0.14 0.50) math:product 0.07 .
#   (0.026750000000000003 0.065) math:sum 0.09175 .
#   (0.09175 0.07) math:sum 0.16175 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.535
#   ?pB = 0.325
#   ?pC = 0.14
#   ?pi = _:sk_0
#   ?pi2A = 0.49550000000000005
#   ?pi2B = 0.34275
#   ?pi2C = 0.16175
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4605
#   ?s2 = 0.30774999999999997
#   ?s3 = 0.09175
#   ?tAA = 0.42800000000000005
#   ?tAB = 0.08025
#   ?tAC = 0.026750000000000003
#   ?tBA = 0.0325
#   ?tBB = 0.22749999999999998
#   ?tBC = 0.065
#   ?tCA = 0.035
#   ?tCB = 0.035
#   ?tCC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :pB 0.34275 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :pC 0.16175 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (0.535 0.80) math:product 0.42800000000000005 .
#   (0.325 0.10) math:product 0.0325 .
#   (0.14 0.25) math:product 0.035 .
#   (0.42800000000000005 0.0325) math:sum 0.4605 .
#   (0.4605 0.035) math:sum 0.49550000000000005 .
#   (0.535 0.15) math:product 0.08025 .
#   (0.325 0.70) math:product 0.22749999999999998 .
#   (0.14 0.25) math:product 0.035 .
#   (0.08025 0.22749999999999998) math:sum 0.30774999999999997 .
#   (0.30774999999999997 0.035) math:sum 0.34275 .
#   (0.535 0.05) math:product 0.026750000000000003 .
#   (0.325 0.20) math:product 0.065 .
#   (0.14 0.50) math:product 0.07 .
#   (0.026750000000000003 0.065) math:sum 0.09175 .
#   (0.09175 0.07) math:sum 0.16175 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.535
#   ?pB = 0.325
#   ?pC = 0.14
#   ?pi = _:sk_0
#   ?pi2A = 0.49550000000000005
#   ?pi2B = 0.34275
#   ?pi2C = 0.16175
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4605
#   ?s2 = 0.30774999999999997
#   ?s3 = 0.09175
#   ?tAA = 0.42800000000000005
#   ?tAB = 0.08025
#   ?tAC = 0.026750000000000003
#   ?tBA = 0.0325
#   ?tBB = 0.22749999999999998
#   ?tBC = 0.065
#   ?tCA = 0.035
#   ?tCB = 0.035
#   ?tCC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :pC 0.16175 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :pi2 _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (0.535 0.80) math:product 0.42800000000000005 .
#   (0.325 0.10) math:product 0.0325 .
#   (0.14 0.25) math:product 0.035 .
#   (0.42800000000000005 0.0325) math:sum 0.4605 .
#   (0.4605 0.035) math:sum 0.49550000000000005 .
#   (0.535 0.15) math:product 0.08025 .
#   (0.325 0.70) math:product 0.22749999999999998 .
#   (0.14 0.25) math:product 0.035 .
#   (0.08025 0.22749999999999998) math:sum 0.30774999999999997 .
#   (0.30774999999999997 0.035) math:sum 0.34275 .
#   (0.535 0.05) math:product 0.026750000000000003 .
#   (0.325 0.20) math:product 0.065 .
#   (0.14 0.50) math:product 0.07 .
#   (0.026750000000000003 0.065) math:sum 0.09175 .
#   (0.09175 0.07) math:sum 0.16175 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi2A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi2B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi2C .
#   } => {
#     _:b6 :pA ?pi2A .
#     _:b6 :pB ?pi2B .
#     _:b6 :pC ?pi2C .
#     :MC1 :pi2 _:b6 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.535
#   ?pB = 0.325
#   ?pC = 0.14
#   ?pi = _:sk_0
#   ?pi2A = 0.49550000000000005
#   ?pi2B = 0.34275
#   ?pi2C = 0.16175
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4605
#   ?s2 = 0.30774999999999997
#   ?s3 = 0.09175
#   ?tAA = 0.42800000000000005
#   ?tAB = 0.08025
#   ?tAC = 0.026750000000000003
#   ?tBA = 0.0325
#   ?tBB = 0.22749999999999998
#   ?tBC = 0.065
#   ?tCA = 0.035
#   ?tCB = 0.035
#   ?tCC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :pi2 _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :pA 0.4711125000000001 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (0.49550000000000005 0.80) math:product 0.3964000000000001 .
#   (0.34275 0.10) math:product 0.034275 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.3964000000000001 0.034275) math:sum 0.4306750000000001 .
#   (0.4306750000000001 0.0404375) math:sum 0.4711125000000001 .
#   (0.49550000000000005 0.15) math:product 0.074325 .
#   (0.34275 0.70) math:product 0.23992499999999997 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.074325 0.23992499999999997) math:sum 0.31425 .
#   (0.31425 0.0404375) math:sum 0.3546875 .
#   (0.49550000000000005 0.05) math:product 0.024775000000000005 .
#   (0.34275 0.20) math:product 0.06855 .
#   (0.16175 0.50) math:product 0.080875 .
#   (0.024775000000000005 0.06855) math:sum 0.093325 .
#   (0.093325 0.080875) math:sum 0.17420000000000002 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.49550000000000005
#   ?pB = 0.34275
#   ?pC = 0.16175
#   ?pi = _:sk_1
#   ?pi3A = 0.4711125000000001
#   ?pi3B = 0.3546875
#   ?pi3C = 0.17420000000000002
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4306750000000001
#   ?s2 = 0.31425
#   ?s3 = 0.093325
#   ?tAA = 0.3964000000000001
#   ?tAB = 0.074325
#   ?tAC = 0.024775000000000005
#   ?tBA = 0.034275
#   ?tBB = 0.23992499999999997
#   ?tBC = 0.06855
#   ?tCA = 0.0404375
#   ?tCB = 0.0404375
#   ?tCC = 0.080875
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :pA 0.4711125000000001 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :pB 0.3546875 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (0.49550000000000005 0.80) math:product 0.3964000000000001 .
#   (0.34275 0.10) math:product 0.034275 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.3964000000000001 0.034275) math:sum 0.4306750000000001 .
#   (0.4306750000000001 0.0404375) math:sum 0.4711125000000001 .
#   (0.49550000000000005 0.15) math:product 0.074325 .
#   (0.34275 0.70) math:product 0.23992499999999997 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.074325 0.23992499999999997) math:sum 0.31425 .
#   (0.31425 0.0404375) math:sum 0.3546875 .
#   (0.49550000000000005 0.05) math:product 0.024775000000000005 .
#   (0.34275 0.20) math:product 0.06855 .
#   (0.16175 0.50) math:product 0.080875 .
#   (0.024775000000000005 0.06855) math:sum 0.093325 .
#   (0.093325 0.080875) math:sum 0.17420000000000002 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.49550000000000005
#   ?pB = 0.34275
#   ?pC = 0.16175
#   ?pi = _:sk_1
#   ?pi3A = 0.4711125000000001
#   ?pi3B = 0.3546875
#   ?pi3C = 0.17420000000000002
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4306750000000001
#   ?s2 = 0.31425
#   ?s3 = 0.093325
#   ?tAA = 0.3964000000000001
#   ?tAB = 0.074325
#   ?tAC = 0.024775000000000005
#   ?tBA = 0.034275
#   ?tBB = 0.23992499999999997
#   ?tBC = 0.06855
#   ?tCA = 0.0404375
#   ?tCB = 0.0404375
#   ?tCC = 0.080875
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :pB 0.3546875 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :pC 0.17420000000000002 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (0.49550000000000005 0.80) math:product 0.3964000000000001 .
#   (0.34275 0.10) math:product 0.034275 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.3964000000000001 0.034275) math:sum 0.4306750000000001 .
#   (0.4306750000000001 0.0404375) math:sum 0.4711125000000001 .
#   (0.49550000000000005 0.15) math:product 0.074325 .
#   (0.34275 0.70) math:product 0.23992499999999997 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.074325 0.23992499999999997) math:sum 0.31425 .
#   (0.31425 0.0404375) math:sum 0.3546875 .
#   (0.49550000000000005 0.05) math:product 0.024775000000000005 .
#   (0.34275 0.20) math:product 0.06855 .
#   (0.16175 0.50) math:product 0.080875 .
#   (0.024775000000000005 0.06855) math:sum 0.093325 .
#   (0.093325 0.080875) math:sum 0.17420000000000002 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.49550000000000005
#   ?pB = 0.34275
#   ?pC = 0.16175
#   ?pi = _:sk_1
#   ?pi3A = 0.4711125000000001
#   ?pi3B = 0.3546875
#   ?pi3C = 0.17420000000000002
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4306750000000001
#   ?s2 = 0.31425
#   ?s3 = 0.093325
#   ?tAA = 0.3964000000000001
#   ?tAB = 0.074325
#   ?tAC = 0.024775000000000005
#   ?tBA = 0.034275
#   ?tBB = 0.23992499999999997
#   ?tBC = 0.06855
#   ?tCA = 0.0404375
#   ?tCB = 0.0404375
#   ?tCC = 0.080875
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :pC 0.17420000000000002 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :pi3 _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (0.49550000000000005 0.80) math:product 0.3964000000000001 .
#   (0.34275 0.10) math:product 0.034275 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.3964000000000001 0.034275) math:sum 0.4306750000000001 .
#   (0.4306750000000001 0.0404375) math:sum 0.4711125000000001 .
#   (0.49550000000000005 0.15) math:product 0.074325 .
#   (0.34275 0.70) math:product 0.23992499999999997 .
#   (0.16175 0.25) math:product 0.0404375 .
#   (0.074325 0.23992499999999997) math:sum 0.31425 .
#   (0.31425 0.0404375) math:sum 0.3546875 .
#   (0.49550000000000005 0.05) math:product 0.024775000000000005 .
#   (0.34275 0.20) math:product 0.06855 .
#   (0.16175 0.50) math:product 0.080875 .
#   (0.024775000000000005 0.06855) math:sum 0.093325 .
#   (0.093325 0.080875) math:sum 0.17420000000000002 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     ?pi :pA ?pA .
#     ?pi :pB ?pB .
#     ?pi :pC ?pC .
#     (?pA ?AA) math:product ?tAA .
#     (?pB ?BA) math:product ?tBA .
#     (?pC ?CA) math:product ?tCA .
#     (?tAA ?tBA) math:sum ?s1 .
#     (?s1 ?tCA) math:sum ?pi3A .
#     (?pA ?AB) math:product ?tAB .
#     (?pB ?BB) math:product ?tBB .
#     (?pC ?CB) math:product ?tCB .
#     (?tAB ?tBB) math:sum ?s2 .
#     (?s2 ?tCB) math:sum ?pi3B .
#     (?pA ?AC) math:product ?tAC .
#     (?pB ?BC) math:product ?tBC .
#     (?pC ?CC) math:product ?tCC .
#     (?tAC ?tBC) math:sum ?s3 .
#     (?s3 ?tCC) math:sum ?pi3C .
#   } => {
#     _:b7 :pA ?pi3A .
#     _:b7 :pB ?pi3B .
#     _:b7 :pC ?pi3C .
#     :MC1 :pi3 _:b7 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AB = 0.15
#   ?AC = 0.05
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?pA = 0.49550000000000005
#   ?pB = 0.34275
#   ?pC = 0.16175
#   ?pi = _:sk_1
#   ?pi3A = 0.4711125000000001
#   ?pi3B = 0.3546875
#   ?pi3C = 0.17420000000000002
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?s1 = 0.4306750000000001
#   ?s2 = 0.31425
#   ?s3 = 0.093325
#   ?tAA = 0.3964000000000001
#   ?tAB = 0.074325
#   ?tAC = 0.024775000000000005
#   ?tBA = 0.034275
#   ?tBB = 0.23992499999999997
#   ?tBC = 0.06855
#   ?tCA = 0.0404375
#   ?tCB = 0.0404375
#   ?tCC = 0.080875
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :pi3 _:sk_2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :pA 0.6675000000000001 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product 0.6400000000000001 .
#   (0.15 0.10) math:product 0.015 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.6400000000000001 0.015) math:sum 0.6550000000000001 .
#   (0.6550000000000001 0.0125) math:sum 0.6675000000000001 .
#   (0.80 0.15) math:product 0.12 .
#   (0.15 0.70) math:product 0.105 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.12 0.105) math:sum 0.22499999999999998 .
#   (0.22499999999999998 0.0125) math:sum 0.2375 .
#   (0.80 0.05) math:product 0.04000000000000001 .
#   (0.15 0.20) math:product 0.03 .
#   (0.05 0.50) math:product 0.025 .
#   (0.04000000000000001 0.03) math:sum 0.07 .
#   (0.07 0.025) math:sum 0.095 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = 0.6400000000000001
#   ?AA_AB = 0.12
#   ?AA_AC = 0.04000000000000001
#   ?AB = 0.15
#   ?AB_BA = 0.015
#   ?AB_BB = 0.105
#   ?AB_BC = 0.03
#   ?AC = 0.05
#   ?AC_CA = 0.0125
#   ?AC_CB = 0.0125
#   ?AC_CC = 0.025
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = 0.6675000000000001
#   ?P2AB = 0.2375
#   ?P2AC = 0.095
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = 0.6550000000000001
#   ?sAB = 0.22499999999999998
#   ?sAC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :pA 0.6675000000000001 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :pB 0.2375 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product 0.6400000000000001 .
#   (0.15 0.10) math:product 0.015 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.6400000000000001 0.015) math:sum 0.6550000000000001 .
#   (0.6550000000000001 0.0125) math:sum 0.6675000000000001 .
#   (0.80 0.15) math:product 0.12 .
#   (0.15 0.70) math:product 0.105 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.12 0.105) math:sum 0.22499999999999998 .
#   (0.22499999999999998 0.0125) math:sum 0.2375 .
#   (0.80 0.05) math:product 0.04000000000000001 .
#   (0.15 0.20) math:product 0.03 .
#   (0.05 0.50) math:product 0.025 .
#   (0.04000000000000001 0.03) math:sum 0.07 .
#   (0.07 0.025) math:sum 0.095 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = 0.6400000000000001
#   ?AA_AB = 0.12
#   ?AA_AC = 0.04000000000000001
#   ?AB = 0.15
#   ?AB_BA = 0.015
#   ?AB_BB = 0.105
#   ?AB_BC = 0.03
#   ?AC = 0.05
#   ?AC_CA = 0.0125
#   ?AC_CB = 0.0125
#   ?AC_CC = 0.025
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = 0.6675000000000001
#   ?P2AB = 0.2375
#   ?P2AC = 0.095
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = 0.6550000000000001
#   ?sAB = 0.22499999999999998
#   ?sAC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :pB 0.2375 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_3 :pC 0.095 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product 0.6400000000000001 .
#   (0.15 0.10) math:product 0.015 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.6400000000000001 0.015) math:sum 0.6550000000000001 .
#   (0.6550000000000001 0.0125) math:sum 0.6675000000000001 .
#   (0.80 0.15) math:product 0.12 .
#   (0.15 0.70) math:product 0.105 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.12 0.105) math:sum 0.22499999999999998 .
#   (0.22499999999999998 0.0125) math:sum 0.2375 .
#   (0.80 0.05) math:product 0.04000000000000001 .
#   (0.15 0.20) math:product 0.03 .
#   (0.05 0.50) math:product 0.025 .
#   (0.04000000000000001 0.03) math:sum 0.07 .
#   (0.07 0.025) math:sum 0.095 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = 0.6400000000000001
#   ?AA_AB = 0.12
#   ?AA_AC = 0.04000000000000001
#   ?AB = 0.15
#   ?AB_BA = 0.015
#   ?AB_BB = 0.105
#   ?AB_BC = 0.03
#   ?AC = 0.05
#   ?AC_CA = 0.0125
#   ?AC_CB = 0.0125
#   ?AC_CC = 0.025
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = 0.6675000000000001
#   ?P2AB = 0.2375
#   ?P2AC = 0.095
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = 0.6550000000000001
#   ?sAB = 0.22499999999999998
#   ?sAC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_3 :pC 0.095 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :P2rowA _:sk_3 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :row _:b1 .
#   _:b1 :from :A .
#   _:b1 :pA 0.80 .
#   _:b1 :pB 0.15 .
#   _:b1 :pC 0.05 .
#   :MC1 :row _:b2 .
#   _:b2 :from :B .
#   _:b2 :pA 0.10 .
#   _:b2 :pB 0.70 .
#   _:b2 :pC 0.20 .
#   :MC1 :row _:b3 .
#   _:b3 :from :C .
#   _:b3 :pA 0.25 .
#   _:b3 :pB 0.25 .
#   _:b3 :pC 0.50 .
#   (0.80 0.80) math:product 0.6400000000000001 .
#   (0.15 0.10) math:product 0.015 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.6400000000000001 0.015) math:sum 0.6550000000000001 .
#   (0.6550000000000001 0.0125) math:sum 0.6675000000000001 .
#   (0.80 0.15) math:product 0.12 .
#   (0.15 0.70) math:product 0.105 .
#   (0.05 0.25) math:product 0.0125 .
#   (0.12 0.105) math:sum 0.22499999999999998 .
#   (0.22499999999999998 0.0125) math:sum 0.2375 .
#   (0.80 0.05) math:product 0.04000000000000001 .
#   (0.15 0.20) math:product 0.03 .
#   (0.05 0.50) math:product 0.025 .
#   (0.04000000000000001 0.03) math:sum 0.07 .
#   (0.07 0.025) math:sum 0.095 .
# via the schematic forward rule:
#   {
#     :MC1 :row ?rA .
#     ?rA :from :A .
#     ?rA :pA ?AA .
#     ?rA :pB ?AB .
#     ?rA :pC ?AC .
#     :MC1 :row ?rB .
#     ?rB :from :B .
#     ?rB :pA ?BA .
#     ?rB :pB ?BB .
#     ?rB :pC ?BC .
#     :MC1 :row ?rC .
#     ?rC :from :C .
#     ?rC :pA ?CA .
#     ?rC :pB ?CB .
#     ?rC :pC ?CC .
#     (?AA ?AA) math:product ?AA_AA .
#     (?AB ?BA) math:product ?AB_BA .
#     (?AC ?CA) math:product ?AC_CA .
#     (?AA_AA ?AB_BA) math:sum ?sAA .
#     (?sAA ?AC_CA) math:sum ?P2AA .
#     (?AA ?AB) math:product ?AA_AB .
#     (?AB ?BB) math:product ?AB_BB .
#     (?AC ?CB) math:product ?AC_CB .
#     (?AA_AB ?AB_BB) math:sum ?sAB .
#     (?sAB ?AC_CB) math:sum ?P2AB .
#     (?AA ?AC) math:product ?AA_AC .
#     (?AB ?BC) math:product ?AB_BC .
#     (?AC ?CC) math:product ?AC_CC .
#     (?AA_AC ?AB_BC) math:sum ?sAC .
#     (?sAC ?AC_CC) math:sum ?P2AC .
#   } => {
#     _:b8 :pA ?P2AA .
#     _:b8 :pB ?P2AB .
#     _:b8 :pC ?P2AC .
#     :MC1 :P2rowA _:b8 .
#   } .
# with substitution (on rule variables):
#   ?AA = 0.80
#   ?AA_AA = 0.6400000000000001
#   ?AA_AB = 0.12
#   ?AA_AC = 0.04000000000000001
#   ?AB = 0.15
#   ?AB_BA = 0.015
#   ?AB_BB = 0.105
#   ?AB_BC = 0.03
#   ?AC = 0.05
#   ?AC_CA = 0.0125
#   ?AC_CB = 0.0125
#   ?AC_CC = 0.025
#   ?BA = 0.10
#   ?BB = 0.70
#   ?BC = 0.20
#   ?CA = 0.25
#   ?CB = 0.25
#   ?CC = 0.50
#   ?P2AA = 0.6675000000000001
#   ?P2AB = 0.2375
#   ?P2AC = 0.095
#   ?rA = _:b1
#   ?rB = _:b2
#   ?rC = _:b3
#   ?sAA = 0.6550000000000001
#   ?sAB = 0.22499999999999998
#   ?sAC = 0.07
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :P2rowA _:sk_3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :t 0 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#   } => {
#     _:b9 :t 0 .
#     _:b9 :pi ?pi .
#     :MC1 :metrics _:b9 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :t 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :pi _:b4 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#   } => {
#     _:b9 :t 0 .
#     _:b9 :pi ?pi .
#     :MC1 :metrics _:b9 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :pi _:b4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_4 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi0 _:b4 .
# via the schematic forward rule:
#   {
#     :MC1 :pi0 ?pi .
#   } => {
#     _:b9 :t 0 .
#     _:b9 :pi ?pi .
#     :MC1 :metrics _:b9 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :t 1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#   } => {
#     _:b10 :t 1 .
#     _:b10 :pi ?pi .
#     :MC1 :metrics _:b10 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :t 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :pi _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#   } => {
#     _:b10 :t 1 .
#     _:b10 :pi ?pi .
#     :MC1 :metrics _:b10 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :pi _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_5 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi1 _:sk_0 .
# via the schematic forward rule:
#   {
#     :MC1 :pi1 ?pi .
#   } => {
#     _:b10 :t 1 .
#     _:b10 :pi ?pi .
#     :MC1 :metrics _:b10 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :t 2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#   } => {
#     _:b11 :t 2 .
#     _:b11 :pi ?pi .
#     :MC1 :metrics _:b11 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :t 2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :pi _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#   } => {
#     _:b11 :t 2 .
#     _:b11 :pi ?pi .
#     :MC1 :metrics _:b11 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :pi _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_6 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi2 _:sk_1 .
# via the schematic forward rule:
#   {
#     :MC1 :pi2 ?pi .
#   } => {
#     _:b11 :t 2 .
#     _:b11 :pi ?pi .
#     :MC1 :metrics _:b11 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_6 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :t 3 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi3 _:sk_2 .
# via the schematic forward rule:
#   {
#     :MC1 :pi3 ?pi .
#   } => {
#     _:b12 :t 3 .
#     _:b12 :pi ?pi .
#     :MC1 :metrics _:b12 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :t 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :pi _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi3 _:sk_2 .
# via the schematic forward rule:
#   {
#     :MC1 :pi3 ?pi .
#   } => {
#     _:b12 :t 3 .
#     _:b12 :pi ?pi .
#     :MC1 :metrics _:b12 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :pi _:sk_2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :MC1 :metrics _:sk_7 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :pi3 _:sk_2 .
# via the schematic forward rule:
#   {
#     :MC1 :pi3 ?pi .
#   } => {
#     _:b12 :t 3 .
#     _:b12 :pi ?pi .
#     :MC1 :metrics _:b12 .
#   } .
# with substitution (on rule variables):
#   ?pi = _:sk_2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:MC1 :metrics _:sk_7 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :sumSq 0.3780958503125001 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA 0.4711125000000001 .
#   _:sk_2 :pB 0.3546875 .
#   _:sk_2 :pC 0.17420000000000002 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.4711125000000001 2.0) math:exponentiation 0.2219469876562501 .
#   (0.3546875 2.0) math:exponentiation 0.12580322265625 .
#   (0.17420000000000002 2.0) math:exponentiation 0.030345640000000007 .
#   (0.2219469876562501 0.12580322265625) math:sum 0.3477502103125001 .
#   (0.3477502103125001 0.030345640000000007) math:sum 0.3780958503125001 .
#   (1.0 0.3780958503125001) math:difference 0.6219041496875 .
#   (1.0 0.3780958503125001) math:quotient 2.644831989490204 .
#   (0.4711125000000001 0.3333333333333333) math:difference 0.13777916666666679 .
#   0.13777916666666679 math:absoluteValue 0.13777916666666679 .
#   (0.3546875 0.3333333333333333) math:difference 0.021354166666666674 .
#   0.021354166666666674 math:absoluteValue 0.021354166666666674 .
#   (0.17420000000000002 0.3333333333333333) math:difference -0.1591333333333333 .
#   -0.1591333333333333 math:absoluteValue 0.1591333333333333 .
#   (0.13777916666666679 0.021354166666666674) math:sum 0.15913333333333346 .
#   (0.15913333333333346 0.1591333333333333) math:sum 0.31826666666666675 .
#   (0.5 0.31826666666666675) math:product 0.15913333333333338 .
#   (0.13777916666666679 2.0) math:exponentiation 0.018983098767361144 .
#   (0.021354166666666674 2.0) math:exponentiation 0.0004560004340277781 .
#   (-0.1591333333333333 2.0) math:exponentiation 0.025323417777777767 .
#   (0.018983098767361144 0.0004560004340277781) math:sum 0.01943909920138892 .
#   (0.01943909920138892 0.025323417777777767) math:sum 0.04476251697916669 .
#   (0.04476251697916669 0.5) math:exponentiation 0.2115715410426617 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.4711125000000001
#   ?a2 = 0.2219469876562501
#   ?ab2 = 0.3477502103125001
#   ?ada = 0.13777916666666679
#   ?adb = 0.021354166666666674
#   ?adc = 0.1591333333333333
#   ?b = 0.3546875
#   ?b2 = 0.12580322265625
#   ?c = 0.17420000000000002
#   ?c2 = 0.030345640000000007
#   ?da = 0.13777916666666679
#   ?da2 = 0.018983098767361144
#   ?db = 0.021354166666666674
#   ?db2 = 0.0004560004340277781
#   ?dc = -0.1591333333333333
#   ?dc2 = 0.025323417777777767
#   ?effN = 2.644831989490204
#   ?gini = 0.6219041496875
#   ?l2 = 0.2115715410426617
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = 0.15913333333333346
#   ?s2 = 0.01943909920138892
#   ?s3 = 0.04476251697916669
#   ?sAbs = 0.31826666666666675
#   ?sumSq = 0.3780958503125001
#   ?tv = 0.15913333333333338
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :sumSq 0.3780958503125001 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :gini 0.6219041496875 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA 0.4711125000000001 .
#   _:sk_2 :pB 0.3546875 .
#   _:sk_2 :pC 0.17420000000000002 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.4711125000000001 2.0) math:exponentiation 0.2219469876562501 .
#   (0.3546875 2.0) math:exponentiation 0.12580322265625 .
#   (0.17420000000000002 2.0) math:exponentiation 0.030345640000000007 .
#   (0.2219469876562501 0.12580322265625) math:sum 0.3477502103125001 .
#   (0.3477502103125001 0.030345640000000007) math:sum 0.3780958503125001 .
#   (1.0 0.3780958503125001) math:difference 0.6219041496875 .
#   (1.0 0.3780958503125001) math:quotient 2.644831989490204 .
#   (0.4711125000000001 0.3333333333333333) math:difference 0.13777916666666679 .
#   0.13777916666666679 math:absoluteValue 0.13777916666666679 .
#   (0.3546875 0.3333333333333333) math:difference 0.021354166666666674 .
#   0.021354166666666674 math:absoluteValue 0.021354166666666674 .
#   (0.17420000000000002 0.3333333333333333) math:difference -0.1591333333333333 .
#   -0.1591333333333333 math:absoluteValue 0.1591333333333333 .
#   (0.13777916666666679 0.021354166666666674) math:sum 0.15913333333333346 .
#   (0.15913333333333346 0.1591333333333333) math:sum 0.31826666666666675 .
#   (0.5 0.31826666666666675) math:product 0.15913333333333338 .
#   (0.13777916666666679 2.0) math:exponentiation 0.018983098767361144 .
#   (0.021354166666666674 2.0) math:exponentiation 0.0004560004340277781 .
#   (-0.1591333333333333 2.0) math:exponentiation 0.025323417777777767 .
#   (0.018983098767361144 0.0004560004340277781) math:sum 0.01943909920138892 .
#   (0.01943909920138892 0.025323417777777767) math:sum 0.04476251697916669 .
#   (0.04476251697916669 0.5) math:exponentiation 0.2115715410426617 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.4711125000000001
#   ?a2 = 0.2219469876562501
#   ?ab2 = 0.3477502103125001
#   ?ada = 0.13777916666666679
#   ?adb = 0.021354166666666674
#   ?adc = 0.1591333333333333
#   ?b = 0.3546875
#   ?b2 = 0.12580322265625
#   ?c = 0.17420000000000002
#   ?c2 = 0.030345640000000007
#   ?da = 0.13777916666666679
#   ?da2 = 0.018983098767361144
#   ?db = 0.021354166666666674
#   ?db2 = 0.0004560004340277781
#   ?dc = -0.1591333333333333
#   ?dc2 = 0.025323417777777767
#   ?effN = 2.644831989490204
#   ?gini = 0.6219041496875
#   ?l2 = 0.2115715410426617
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = 0.15913333333333346
#   ?s2 = 0.01943909920138892
#   ?s3 = 0.04476251697916669
#   ?sAbs = 0.31826666666666675
#   ?sumSq = 0.3780958503125001
#   ?tv = 0.15913333333333338
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :gini 0.6219041496875 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :effectiveStates 2.644831989490204 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA 0.4711125000000001 .
#   _:sk_2 :pB 0.3546875 .
#   _:sk_2 :pC 0.17420000000000002 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.4711125000000001 2.0) math:exponentiation 0.2219469876562501 .
#   (0.3546875 2.0) math:exponentiation 0.12580322265625 .
#   (0.17420000000000002 2.0) math:exponentiation 0.030345640000000007 .
#   (0.2219469876562501 0.12580322265625) math:sum 0.3477502103125001 .
#   (0.3477502103125001 0.030345640000000007) math:sum 0.3780958503125001 .
#   (1.0 0.3780958503125001) math:difference 0.6219041496875 .
#   (1.0 0.3780958503125001) math:quotient 2.644831989490204 .
#   (0.4711125000000001 0.3333333333333333) math:difference 0.13777916666666679 .
#   0.13777916666666679 math:absoluteValue 0.13777916666666679 .
#   (0.3546875 0.3333333333333333) math:difference 0.021354166666666674 .
#   0.021354166666666674 math:absoluteValue 0.021354166666666674 .
#   (0.17420000000000002 0.3333333333333333) math:difference -0.1591333333333333 .
#   -0.1591333333333333 math:absoluteValue 0.1591333333333333 .
#   (0.13777916666666679 0.021354166666666674) math:sum 0.15913333333333346 .
#   (0.15913333333333346 0.1591333333333333) math:sum 0.31826666666666675 .
#   (0.5 0.31826666666666675) math:product 0.15913333333333338 .
#   (0.13777916666666679 2.0) math:exponentiation 0.018983098767361144 .
#   (0.021354166666666674 2.0) math:exponentiation 0.0004560004340277781 .
#   (-0.1591333333333333 2.0) math:exponentiation 0.025323417777777767 .
#   (0.018983098767361144 0.0004560004340277781) math:sum 0.01943909920138892 .
#   (0.01943909920138892 0.025323417777777767) math:sum 0.04476251697916669 .
#   (0.04476251697916669 0.5) math:exponentiation 0.2115715410426617 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.4711125000000001
#   ?a2 = 0.2219469876562501
#   ?ab2 = 0.3477502103125001
#   ?ada = 0.13777916666666679
#   ?adb = 0.021354166666666674
#   ?adc = 0.1591333333333333
#   ?b = 0.3546875
#   ?b2 = 0.12580322265625
#   ?c = 0.17420000000000002
#   ?c2 = 0.030345640000000007
#   ?da = 0.13777916666666679
#   ?da2 = 0.018983098767361144
#   ?db = 0.021354166666666674
#   ?db2 = 0.0004560004340277781
#   ?dc = -0.1591333333333333
#   ?dc2 = 0.025323417777777767
#   ?effN = 2.644831989490204
#   ?gini = 0.6219041496875
#   ?l2 = 0.2115715410426617
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = 0.15913333333333346
#   ?s2 = 0.01943909920138892
#   ?s3 = 0.04476251697916669
#   ?sAbs = 0.31826666666666675
#   ?sumSq = 0.3780958503125001
#   ?tv = 0.15913333333333338
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :effectiveStates 2.644831989490204 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :tvToUniform 0.15913333333333338 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA 0.4711125000000001 .
#   _:sk_2 :pB 0.3546875 .
#   _:sk_2 :pC 0.17420000000000002 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.4711125000000001 2.0) math:exponentiation 0.2219469876562501 .
#   (0.3546875 2.0) math:exponentiation 0.12580322265625 .
#   (0.17420000000000002 2.0) math:exponentiation 0.030345640000000007 .
#   (0.2219469876562501 0.12580322265625) math:sum 0.3477502103125001 .
#   (0.3477502103125001 0.030345640000000007) math:sum 0.3780958503125001 .
#   (1.0 0.3780958503125001) math:difference 0.6219041496875 .
#   (1.0 0.3780958503125001) math:quotient 2.644831989490204 .
#   (0.4711125000000001 0.3333333333333333) math:difference 0.13777916666666679 .
#   0.13777916666666679 math:absoluteValue 0.13777916666666679 .
#   (0.3546875 0.3333333333333333) math:difference 0.021354166666666674 .
#   0.021354166666666674 math:absoluteValue 0.021354166666666674 .
#   (0.17420000000000002 0.3333333333333333) math:difference -0.1591333333333333 .
#   -0.1591333333333333 math:absoluteValue 0.1591333333333333 .
#   (0.13777916666666679 0.021354166666666674) math:sum 0.15913333333333346 .
#   (0.15913333333333346 0.1591333333333333) math:sum 0.31826666666666675 .
#   (0.5 0.31826666666666675) math:product 0.15913333333333338 .
#   (0.13777916666666679 2.0) math:exponentiation 0.018983098767361144 .
#   (0.021354166666666674 2.0) math:exponentiation 0.0004560004340277781 .
#   (-0.1591333333333333 2.0) math:exponentiation 0.025323417777777767 .
#   (0.018983098767361144 0.0004560004340277781) math:sum 0.01943909920138892 .
#   (0.01943909920138892 0.025323417777777767) math:sum 0.04476251697916669 .
#   (0.04476251697916669 0.5) math:exponentiation 0.2115715410426617 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.4711125000000001
#   ?a2 = 0.2219469876562501
#   ?ab2 = 0.3477502103125001
#   ?ada = 0.13777916666666679
#   ?adb = 0.021354166666666674
#   ?adc = 0.1591333333333333
#   ?b = 0.3546875
#   ?b2 = 0.12580322265625
#   ?c = 0.17420000000000002
#   ?c2 = 0.030345640000000007
#   ?da = 0.13777916666666679
#   ?da2 = 0.018983098767361144
#   ?db = 0.021354166666666674
#   ?db2 = 0.0004560004340277781
#   ?dc = -0.1591333333333333
#   ?dc2 = 0.025323417777777767
#   ?effN = 2.644831989490204
#   ?gini = 0.6219041496875
#   ?l2 = 0.2115715410426617
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = 0.15913333333333346
#   ?s2 = 0.01943909920138892
#   ?s3 = 0.04476251697916669
#   ?sAbs = 0.31826666666666675
#   ?sumSq = 0.3780958503125001
#   ?tv = 0.15913333333333338
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :tvToUniform 0.15913333333333338 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_7 :l2ToUniform 0.2115715410426617 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_7 .
#   _:sk_7 :pi _:sk_2 .
#   _:sk_2 :pA 0.4711125000000001 .
#   _:sk_2 :pB 0.3546875 .
#   _:sk_2 :pC 0.17420000000000002 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.4711125000000001 2.0) math:exponentiation 0.2219469876562501 .
#   (0.3546875 2.0) math:exponentiation 0.12580322265625 .
#   (0.17420000000000002 2.0) math:exponentiation 0.030345640000000007 .
#   (0.2219469876562501 0.12580322265625) math:sum 0.3477502103125001 .
#   (0.3477502103125001 0.030345640000000007) math:sum 0.3780958503125001 .
#   (1.0 0.3780958503125001) math:difference 0.6219041496875 .
#   (1.0 0.3780958503125001) math:quotient 2.644831989490204 .
#   (0.4711125000000001 0.3333333333333333) math:difference 0.13777916666666679 .
#   0.13777916666666679 math:absoluteValue 0.13777916666666679 .
#   (0.3546875 0.3333333333333333) math:difference 0.021354166666666674 .
#   0.021354166666666674 math:absoluteValue 0.021354166666666674 .
#   (0.17420000000000002 0.3333333333333333) math:difference -0.1591333333333333 .
#   -0.1591333333333333 math:absoluteValue 0.1591333333333333 .
#   (0.13777916666666679 0.021354166666666674) math:sum 0.15913333333333346 .
#   (0.15913333333333346 0.1591333333333333) math:sum 0.31826666666666675 .
#   (0.5 0.31826666666666675) math:product 0.15913333333333338 .
#   (0.13777916666666679 2.0) math:exponentiation 0.018983098767361144 .
#   (0.021354166666666674 2.0) math:exponentiation 0.0004560004340277781 .
#   (-0.1591333333333333 2.0) math:exponentiation 0.025323417777777767 .
#   (0.018983098767361144 0.0004560004340277781) math:sum 0.01943909920138892 .
#   (0.01943909920138892 0.025323417777777767) math:sum 0.04476251697916669 .
#   (0.04476251697916669 0.5) math:exponentiation 0.2115715410426617 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.4711125000000001
#   ?a2 = 0.2219469876562501
#   ?ab2 = 0.3477502103125001
#   ?ada = 0.13777916666666679
#   ?adb = 0.021354166666666674
#   ?adc = 0.1591333333333333
#   ?b = 0.3546875
#   ?b2 = 0.12580322265625
#   ?c = 0.17420000000000002
#   ?c2 = 0.030345640000000007
#   ?da = 0.13777916666666679
#   ?da2 = 0.018983098767361144
#   ?db = 0.021354166666666674
#   ?db2 = 0.0004560004340277781
#   ?dc = -0.1591333333333333
#   ?dc2 = 0.025323417777777767
#   ?effN = 2.644831989490204
#   ?gini = 0.6219041496875
#   ?l2 = 0.2115715410426617
#   ?m = _:sk_7
#   ?pi = _:sk_2
#   ?s1 = 0.15913333333333346
#   ?s2 = 0.01943909920138892
#   ?s3 = 0.04476251697916669
#   ?sAbs = 0.31826666666666675
#   ?sumSq = 0.3780958503125001
#   ?tv = 0.15913333333333338
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_7 :l2ToUniform 0.2115715410426617 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :sumSq 0.3891608750000001 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.49550000000000005 2.0) math:exponentiation 0.24552025000000005 .
#   (0.34275 2.0) math:exponentiation 0.1174775625 .
#   (0.16175 2.0) math:exponentiation 0.0261630625 .
#   (0.24552025000000005 0.1174775625) math:sum 0.36299781250000007 .
#   (0.36299781250000007 0.0261630625) math:sum 0.3891608750000001 .
#   (1.0 0.3891608750000001) math:difference 0.6108391249999999 .
#   (1.0 0.3891608750000001) math:quotient 2.569631389589202 .
#   (0.49550000000000005 0.3333333333333333) math:difference 0.16216666666666674 .
#   0.16216666666666674 math:absoluteValue 0.16216666666666674 .
#   (0.34275 0.3333333333333333) math:difference 0.009416666666666684 .
#   0.009416666666666684 math:absoluteValue 0.009416666666666684 .
#   (0.16175 0.3333333333333333) math:difference -0.1715833333333333 .
#   -0.1715833333333333 math:absoluteValue 0.1715833333333333 .
#   (0.16216666666666674 0.009416666666666684) math:sum 0.17158333333333342 .
#   (0.17158333333333342 0.1715833333333333) math:sum 0.34316666666666673 .
#   (0.5 0.34316666666666673) math:product 0.17158333333333337 .
#   (0.16216666666666674 2.0) math:exponentiation 0.026298027777777802 .
#   (0.009416666666666684 2.0) math:exponentiation 0.00008867361111111145 .
#   (-0.1715833333333333 2.0) math:exponentiation 0.02944084027777777 .
#   (0.026298027777777802 0.00008867361111111145) math:sum 0.026386701388888913 .
#   (0.026386701388888913 0.02944084027777777) math:sum 0.05582754166666668 .
#   (0.05582754166666668 0.5) math:exponentiation 0.23627852561472165 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.49550000000000005
#   ?a2 = 0.24552025000000005
#   ?ab2 = 0.36299781250000007
#   ?ada = 0.16216666666666674
#   ?adb = 0.009416666666666684
#   ?adc = 0.1715833333333333
#   ?b = 0.34275
#   ?b2 = 0.1174775625
#   ?c = 0.16175
#   ?c2 = 0.0261630625
#   ?da = 0.16216666666666674
#   ?da2 = 0.026298027777777802
#   ?db = 0.009416666666666684
#   ?db2 = 0.00008867361111111145
#   ?dc = -0.1715833333333333
#   ?dc2 = 0.02944084027777777
#   ?effN = 2.569631389589202
#   ?gini = 0.6108391249999999
#   ?l2 = 0.23627852561472165
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = 0.17158333333333342
#   ?s2 = 0.026386701388888913
#   ?s3 = 0.05582754166666668
#   ?sAbs = 0.34316666666666673
#   ?sumSq = 0.3891608750000001
#   ?tv = 0.17158333333333337
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :sumSq 0.3891608750000001 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :gini 0.6108391249999999 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.49550000000000005 2.0) math:exponentiation 0.24552025000000005 .
#   (0.34275 2.0) math:exponentiation 0.1174775625 .
#   (0.16175 2.0) math:exponentiation 0.0261630625 .
#   (0.24552025000000005 0.1174775625) math:sum 0.36299781250000007 .
#   (0.36299781250000007 0.0261630625) math:sum 0.3891608750000001 .
#   (1.0 0.3891608750000001) math:difference 0.6108391249999999 .
#   (1.0 0.3891608750000001) math:quotient 2.569631389589202 .
#   (0.49550000000000005 0.3333333333333333) math:difference 0.16216666666666674 .
#   0.16216666666666674 math:absoluteValue 0.16216666666666674 .
#   (0.34275 0.3333333333333333) math:difference 0.009416666666666684 .
#   0.009416666666666684 math:absoluteValue 0.009416666666666684 .
#   (0.16175 0.3333333333333333) math:difference -0.1715833333333333 .
#   -0.1715833333333333 math:absoluteValue 0.1715833333333333 .
#   (0.16216666666666674 0.009416666666666684) math:sum 0.17158333333333342 .
#   (0.17158333333333342 0.1715833333333333) math:sum 0.34316666666666673 .
#   (0.5 0.34316666666666673) math:product 0.17158333333333337 .
#   (0.16216666666666674 2.0) math:exponentiation 0.026298027777777802 .
#   (0.009416666666666684 2.0) math:exponentiation 0.00008867361111111145 .
#   (-0.1715833333333333 2.0) math:exponentiation 0.02944084027777777 .
#   (0.026298027777777802 0.00008867361111111145) math:sum 0.026386701388888913 .
#   (0.026386701388888913 0.02944084027777777) math:sum 0.05582754166666668 .
#   (0.05582754166666668 0.5) math:exponentiation 0.23627852561472165 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.49550000000000005
#   ?a2 = 0.24552025000000005
#   ?ab2 = 0.36299781250000007
#   ?ada = 0.16216666666666674
#   ?adb = 0.009416666666666684
#   ?adc = 0.1715833333333333
#   ?b = 0.34275
#   ?b2 = 0.1174775625
#   ?c = 0.16175
#   ?c2 = 0.0261630625
#   ?da = 0.16216666666666674
#   ?da2 = 0.026298027777777802
#   ?db = 0.009416666666666684
#   ?db2 = 0.00008867361111111145
#   ?dc = -0.1715833333333333
#   ?dc2 = 0.02944084027777777
#   ?effN = 2.569631389589202
#   ?gini = 0.6108391249999999
#   ?l2 = 0.23627852561472165
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = 0.17158333333333342
#   ?s2 = 0.026386701388888913
#   ?s3 = 0.05582754166666668
#   ?sAbs = 0.34316666666666673
#   ?sumSq = 0.3891608750000001
#   ?tv = 0.17158333333333337
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :gini 0.6108391249999999 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :effectiveStates 2.569631389589202 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.49550000000000005 2.0) math:exponentiation 0.24552025000000005 .
#   (0.34275 2.0) math:exponentiation 0.1174775625 .
#   (0.16175 2.0) math:exponentiation 0.0261630625 .
#   (0.24552025000000005 0.1174775625) math:sum 0.36299781250000007 .
#   (0.36299781250000007 0.0261630625) math:sum 0.3891608750000001 .
#   (1.0 0.3891608750000001) math:difference 0.6108391249999999 .
#   (1.0 0.3891608750000001) math:quotient 2.569631389589202 .
#   (0.49550000000000005 0.3333333333333333) math:difference 0.16216666666666674 .
#   0.16216666666666674 math:absoluteValue 0.16216666666666674 .
#   (0.34275 0.3333333333333333) math:difference 0.009416666666666684 .
#   0.009416666666666684 math:absoluteValue 0.009416666666666684 .
#   (0.16175 0.3333333333333333) math:difference -0.1715833333333333 .
#   -0.1715833333333333 math:absoluteValue 0.1715833333333333 .
#   (0.16216666666666674 0.009416666666666684) math:sum 0.17158333333333342 .
#   (0.17158333333333342 0.1715833333333333) math:sum 0.34316666666666673 .
#   (0.5 0.34316666666666673) math:product 0.17158333333333337 .
#   (0.16216666666666674 2.0) math:exponentiation 0.026298027777777802 .
#   (0.009416666666666684 2.0) math:exponentiation 0.00008867361111111145 .
#   (-0.1715833333333333 2.0) math:exponentiation 0.02944084027777777 .
#   (0.026298027777777802 0.00008867361111111145) math:sum 0.026386701388888913 .
#   (0.026386701388888913 0.02944084027777777) math:sum 0.05582754166666668 .
#   (0.05582754166666668 0.5) math:exponentiation 0.23627852561472165 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.49550000000000005
#   ?a2 = 0.24552025000000005
#   ?ab2 = 0.36299781250000007
#   ?ada = 0.16216666666666674
#   ?adb = 0.009416666666666684
#   ?adc = 0.1715833333333333
#   ?b = 0.34275
#   ?b2 = 0.1174775625
#   ?c = 0.16175
#   ?c2 = 0.0261630625
#   ?da = 0.16216666666666674
#   ?da2 = 0.026298027777777802
#   ?db = 0.009416666666666684
#   ?db2 = 0.00008867361111111145
#   ?dc = -0.1715833333333333
#   ?dc2 = 0.02944084027777777
#   ?effN = 2.569631389589202
#   ?gini = 0.6108391249999999
#   ?l2 = 0.23627852561472165
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = 0.17158333333333342
#   ?s2 = 0.026386701388888913
#   ?s3 = 0.05582754166666668
#   ?sAbs = 0.34316666666666673
#   ?sumSq = 0.3891608750000001
#   ?tv = 0.17158333333333337
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :effectiveStates 2.569631389589202 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :tvToUniform 0.17158333333333337 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.49550000000000005 2.0) math:exponentiation 0.24552025000000005 .
#   (0.34275 2.0) math:exponentiation 0.1174775625 .
#   (0.16175 2.0) math:exponentiation 0.0261630625 .
#   (0.24552025000000005 0.1174775625) math:sum 0.36299781250000007 .
#   (0.36299781250000007 0.0261630625) math:sum 0.3891608750000001 .
#   (1.0 0.3891608750000001) math:difference 0.6108391249999999 .
#   (1.0 0.3891608750000001) math:quotient 2.569631389589202 .
#   (0.49550000000000005 0.3333333333333333) math:difference 0.16216666666666674 .
#   0.16216666666666674 math:absoluteValue 0.16216666666666674 .
#   (0.34275 0.3333333333333333) math:difference 0.009416666666666684 .
#   0.009416666666666684 math:absoluteValue 0.009416666666666684 .
#   (0.16175 0.3333333333333333) math:difference -0.1715833333333333 .
#   -0.1715833333333333 math:absoluteValue 0.1715833333333333 .
#   (0.16216666666666674 0.009416666666666684) math:sum 0.17158333333333342 .
#   (0.17158333333333342 0.1715833333333333) math:sum 0.34316666666666673 .
#   (0.5 0.34316666666666673) math:product 0.17158333333333337 .
#   (0.16216666666666674 2.0) math:exponentiation 0.026298027777777802 .
#   (0.009416666666666684 2.0) math:exponentiation 0.00008867361111111145 .
#   (-0.1715833333333333 2.0) math:exponentiation 0.02944084027777777 .
#   (0.026298027777777802 0.00008867361111111145) math:sum 0.026386701388888913 .
#   (0.026386701388888913 0.02944084027777777) math:sum 0.05582754166666668 .
#   (0.05582754166666668 0.5) math:exponentiation 0.23627852561472165 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.49550000000000005
#   ?a2 = 0.24552025000000005
#   ?ab2 = 0.36299781250000007
#   ?ada = 0.16216666666666674
#   ?adb = 0.009416666666666684
#   ?adc = 0.1715833333333333
#   ?b = 0.34275
#   ?b2 = 0.1174775625
#   ?c = 0.16175
#   ?c2 = 0.0261630625
#   ?da = 0.16216666666666674
#   ?da2 = 0.026298027777777802
#   ?db = 0.009416666666666684
#   ?db2 = 0.00008867361111111145
#   ?dc = -0.1715833333333333
#   ?dc2 = 0.02944084027777777
#   ?effN = 2.569631389589202
#   ?gini = 0.6108391249999999
#   ?l2 = 0.23627852561472165
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = 0.17158333333333342
#   ?s2 = 0.026386701388888913
#   ?s3 = 0.05582754166666668
#   ?sAbs = 0.34316666666666673
#   ?sumSq = 0.3891608750000001
#   ?tv = 0.17158333333333337
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :tvToUniform 0.17158333333333337 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_6 :l2ToUniform 0.23627852561472165 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_6 .
#   _:sk_6 :pi _:sk_1 .
#   _:sk_1 :pA 0.49550000000000005 .
#   _:sk_1 :pB 0.34275 .
#   _:sk_1 :pC 0.16175 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.49550000000000005 2.0) math:exponentiation 0.24552025000000005 .
#   (0.34275 2.0) math:exponentiation 0.1174775625 .
#   (0.16175 2.0) math:exponentiation 0.0261630625 .
#   (0.24552025000000005 0.1174775625) math:sum 0.36299781250000007 .
#   (0.36299781250000007 0.0261630625) math:sum 0.3891608750000001 .
#   (1.0 0.3891608750000001) math:difference 0.6108391249999999 .
#   (1.0 0.3891608750000001) math:quotient 2.569631389589202 .
#   (0.49550000000000005 0.3333333333333333) math:difference 0.16216666666666674 .
#   0.16216666666666674 math:absoluteValue 0.16216666666666674 .
#   (0.34275 0.3333333333333333) math:difference 0.009416666666666684 .
#   0.009416666666666684 math:absoluteValue 0.009416666666666684 .
#   (0.16175 0.3333333333333333) math:difference -0.1715833333333333 .
#   -0.1715833333333333 math:absoluteValue 0.1715833333333333 .
#   (0.16216666666666674 0.009416666666666684) math:sum 0.17158333333333342 .
#   (0.17158333333333342 0.1715833333333333) math:sum 0.34316666666666673 .
#   (0.5 0.34316666666666673) math:product 0.17158333333333337 .
#   (0.16216666666666674 2.0) math:exponentiation 0.026298027777777802 .
#   (0.009416666666666684 2.0) math:exponentiation 0.00008867361111111145 .
#   (-0.1715833333333333 2.0) math:exponentiation 0.02944084027777777 .
#   (0.026298027777777802 0.00008867361111111145) math:sum 0.026386701388888913 .
#   (0.026386701388888913 0.02944084027777777) math:sum 0.05582754166666668 .
#   (0.05582754166666668 0.5) math:exponentiation 0.23627852561472165 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.49550000000000005
#   ?a2 = 0.24552025000000005
#   ?ab2 = 0.36299781250000007
#   ?ada = 0.16216666666666674
#   ?adb = 0.009416666666666684
#   ?adc = 0.1715833333333333
#   ?b = 0.34275
#   ?b2 = 0.1174775625
#   ?c = 0.16175
#   ?c2 = 0.0261630625
#   ?da = 0.16216666666666674
#   ?da2 = 0.026298027777777802
#   ?db = 0.009416666666666684
#   ?db2 = 0.00008867361111111145
#   ?dc = -0.1715833333333333
#   ?dc2 = 0.02944084027777777
#   ?effN = 2.569631389589202
#   ?gini = 0.6108391249999999
#   ?l2 = 0.23627852561472165
#   ?m = _:sk_6
#   ?pi = _:sk_1
#   ?s1 = 0.17158333333333342
#   ?s2 = 0.026386701388888913
#   ?s3 = 0.05582754166666668
#   ?sAbs = 0.34316666666666673
#   ?sumSq = 0.3891608750000001
#   ?tv = 0.17158333333333337
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_6 :l2ToUniform 0.23627852561472165 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :sumSq 0.41145000000000004 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.535 2.0) math:exponentiation 0.286225 .
#   (0.325 2.0) math:exponentiation 0.10562500000000001 .
#   (0.14 2.0) math:exponentiation 0.019600000000000003 .
#   (0.286225 0.10562500000000001) math:sum 0.39185000000000003 .
#   (0.39185000000000003 0.019600000000000003) math:sum 0.41145000000000004 .
#   (1.0 0.41145000000000004) math:difference 0.5885499999999999 .
#   (1.0 0.41145000000000004) math:quotient 2.4304289707133306 .
#   (0.535 0.3333333333333333) math:difference 0.20166666666666672 .
#   0.20166666666666672 math:absoluteValue 0.20166666666666672 .
#   (0.325 0.3333333333333333) math:difference -0.008333333333333304 .
#   -0.008333333333333304 math:absoluteValue 0.008333333333333304 .
#   (0.14 0.3333333333333333) math:difference -0.1933333333333333 .
#   -0.1933333333333333 math:absoluteValue 0.1933333333333333 .
#   (0.20166666666666672 0.008333333333333304) math:sum 0.21000000000000002 .
#   (0.21000000000000002 0.1933333333333333) math:sum 0.4033333333333333 .
#   (0.5 0.4033333333333333) math:product 0.20166666666666666 .
#   (0.20166666666666672 2.0) math:exponentiation 0.040669444444444466 .
#   (-0.008333333333333304 2.0) math:exponentiation 0.00006944444444444396 .
#   (-0.1933333333333333 2.0) math:exponentiation 0.03737777777777777 .
#   (0.040669444444444466 0.00006944444444444396) math:sum 0.04073888888888891 .
#   (0.04073888888888891 0.03737777777777777) math:sum 0.07811666666666667 .
#   (0.07811666666666667 0.5) math:exponentiation 0.2794935896700793 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.535
#   ?a2 = 0.286225
#   ?ab2 = 0.39185000000000003
#   ?ada = 0.20166666666666672
#   ?adb = 0.008333333333333304
#   ?adc = 0.1933333333333333
#   ?b = 0.325
#   ?b2 = 0.10562500000000001
#   ?c = 0.14
#   ?c2 = 0.019600000000000003
#   ?da = 0.20166666666666672
#   ?da2 = 0.040669444444444466
#   ?db = -0.008333333333333304
#   ?db2 = 0.00006944444444444396
#   ?dc = -0.1933333333333333
#   ?dc2 = 0.03737777777777777
#   ?effN = 2.4304289707133306
#   ?gini = 0.5885499999999999
#   ?l2 = 0.2794935896700793
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = 0.21000000000000002
#   ?s2 = 0.04073888888888891
#   ?s3 = 0.07811666666666667
#   ?sAbs = 0.4033333333333333
#   ?sumSq = 0.41145000000000004
#   ?tv = 0.20166666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :sumSq 0.41145000000000004 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :gini 0.5885499999999999 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.535 2.0) math:exponentiation 0.286225 .
#   (0.325 2.0) math:exponentiation 0.10562500000000001 .
#   (0.14 2.0) math:exponentiation 0.019600000000000003 .
#   (0.286225 0.10562500000000001) math:sum 0.39185000000000003 .
#   (0.39185000000000003 0.019600000000000003) math:sum 0.41145000000000004 .
#   (1.0 0.41145000000000004) math:difference 0.5885499999999999 .
#   (1.0 0.41145000000000004) math:quotient 2.4304289707133306 .
#   (0.535 0.3333333333333333) math:difference 0.20166666666666672 .
#   0.20166666666666672 math:absoluteValue 0.20166666666666672 .
#   (0.325 0.3333333333333333) math:difference -0.008333333333333304 .
#   -0.008333333333333304 math:absoluteValue 0.008333333333333304 .
#   (0.14 0.3333333333333333) math:difference -0.1933333333333333 .
#   -0.1933333333333333 math:absoluteValue 0.1933333333333333 .
#   (0.20166666666666672 0.008333333333333304) math:sum 0.21000000000000002 .
#   (0.21000000000000002 0.1933333333333333) math:sum 0.4033333333333333 .
#   (0.5 0.4033333333333333) math:product 0.20166666666666666 .
#   (0.20166666666666672 2.0) math:exponentiation 0.040669444444444466 .
#   (-0.008333333333333304 2.0) math:exponentiation 0.00006944444444444396 .
#   (-0.1933333333333333 2.0) math:exponentiation 0.03737777777777777 .
#   (0.040669444444444466 0.00006944444444444396) math:sum 0.04073888888888891 .
#   (0.04073888888888891 0.03737777777777777) math:sum 0.07811666666666667 .
#   (0.07811666666666667 0.5) math:exponentiation 0.2794935896700793 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.535
#   ?a2 = 0.286225
#   ?ab2 = 0.39185000000000003
#   ?ada = 0.20166666666666672
#   ?adb = 0.008333333333333304
#   ?adc = 0.1933333333333333
#   ?b = 0.325
#   ?b2 = 0.10562500000000001
#   ?c = 0.14
#   ?c2 = 0.019600000000000003
#   ?da = 0.20166666666666672
#   ?da2 = 0.040669444444444466
#   ?db = -0.008333333333333304
#   ?db2 = 0.00006944444444444396
#   ?dc = -0.1933333333333333
#   ?dc2 = 0.03737777777777777
#   ?effN = 2.4304289707133306
#   ?gini = 0.5885499999999999
#   ?l2 = 0.2794935896700793
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = 0.21000000000000002
#   ?s2 = 0.04073888888888891
#   ?s3 = 0.07811666666666667
#   ?sAbs = 0.4033333333333333
#   ?sumSq = 0.41145000000000004
#   ?tv = 0.20166666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :gini 0.5885499999999999 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :effectiveStates 2.4304289707133306 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.535 2.0) math:exponentiation 0.286225 .
#   (0.325 2.0) math:exponentiation 0.10562500000000001 .
#   (0.14 2.0) math:exponentiation 0.019600000000000003 .
#   (0.286225 0.10562500000000001) math:sum 0.39185000000000003 .
#   (0.39185000000000003 0.019600000000000003) math:sum 0.41145000000000004 .
#   (1.0 0.41145000000000004) math:difference 0.5885499999999999 .
#   (1.0 0.41145000000000004) math:quotient 2.4304289707133306 .
#   (0.535 0.3333333333333333) math:difference 0.20166666666666672 .
#   0.20166666666666672 math:absoluteValue 0.20166666666666672 .
#   (0.325 0.3333333333333333) math:difference -0.008333333333333304 .
#   -0.008333333333333304 math:absoluteValue 0.008333333333333304 .
#   (0.14 0.3333333333333333) math:difference -0.1933333333333333 .
#   -0.1933333333333333 math:absoluteValue 0.1933333333333333 .
#   (0.20166666666666672 0.008333333333333304) math:sum 0.21000000000000002 .
#   (0.21000000000000002 0.1933333333333333) math:sum 0.4033333333333333 .
#   (0.5 0.4033333333333333) math:product 0.20166666666666666 .
#   (0.20166666666666672 2.0) math:exponentiation 0.040669444444444466 .
#   (-0.008333333333333304 2.0) math:exponentiation 0.00006944444444444396 .
#   (-0.1933333333333333 2.0) math:exponentiation 0.03737777777777777 .
#   (0.040669444444444466 0.00006944444444444396) math:sum 0.04073888888888891 .
#   (0.04073888888888891 0.03737777777777777) math:sum 0.07811666666666667 .
#   (0.07811666666666667 0.5) math:exponentiation 0.2794935896700793 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.535
#   ?a2 = 0.286225
#   ?ab2 = 0.39185000000000003
#   ?ada = 0.20166666666666672
#   ?adb = 0.008333333333333304
#   ?adc = 0.1933333333333333
#   ?b = 0.325
#   ?b2 = 0.10562500000000001
#   ?c = 0.14
#   ?c2 = 0.019600000000000003
#   ?da = 0.20166666666666672
#   ?da2 = 0.040669444444444466
#   ?db = -0.008333333333333304
#   ?db2 = 0.00006944444444444396
#   ?dc = -0.1933333333333333
#   ?dc2 = 0.03737777777777777
#   ?effN = 2.4304289707133306
#   ?gini = 0.5885499999999999
#   ?l2 = 0.2794935896700793
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = 0.21000000000000002
#   ?s2 = 0.04073888888888891
#   ?s3 = 0.07811666666666667
#   ?sAbs = 0.4033333333333333
#   ?sumSq = 0.41145000000000004
#   ?tv = 0.20166666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :effectiveStates 2.4304289707133306 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :tvToUniform 0.20166666666666666 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.535 2.0) math:exponentiation 0.286225 .
#   (0.325 2.0) math:exponentiation 0.10562500000000001 .
#   (0.14 2.0) math:exponentiation 0.019600000000000003 .
#   (0.286225 0.10562500000000001) math:sum 0.39185000000000003 .
#   (0.39185000000000003 0.019600000000000003) math:sum 0.41145000000000004 .
#   (1.0 0.41145000000000004) math:difference 0.5885499999999999 .
#   (1.0 0.41145000000000004) math:quotient 2.4304289707133306 .
#   (0.535 0.3333333333333333) math:difference 0.20166666666666672 .
#   0.20166666666666672 math:absoluteValue 0.20166666666666672 .
#   (0.325 0.3333333333333333) math:difference -0.008333333333333304 .
#   -0.008333333333333304 math:absoluteValue 0.008333333333333304 .
#   (0.14 0.3333333333333333) math:difference -0.1933333333333333 .
#   -0.1933333333333333 math:absoluteValue 0.1933333333333333 .
#   (0.20166666666666672 0.008333333333333304) math:sum 0.21000000000000002 .
#   (0.21000000000000002 0.1933333333333333) math:sum 0.4033333333333333 .
#   (0.5 0.4033333333333333) math:product 0.20166666666666666 .
#   (0.20166666666666672 2.0) math:exponentiation 0.040669444444444466 .
#   (-0.008333333333333304 2.0) math:exponentiation 0.00006944444444444396 .
#   (-0.1933333333333333 2.0) math:exponentiation 0.03737777777777777 .
#   (0.040669444444444466 0.00006944444444444396) math:sum 0.04073888888888891 .
#   (0.04073888888888891 0.03737777777777777) math:sum 0.07811666666666667 .
#   (0.07811666666666667 0.5) math:exponentiation 0.2794935896700793 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.535
#   ?a2 = 0.286225
#   ?ab2 = 0.39185000000000003
#   ?ada = 0.20166666666666672
#   ?adb = 0.008333333333333304
#   ?adc = 0.1933333333333333
#   ?b = 0.325
#   ?b2 = 0.10562500000000001
#   ?c = 0.14
#   ?c2 = 0.019600000000000003
#   ?da = 0.20166666666666672
#   ?da2 = 0.040669444444444466
#   ?db = -0.008333333333333304
#   ?db2 = 0.00006944444444444396
#   ?dc = -0.1933333333333333
#   ?dc2 = 0.03737777777777777
#   ?effN = 2.4304289707133306
#   ?gini = 0.5885499999999999
#   ?l2 = 0.2794935896700793
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = 0.21000000000000002
#   ?s2 = 0.04073888888888891
#   ?s3 = 0.07811666666666667
#   ?sAbs = 0.4033333333333333
#   ?sumSq = 0.41145000000000004
#   ?tv = 0.20166666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :tvToUniform 0.20166666666666666 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_5 :l2ToUniform 0.2794935896700793 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_5 .
#   _:sk_5 :pi _:sk_0 .
#   _:sk_0 :pA 0.535 .
#   _:sk_0 :pB 0.325 .
#   _:sk_0 :pC 0.14 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.535 2.0) math:exponentiation 0.286225 .
#   (0.325 2.0) math:exponentiation 0.10562500000000001 .
#   (0.14 2.0) math:exponentiation 0.019600000000000003 .
#   (0.286225 0.10562500000000001) math:sum 0.39185000000000003 .
#   (0.39185000000000003 0.019600000000000003) math:sum 0.41145000000000004 .
#   (1.0 0.41145000000000004) math:difference 0.5885499999999999 .
#   (1.0 0.41145000000000004) math:quotient 2.4304289707133306 .
#   (0.535 0.3333333333333333) math:difference 0.20166666666666672 .
#   0.20166666666666672 math:absoluteValue 0.20166666666666672 .
#   (0.325 0.3333333333333333) math:difference -0.008333333333333304 .
#   -0.008333333333333304 math:absoluteValue 0.008333333333333304 .
#   (0.14 0.3333333333333333) math:difference -0.1933333333333333 .
#   -0.1933333333333333 math:absoluteValue 0.1933333333333333 .
#   (0.20166666666666672 0.008333333333333304) math:sum 0.21000000000000002 .
#   (0.21000000000000002 0.1933333333333333) math:sum 0.4033333333333333 .
#   (0.5 0.4033333333333333) math:product 0.20166666666666666 .
#   (0.20166666666666672 2.0) math:exponentiation 0.040669444444444466 .
#   (-0.008333333333333304 2.0) math:exponentiation 0.00006944444444444396 .
#   (-0.1933333333333333 2.0) math:exponentiation 0.03737777777777777 .
#   (0.040669444444444466 0.00006944444444444396) math:sum 0.04073888888888891 .
#   (0.04073888888888891 0.03737777777777777) math:sum 0.07811666666666667 .
#   (0.07811666666666667 0.5) math:exponentiation 0.2794935896700793 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.535
#   ?a2 = 0.286225
#   ?ab2 = 0.39185000000000003
#   ?ada = 0.20166666666666672
#   ?adb = 0.008333333333333304
#   ?adc = 0.1933333333333333
#   ?b = 0.325
#   ?b2 = 0.10562500000000001
#   ?c = 0.14
#   ?c2 = 0.019600000000000003
#   ?da = 0.20166666666666672
#   ?da2 = 0.040669444444444466
#   ?db = -0.008333333333333304
#   ?db2 = 0.00006944444444444396
#   ?dc = -0.1933333333333333
#   ?dc2 = 0.03737777777777777
#   ?effN = 2.4304289707133306
#   ?gini = 0.5885499999999999
#   ?l2 = 0.2794935896700793
#   ?m = _:sk_5
#   ?pi = _:sk_0
#   ?s1 = 0.21000000000000002
#   ?s2 = 0.04073888888888891
#   ?s3 = 0.07811666666666667
#   ?sAbs = 0.4033333333333333
#   ?sumSq = 0.41145000000000004
#   ?tv = 0.20166666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_5 :l2ToUniform 0.2794935896700793 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :sumSq 0.45999999999999996 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.60 2.0) math:exponentiation 0.36 .
#   (0.30 2.0) math:exponentiation 0.09 .
#   (0.10 2.0) math:exponentiation 0.010000000000000002 .
#   (0.36 0.09) math:sum 0.44999999999999996 .
#   (0.44999999999999996 0.010000000000000002) math:sum 0.45999999999999996 .
#   (1.0 0.45999999999999996) math:difference 0.54 .
#   (1.0 0.45999999999999996) math:quotient 2.173913043478261 .
#   (0.60 0.3333333333333333) math:difference 0.26666666666666666 .
#   0.26666666666666666 math:absoluteValue 0.26666666666666666 .
#   (0.30 0.3333333333333333) math:difference -0.033333333333333326 .
#   -0.033333333333333326 math:absoluteValue 0.033333333333333326 .
#   (0.10 0.3333333333333333) math:difference -0.2333333333333333 .
#   -0.2333333333333333 math:absoluteValue 0.2333333333333333 .
#   (0.26666666666666666 0.033333333333333326) math:sum 0.3 .
#   (0.3 0.2333333333333333) math:sum 0.5333333333333333 .
#   (0.5 0.5333333333333333) math:product 0.26666666666666666 .
#   (0.26666666666666666 2.0) math:exponentiation 0.07111111111111111 .
#   (-0.033333333333333326 2.0) math:exponentiation 0.0011111111111111107 .
#   (-0.2333333333333333 2.0) math:exponentiation 0.054444444444444434 .
#   (0.07111111111111111 0.0011111111111111107) math:sum 0.07222222222222222 .
#   (0.07222222222222222 0.054444444444444434) math:sum 0.12666666666666665 .
#   (0.12666666666666665 0.5) math:exponentiation 0.3559026084010437 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = 0.36
#   ?ab2 = 0.44999999999999996
#   ?ada = 0.26666666666666666
#   ?adb = 0.033333333333333326
#   ?adc = 0.2333333333333333
#   ?b = 0.30
#   ?b2 = 0.09
#   ?c = 0.10
#   ?c2 = 0.010000000000000002
#   ?da = 0.26666666666666666
#   ?da2 = 0.07111111111111111
#   ?db = -0.033333333333333326
#   ?db2 = 0.0011111111111111107
#   ?dc = -0.2333333333333333
#   ?dc2 = 0.054444444444444434
#   ?effN = 2.173913043478261
#   ?gini = 0.54
#   ?l2 = 0.3559026084010437
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = 0.3
#   ?s2 = 0.07222222222222222
#   ?s3 = 0.12666666666666665
#   ?sAbs = 0.5333333333333333
#   ?sumSq = 0.45999999999999996
#   ?tv = 0.26666666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :sumSq 0.45999999999999996 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :gini 0.54 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.60 2.0) math:exponentiation 0.36 .
#   (0.30 2.0) math:exponentiation 0.09 .
#   (0.10 2.0) math:exponentiation 0.010000000000000002 .
#   (0.36 0.09) math:sum 0.44999999999999996 .
#   (0.44999999999999996 0.010000000000000002) math:sum 0.45999999999999996 .
#   (1.0 0.45999999999999996) math:difference 0.54 .
#   (1.0 0.45999999999999996) math:quotient 2.173913043478261 .
#   (0.60 0.3333333333333333) math:difference 0.26666666666666666 .
#   0.26666666666666666 math:absoluteValue 0.26666666666666666 .
#   (0.30 0.3333333333333333) math:difference -0.033333333333333326 .
#   -0.033333333333333326 math:absoluteValue 0.033333333333333326 .
#   (0.10 0.3333333333333333) math:difference -0.2333333333333333 .
#   -0.2333333333333333 math:absoluteValue 0.2333333333333333 .
#   (0.26666666666666666 0.033333333333333326) math:sum 0.3 .
#   (0.3 0.2333333333333333) math:sum 0.5333333333333333 .
#   (0.5 0.5333333333333333) math:product 0.26666666666666666 .
#   (0.26666666666666666 2.0) math:exponentiation 0.07111111111111111 .
#   (-0.033333333333333326 2.0) math:exponentiation 0.0011111111111111107 .
#   (-0.2333333333333333 2.0) math:exponentiation 0.054444444444444434 .
#   (0.07111111111111111 0.0011111111111111107) math:sum 0.07222222222222222 .
#   (0.07222222222222222 0.054444444444444434) math:sum 0.12666666666666665 .
#   (0.12666666666666665 0.5) math:exponentiation 0.3559026084010437 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = 0.36
#   ?ab2 = 0.44999999999999996
#   ?ada = 0.26666666666666666
#   ?adb = 0.033333333333333326
#   ?adc = 0.2333333333333333
#   ?b = 0.30
#   ?b2 = 0.09
#   ?c = 0.10
#   ?c2 = 0.010000000000000002
#   ?da = 0.26666666666666666
#   ?da2 = 0.07111111111111111
#   ?db = -0.033333333333333326
#   ?db2 = 0.0011111111111111107
#   ?dc = -0.2333333333333333
#   ?dc2 = 0.054444444444444434
#   ?effN = 2.173913043478261
#   ?gini = 0.54
#   ?l2 = 0.3559026084010437
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = 0.3
#   ?s2 = 0.07222222222222222
#   ?s3 = 0.12666666666666665
#   ?sAbs = 0.5333333333333333
#   ?sumSq = 0.45999999999999996
#   ?tv = 0.26666666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :gini 0.54 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :effectiveStates 2.173913043478261 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.60 2.0) math:exponentiation 0.36 .
#   (0.30 2.0) math:exponentiation 0.09 .
#   (0.10 2.0) math:exponentiation 0.010000000000000002 .
#   (0.36 0.09) math:sum 0.44999999999999996 .
#   (0.44999999999999996 0.010000000000000002) math:sum 0.45999999999999996 .
#   (1.0 0.45999999999999996) math:difference 0.54 .
#   (1.0 0.45999999999999996) math:quotient 2.173913043478261 .
#   (0.60 0.3333333333333333) math:difference 0.26666666666666666 .
#   0.26666666666666666 math:absoluteValue 0.26666666666666666 .
#   (0.30 0.3333333333333333) math:difference -0.033333333333333326 .
#   -0.033333333333333326 math:absoluteValue 0.033333333333333326 .
#   (0.10 0.3333333333333333) math:difference -0.2333333333333333 .
#   -0.2333333333333333 math:absoluteValue 0.2333333333333333 .
#   (0.26666666666666666 0.033333333333333326) math:sum 0.3 .
#   (0.3 0.2333333333333333) math:sum 0.5333333333333333 .
#   (0.5 0.5333333333333333) math:product 0.26666666666666666 .
#   (0.26666666666666666 2.0) math:exponentiation 0.07111111111111111 .
#   (-0.033333333333333326 2.0) math:exponentiation 0.0011111111111111107 .
#   (-0.2333333333333333 2.0) math:exponentiation 0.054444444444444434 .
#   (0.07111111111111111 0.0011111111111111107) math:sum 0.07222222222222222 .
#   (0.07222222222222222 0.054444444444444434) math:sum 0.12666666666666665 .
#   (0.12666666666666665 0.5) math:exponentiation 0.3559026084010437 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = 0.36
#   ?ab2 = 0.44999999999999996
#   ?ada = 0.26666666666666666
#   ?adb = 0.033333333333333326
#   ?adc = 0.2333333333333333
#   ?b = 0.30
#   ?b2 = 0.09
#   ?c = 0.10
#   ?c2 = 0.010000000000000002
#   ?da = 0.26666666666666666
#   ?da2 = 0.07111111111111111
#   ?db = -0.033333333333333326
#   ?db2 = 0.0011111111111111107
#   ?dc = -0.2333333333333333
#   ?dc2 = 0.054444444444444434
#   ?effN = 2.173913043478261
#   ?gini = 0.54
#   ?l2 = 0.3559026084010437
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = 0.3
#   ?s2 = 0.07222222222222222
#   ?s3 = 0.12666666666666665
#   ?sAbs = 0.5333333333333333
#   ?sumSq = 0.45999999999999996
#   ?tv = 0.26666666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :effectiveStates 2.173913043478261 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :tvToUniform 0.26666666666666666 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.60 2.0) math:exponentiation 0.36 .
#   (0.30 2.0) math:exponentiation 0.09 .
#   (0.10 2.0) math:exponentiation 0.010000000000000002 .
#   (0.36 0.09) math:sum 0.44999999999999996 .
#   (0.44999999999999996 0.010000000000000002) math:sum 0.45999999999999996 .
#   (1.0 0.45999999999999996) math:difference 0.54 .
#   (1.0 0.45999999999999996) math:quotient 2.173913043478261 .
#   (0.60 0.3333333333333333) math:difference 0.26666666666666666 .
#   0.26666666666666666 math:absoluteValue 0.26666666666666666 .
#   (0.30 0.3333333333333333) math:difference -0.033333333333333326 .
#   -0.033333333333333326 math:absoluteValue 0.033333333333333326 .
#   (0.10 0.3333333333333333) math:difference -0.2333333333333333 .
#   -0.2333333333333333 math:absoluteValue 0.2333333333333333 .
#   (0.26666666666666666 0.033333333333333326) math:sum 0.3 .
#   (0.3 0.2333333333333333) math:sum 0.5333333333333333 .
#   (0.5 0.5333333333333333) math:product 0.26666666666666666 .
#   (0.26666666666666666 2.0) math:exponentiation 0.07111111111111111 .
#   (-0.033333333333333326 2.0) math:exponentiation 0.0011111111111111107 .
#   (-0.2333333333333333 2.0) math:exponentiation 0.054444444444444434 .
#   (0.07111111111111111 0.0011111111111111107) math:sum 0.07222222222222222 .
#   (0.07222222222222222 0.054444444444444434) math:sum 0.12666666666666665 .
#   (0.12666666666666665 0.5) math:exponentiation 0.3559026084010437 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = 0.36
#   ?ab2 = 0.44999999999999996
#   ?ada = 0.26666666666666666
#   ?adb = 0.033333333333333326
#   ?adc = 0.2333333333333333
#   ?b = 0.30
#   ?b2 = 0.09
#   ?c = 0.10
#   ?c2 = 0.010000000000000002
#   ?da = 0.26666666666666666
#   ?da2 = 0.07111111111111111
#   ?db = -0.033333333333333326
#   ?db2 = 0.0011111111111111107
#   ?dc = -0.2333333333333333
#   ?dc2 = 0.054444444444444434
#   ?effN = 2.173913043478261
#   ?gini = 0.54
#   ?l2 = 0.3559026084010437
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = 0.3
#   ?s2 = 0.07222222222222222
#   ?s3 = 0.12666666666666665
#   ?sAbs = 0.5333333333333333
#   ?sumSq = 0.45999999999999996
#   ?tv = 0.26666666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :tvToUniform 0.26666666666666666 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_4 :l2ToUniform 0.3559026084010437 .
# It holds because the following instance of the rule body is provable:
#   :MC1 :metrics _:sk_4 .
#   _:sk_4 :pi _:b4 .
#   _:b4 :pA 0.60 .
#   _:b4 :pB 0.30 .
#   _:b4 :pC 0.10 .
#   (1.0 3.0) math:quotient 0.3333333333333333 .
#   (0.60 2.0) math:exponentiation 0.36 .
#   (0.30 2.0) math:exponentiation 0.09 .
#   (0.10 2.0) math:exponentiation 0.010000000000000002 .
#   (0.36 0.09) math:sum 0.44999999999999996 .
#   (0.44999999999999996 0.010000000000000002) math:sum 0.45999999999999996 .
#   (1.0 0.45999999999999996) math:difference 0.54 .
#   (1.0 0.45999999999999996) math:quotient 2.173913043478261 .
#   (0.60 0.3333333333333333) math:difference 0.26666666666666666 .
#   0.26666666666666666 math:absoluteValue 0.26666666666666666 .
#   (0.30 0.3333333333333333) math:difference -0.033333333333333326 .
#   -0.033333333333333326 math:absoluteValue 0.033333333333333326 .
#   (0.10 0.3333333333333333) math:difference -0.2333333333333333 .
#   -0.2333333333333333 math:absoluteValue 0.2333333333333333 .
#   (0.26666666666666666 0.033333333333333326) math:sum 0.3 .
#   (0.3 0.2333333333333333) math:sum 0.5333333333333333 .
#   (0.5 0.5333333333333333) math:product 0.26666666666666666 .
#   (0.26666666666666666 2.0) math:exponentiation 0.07111111111111111 .
#   (-0.033333333333333326 2.0) math:exponentiation 0.0011111111111111107 .
#   (-0.2333333333333333 2.0) math:exponentiation 0.054444444444444434 .
#   (0.07111111111111111 0.0011111111111111107) math:sum 0.07222222222222222 .
#   (0.07222222222222222 0.054444444444444434) math:sum 0.12666666666666665 .
#   (0.12666666666666665 0.5) math:exponentiation 0.3559026084010437 .
# via the schematic forward rule:
#   {
#     :MC1 :metrics ?m .
#     ?m :pi ?pi .
#     ?pi :pA ?a .
#     ?pi :pB ?b .
#     ?pi :pC ?c .
#     (1.0 3.0) math:quotient ?u .
#     (?a 2.0) math:exponentiation ?a2 .
#     (?b 2.0) math:exponentiation ?b2 .
#     (?c 2.0) math:exponentiation ?c2 .
#     (?a2 ?b2) math:sum ?ab2 .
#     (?ab2 ?c2) math:sum ?sumSq .
#     (1.0 ?sumSq) math:difference ?gini .
#     (1.0 ?sumSq) math:quotient ?effN .
#     (?a ?u) math:difference ?da .
#     ?da math:absoluteValue ?ada .
#     (?b ?u) math:difference ?db .
#     ?db math:absoluteValue ?adb .
#     (?c ?u) math:difference ?dc .
#     ?dc math:absoluteValue ?adc .
#     (?ada ?adb) math:sum ?s1 .
#     (?s1 ?adc) math:sum ?sAbs .
#     (0.5 ?sAbs) math:product ?tv .
#     (?da 2.0) math:exponentiation ?da2 .
#     (?db 2.0) math:exponentiation ?db2 .
#     (?dc 2.0) math:exponentiation ?dc2 .
#     (?da2 ?db2) math:sum ?s2 .
#     (?s2 ?dc2) math:sum ?s3 .
#     (?s3 0.5) math:exponentiation ?l2 .
#   } => {
#     ?m :sumSq ?sumSq .
#     ?m :gini ?gini .
#     ?m :effectiveStates ?effN .
#     ?m :tvToUniform ?tv .
#     ?m :l2ToUniform ?l2 .
#   } .
# with substitution (on rule variables):
#   ?a = 0.60
#   ?a2 = 0.36
#   ?ab2 = 0.44999999999999996
#   ?ada = 0.26666666666666666
#   ?adb = 0.033333333333333326
#   ?adc = 0.2333333333333333
#   ?b = 0.30
#   ?b2 = 0.09
#   ?c = 0.10
#   ?c2 = 0.010000000000000002
#   ?da = 0.26666666666666666
#   ?da2 = 0.07111111111111111
#   ?db = -0.033333333333333326
#   ?db2 = 0.0011111111111111107
#   ?dc = -0.2333333333333333
#   ?dc2 = 0.054444444444444434
#   ?effN = 2.173913043478261
#   ?gini = 0.54
#   ?l2 = 0.3559026084010437
#   ?m = _:sk_4
#   ?pi = _:b4
#   ?s1 = 0.3
#   ?s2 = 0.07222222222222222
#   ?s3 = 0.12666666666666665
#   ?sAbs = 0.5333333333333333
#   ?sumSq = 0.45999999999999996
#   ?tv = 0.26666666666666666
#   ?u = 0.3333333333333333
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_4 :l2ToUniform 0.3559026084010437 .

