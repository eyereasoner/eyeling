@prefix : <http://example.org/time-tests#> .
@prefix time: <http://www.w3.org/2000/10/swap/time#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-01 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-01 a :TimeBuiltinTest .
#     :t-time-day-01 :builtin time:day .
#     :t-time-day-01 :input ?dt .
#     :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-01 :actual ?d .
#     :t-time-day-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "1"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-01 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-01 :builtin time:day .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-01 a :TimeBuiltinTest .
#     :t-time-day-01 :builtin time:day .
#     :t-time-day-01 :input ?dt .
#     :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-01 :actual ?d .
#     :t-time-day-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "1"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-01 :builtin time:day .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-01 a :TimeBuiltinTest .
#     :t-time-day-01 :builtin time:day .
#     :t-time-day-01 :input ?dt .
#     :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-01 :actual ?d .
#     :t-time-day-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "1"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-01 a :TimeBuiltinTest .
#     :t-time-day-01 :builtin time:day .
#     :t-time-day-01 :input ?dt .
#     :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-01 :actual ?d .
#     :t-time-day-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "1"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-01 :actual "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-01 a :TimeBuiltinTest .
#     :t-time-day-01 :builtin time:day .
#     :t-time-day-01 :input ?dt .
#     :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-01 :actual ?d .
#     :t-time-day-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "1"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-01 :actual "1"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-01 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-01 a :TimeBuiltinTest .
#     :t-time-day-01 :builtin time:day .
#     :t-time-day-01 :input ?dt .
#     :t-time-day-01 :expected "1"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-01 :actual ?d .
#     :t-time-day-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "1"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-01 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-02 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "31"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-02 a :TimeBuiltinTest .
#     :t-time-day-02 :builtin time:day .
#     :t-time-day-02 :input ?dt .
#     :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-02 :actual ?d .
#     :t-time-day-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "31"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-02 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-02 :builtin time:day .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "31"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-02 a :TimeBuiltinTest .
#     :t-time-day-02 :builtin time:day .
#     :t-time-day-02 :input ?dt .
#     :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-02 :actual ?d .
#     :t-time-day-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "31"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-02 :builtin time:day .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "31"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-02 a :TimeBuiltinTest .
#     :t-time-day-02 :builtin time:day .
#     :t-time-day-02 :input ?dt .
#     :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-02 :actual ?d .
#     :t-time-day-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "31"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "31"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-02 a :TimeBuiltinTest .
#     :t-time-day-02 :builtin time:day .
#     :t-time-day-02 :input ?dt .
#     :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-02 :actual ?d .
#     :t-time-day-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "31"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-02 :actual "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "31"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-02 a :TimeBuiltinTest .
#     :t-time-day-02 :builtin time:day .
#     :t-time-day-02 :input ?dt .
#     :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-02 :actual ?d .
#     :t-time-day-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "31"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-02 :actual "31"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-day-02 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:day "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "31"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:day ?d .
#     ?d math:equalTo "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-day-02 a :TimeBuiltinTest .
#     :t-time-day-02 :builtin time:day .
#     :t-time-day-02 :input ?dt .
#     :t-time-day-02 :expected "31"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-day-02 :actual ?d .
#     :t-time-day-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = "31"^^<http://www.w3.org/2001/XMLSchema#integer>
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-day-02 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-01 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-01 a :TimeBuiltinTest .
#     :t-time-month-01 :builtin time:month .
#     :t-time-month-01 :input ?dt .
#     :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-01 :actual ?m .
#     :t-time-month-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-01 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-01 :builtin time:month .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-01 a :TimeBuiltinTest .
#     :t-time-month-01 :builtin time:month .
#     :t-time-month-01 :input ?dt .
#     :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-01 :actual ?m .
#     :t-time-month-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-01 :builtin time:month .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-01 a :TimeBuiltinTest .
#     :t-time-month-01 :builtin time:month .
#     :t-time-month-01 :input ?dt .
#     :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-01 :actual ?m .
#     :t-time-month-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-01 a :TimeBuiltinTest .
#     :t-time-month-01 :builtin time:month .
#     :t-time-month-01 :input ?dt .
#     :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-01 :actual ?m .
#     :t-time-month-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-01 :actual "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-01 a :TimeBuiltinTest .
#     :t-time-month-01 :builtin time:month .
#     :t-time-month-01 :input ?dt .
#     :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-01 :actual ?m .
#     :t-time-month-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-01 :actual "4"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-01 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-01 a :TimeBuiltinTest .
#     :t-time-month-01 :builtin time:month .
#     :t-time-month-01 :input ?dt .
#     :t-time-month-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-01 :actual ?m .
#     :t-time-month-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-01 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-02 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "12"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-02 a :TimeBuiltinTest .
#     :t-time-month-02 :builtin time:month .
#     :t-time-month-02 :input ?dt .
#     :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-02 :actual ?m .
#     :t-time-month-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "12"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-02 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-02 :builtin time:month .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "12"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-02 a :TimeBuiltinTest .
#     :t-time-month-02 :builtin time:month .
#     :t-time-month-02 :input ?dt .
#     :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-02 :actual ?m .
#     :t-time-month-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "12"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-02 :builtin time:month .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "12"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-02 a :TimeBuiltinTest .
#     :t-time-month-02 :builtin time:month .
#     :t-time-month-02 :input ?dt .
#     :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-02 :actual ?m .
#     :t-time-month-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "12"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "12"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-02 a :TimeBuiltinTest .
#     :t-time-month-02 :builtin time:month .
#     :t-time-month-02 :input ?dt .
#     :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-02 :actual ?m .
#     :t-time-month-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "12"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-02 :actual "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "12"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-02 a :TimeBuiltinTest .
#     :t-time-month-02 :builtin time:month .
#     :t-time-month-02 :input ?dt .
#     :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-02 :actual ?m .
#     :t-time-month-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "12"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-02 :actual "12"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-month-02 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:month "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "12"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:month ?m .
#     ?m math:equalTo "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-month-02 a :TimeBuiltinTest .
#     :t-time-month-02 :builtin time:month .
#     :t-time-month-02 :input ?dt .
#     :t-time-month-02 :expected "12"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-month-02 :actual ?m .
#     :t-time-month-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?m = "12"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-month-02 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-01 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "2023"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-01 a :TimeBuiltinTest .
#     :t-time-year-01 :builtin time:year .
#     :t-time-year-01 :input ?dt .
#     :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-01 :actual ?y .
#     :t-time-year-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "2023"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-01 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-01 :builtin time:year .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "2023"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-01 a :TimeBuiltinTest .
#     :t-time-year-01 :builtin time:year .
#     :t-time-year-01 :input ?dt .
#     :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-01 :actual ?y .
#     :t-time-year-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "2023"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-01 :builtin time:year .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "2023"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-01 a :TimeBuiltinTest .
#     :t-time-year-01 :builtin time:year .
#     :t-time-year-01 :input ?dt .
#     :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-01 :actual ?y .
#     :t-time-year-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "2023"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "2023"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-01 a :TimeBuiltinTest .
#     :t-time-year-01 :builtin time:year .
#     :t-time-year-01 :input ?dt .
#     :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-01 :actual ?y .
#     :t-time-year-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "2023"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-01 :actual "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "2023"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-01 a :TimeBuiltinTest .
#     :t-time-year-01 :builtin time:year .
#     :t-time-year-01 :input ?dt .
#     :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-01 :actual ?y .
#     :t-time-year-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "2023"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-01 :actual "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-01 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "2023"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-01 a :TimeBuiltinTest .
#     :t-time-year-01 :builtin time:year .
#     :t-time-year-01 :input ?dt .
#     :t-time-year-01 :expected "2023"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-01 :actual ?y .
#     :t-time-year-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "2023"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-01 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-02 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1999"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-02 a :TimeBuiltinTest .
#     :t-time-year-02 :builtin time:year .
#     :t-time-year-02 :input ?dt .
#     :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-02 :actual ?y .
#     :t-time-year-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "1999"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-02 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-02 :builtin time:year .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1999"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-02 a :TimeBuiltinTest .
#     :t-time-year-02 :builtin time:year .
#     :t-time-year-02 :input ?dt .
#     :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-02 :actual ?y .
#     :t-time-year-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "1999"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-02 :builtin time:year .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1999"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-02 a :TimeBuiltinTest .
#     :t-time-year-02 :builtin time:year .
#     :t-time-year-02 :input ?dt .
#     :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-02 :actual ?y .
#     :t-time-year-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "1999"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1999"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-02 a :TimeBuiltinTest .
#     :t-time-year-02 :builtin time:year .
#     :t-time-year-02 :input ?dt .
#     :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-02 :actual ?y .
#     :t-time-year-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "1999"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-02 :actual "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1999"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-02 a :TimeBuiltinTest .
#     :t-time-year-02 :builtin time:year .
#     :t-time-year-02 :input ?dt .
#     :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-02 :actual ?y .
#     :t-time-year-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "1999"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-02 :actual "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-year-02 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:year "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "1999"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:year ?y .
#     ?y math:equalTo "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-year-02 a :TimeBuiltinTest .
#     :t-time-year-02 :builtin time:year .
#     :t-time-year-02 :input ?dt .
#     :t-time-year-02 :expected "1999"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-year-02 :actual ?y .
#     :t-time-year-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?y = "1999"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-year-02 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-01 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "6"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-01 a :TimeBuiltinTest .
#     :t-time-minute-01 :builtin time:minute .
#     :t-time-minute-01 :input ?dt .
#     :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-01 :actual ?min .
#     :t-time-minute-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "6"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-01 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-01 :builtin time:minute .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "6"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-01 a :TimeBuiltinTest .
#     :t-time-minute-01 :builtin time:minute .
#     :t-time-minute-01 :input ?dt .
#     :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-01 :actual ?min .
#     :t-time-minute-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "6"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-01 :builtin time:minute .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "6"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-01 a :TimeBuiltinTest .
#     :t-time-minute-01 :builtin time:minute .
#     :t-time-minute-01 :input ?dt .
#     :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-01 :actual ?min .
#     :t-time-minute-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "6"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "6"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-01 a :TimeBuiltinTest .
#     :t-time-minute-01 :builtin time:minute .
#     :t-time-minute-01 :input ?dt .
#     :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-01 :actual ?min .
#     :t-time-minute-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "6"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-01 :actual "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "6"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-01 a :TimeBuiltinTest .
#     :t-time-minute-01 :builtin time:minute .
#     :t-time-minute-01 :input ?dt .
#     :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-01 :actual ?min .
#     :t-time-minute-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "6"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-01 :actual "6"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-01 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "6"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-01 a :TimeBuiltinTest .
#     :t-time-minute-01 :builtin time:minute .
#     :t-time-minute-01 :input ?dt .
#     :t-time-minute-01 :expected "6"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-01 :actual ?min .
#     :t-time-minute-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "6"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-01 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-02 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-02 a :TimeBuiltinTest .
#     :t-time-minute-02 :builtin time:minute .
#     :t-time-minute-02 :input ?dt .
#     :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-02 :actual ?min .
#     :t-time-minute-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-02 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-02 :builtin time:minute .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-02 a :TimeBuiltinTest .
#     :t-time-minute-02 :builtin time:minute .
#     :t-time-minute-02 :input ?dt .
#     :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-02 :actual ?min .
#     :t-time-minute-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-02 :builtin time:minute .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-02 a :TimeBuiltinTest .
#     :t-time-minute-02 :builtin time:minute .
#     :t-time-minute-02 :input ?dt .
#     :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-02 :actual ?min .
#     :t-time-minute-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-02 a :TimeBuiltinTest .
#     :t-time-minute-02 :builtin time:minute .
#     :t-time-minute-02 :input ?dt .
#     :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-02 :actual ?min .
#     :t-time-minute-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-02 :actual "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-02 a :TimeBuiltinTest .
#     :t-time-minute-02 :builtin time:minute .
#     :t-time-minute-02 :input ?dt .
#     :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-02 :actual ?min .
#     :t-time-minute-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-02 :actual "59"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-minute-02 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:minute "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:minute ?min .
#     ?min math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-minute-02 a :TimeBuiltinTest .
#     :t-time-minute-02 :builtin time:minute .
#     :t-time-minute-02 :input ?dt .
#     :t-time-minute-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-minute-02 :actual ?min .
#     :t-time-minute-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?min = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-minute-02 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-01 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-01 a :TimeBuiltinTest .
#     :t-time-second-01 :builtin time:second .
#     :t-time-second-01 :input ?dt .
#     :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-01 :actual ?sec .
#     :t-time-second-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-01 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-01 :builtin time:second .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-01 a :TimeBuiltinTest .
#     :t-time-second-01 :builtin time:second .
#     :t-time-second-01 :input ?dt .
#     :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-01 :actual ?sec .
#     :t-time-second-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-01 :builtin time:second .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-01 a :TimeBuiltinTest .
#     :t-time-second-01 :builtin time:second .
#     :t-time-second-01 :input ?dt .
#     :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-01 :actual ?sec .
#     :t-time-second-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-01 :input "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-01 a :TimeBuiltinTest .
#     :t-time-second-01 :builtin time:second .
#     :t-time-second-01 :input ?dt .
#     :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-01 :actual ?sec .
#     :t-time-second-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-01 :actual "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-01 a :TimeBuiltinTest .
#     :t-time-second-01 :builtin time:second .
#     :t-time-second-01 :input ?dt .
#     :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-01 :actual ?sec .
#     :t-time-second-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-01 :actual "4"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-01 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt1-value :lexical "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "4"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt1-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-01 a :TimeBuiltinTest .
#     :t-time-second-01 :builtin time:second .
#     :t-time-second-01 :input ?dt .
#     :t-time-second-01 :expected "4"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-01 :actual ?sec .
#     :t-time-second-01 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "2023-04-01T18:06:04Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "4"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-01 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-02 a :TimeBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-02 a :TimeBuiltinTest .
#     :t-time-second-02 :builtin time:second .
#     :t-time-second-02 :input ?dt .
#     :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-02 :actual ?sec .
#     :t-time-second-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-02 a :TimeBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-02 :builtin time:second .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-02 a :TimeBuiltinTest .
#     :t-time-second-02 :builtin time:second .
#     :t-time-second-02 :input ?dt .
#     :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-02 :actual ?sec .
#     :t-time-second-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-02 :builtin time:second .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-02 a :TimeBuiltinTest .
#     :t-time-second-02 :builtin time:second .
#     :t-time-second-02 :input ?dt .
#     :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-02 :actual ?sec .
#     :t-time-second-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-02 :input "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-02 a :TimeBuiltinTest .
#     :t-time-second-02 :builtin time:second .
#     :t-time-second-02 :input ?dt .
#     :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-02 :actual ?sec .
#     :t-time-second-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-02 :actual "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-02 a :TimeBuiltinTest .
#     :t-time-second-02 :builtin time:second .
#     :t-time-second-02 :input ?dt .
#     :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-02 :actual ?sec .
#     :t-time-second-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-02 :actual "59"^^<http://www.w3.org/2001/XMLSchema#integer> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :t-time-second-02 :status :pass .
# It holds because the following instance of the rule body is provable:
#   :dt2-value :lexical "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> .
#   "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime> time:second "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   "59"^^<http://www.w3.org/2001/XMLSchema#integer> math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
# via the schematic forward rule:
#   {
#     :dt2-value :lexical ?dt .
#     ?dt time:second ?sec .
#     ?sec math:equalTo "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#   } => {
#     :t-time-second-02 a :TimeBuiltinTest .
#     :t-time-second-02 :builtin time:second .
#     :t-time-second-02 :input ?dt .
#     :t-time-second-02 :expected "59"^^<http://www.w3.org/2001/XMLSchema#integer> .
#     :t-time-second-02 :actual ?sec .
#     :t-time-second-02 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?dt = "1999-12-31T23:59:59Z"^^<http://www.w3.org/2001/XMLSchema#dateTime>
#   ?sec = "59"^^<http://www.w3.org/2001/XMLSchema#integer>
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:t-time-second-02 :status :pass .

