@prefix : <urn:example:> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   ("Huey" "Dewey" "Louie") :iterate (2 "Louie") .
# It holds because the following instance of the rule body is provable:
#   :Let :param ("Huey" "Dewey" "Louie") .
#   ("Huey" "Dewey" "Louie") list:iterate (2 "Louie") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
# via the schematic forward rule:
#   {
#     :Let :param ?X .
#     ?X list:iterate ?Y .
#     ?X list:iterate (1 "Dewey") .
#     ?X list:iterate (?Z "Dewey") .
#   } => {
#     ?X :iterate ?Y .
#     "Dewey" :hasIndex ?Z .
#   } .
# with substitution (on rule variables):
#   ?X = ("Huey" "Dewey" "Louie")
#   ?Y = (2 "Louie")
#   ?Z = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

("Huey" "Dewey" "Louie") :iterate (2 "Louie") .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   "Dewey" :hasIndex 1 .
# It holds because the following instance of the rule body is provable:
#   :Let :param ("Huey" "Dewey" "Louie") .
#   ("Huey" "Dewey" "Louie") list:iterate (2 "Louie") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
# via the schematic forward rule:
#   {
#     :Let :param ?X .
#     ?X list:iterate ?Y .
#     ?X list:iterate (1 "Dewey") .
#     ?X list:iterate (?Z "Dewey") .
#   } => {
#     ?X :iterate ?Y .
#     "Dewey" :hasIndex ?Z .
#   } .
# with substitution (on rule variables):
#   ?X = ("Huey" "Dewey" "Louie")
#   ?Y = (2 "Louie")
#   ?Z = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

"Dewey" :hasIndex 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   ("Huey" "Dewey" "Louie") :iterate (1 "Dewey") .
# It holds because the following instance of the rule body is provable:
#   :Let :param ("Huey" "Dewey" "Louie") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
# via the schematic forward rule:
#   {
#     :Let :param ?X .
#     ?X list:iterate ?Y .
#     ?X list:iterate (1 "Dewey") .
#     ?X list:iterate (?Z "Dewey") .
#   } => {
#     ?X :iterate ?Y .
#     "Dewey" :hasIndex ?Z .
#   } .
# with substitution (on rule variables):
#   ?X = ("Huey" "Dewey" "Louie")
#   ?Y = (1 "Dewey")
#   ?Z = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

("Huey" "Dewey" "Louie") :iterate (1 "Dewey") .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   ("Huey" "Dewey" "Louie") :iterate (0 "Huey") .
# It holds because the following instance of the rule body is provable:
#   :Let :param ("Huey" "Dewey" "Louie") .
#   ("Huey" "Dewey" "Louie") list:iterate (0 "Huey") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
#   ("Huey" "Dewey" "Louie") list:iterate (1 "Dewey") .
# via the schematic forward rule:
#   {
#     :Let :param ?X .
#     ?X list:iterate ?Y .
#     ?X list:iterate (1 "Dewey") .
#     ?X list:iterate (?Z "Dewey") .
#   } => {
#     ?X :iterate ?Y .
#     "Dewey" :hasIndex ?Z .
#   } .
# with substitution (on rule variables):
#   ?X = ("Huey" "Dewey" "Louie")
#   ?Y = (0 "Huey")
#   ?Z = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

("Huey" "Dewey" "Louie") :iterate (0 "Huey") .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test :is true .
# It holds because the following instance of the rule body is provable:
#   ("Huey" "Dewey" "Louie") :iterate (0 "Huey") .
#   "Dewey" :hasIndex 1 .
# via the schematic forward rule:
#   {
#     ?X :iterate ?Y .
#     "Dewey" :hasIndex 1 .
#   } => {
#     :test :is true .
#   } .
# with substitution (on rule variables):
#   ?X = ("Huey" "Dewey" "Louie")
#   ?Y = (0 "Huey")
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test :is true .

