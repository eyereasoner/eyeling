# =============================================================================
# This example illustrates “eventual interoperability”:
#   1) Start with rich, internally coherent source semantics (my:*).
#   2) Add interoperability later as explicit, reusable alignments when a
#      concrete interaction/business case exists.
#   3) Alignments can be versioned and swapped without changing the source.
#   4) Same source can be aligned one-to-many: different partners, different
#      target shapes.
#
# The file models a dataset owner publishing a roster using their own rich
# vocabulary (my:) without forcing early agreement on a shared schema.
# When two concrete reuse needs appear (exporting to Partner A and Partner B),
# each integration is handled by adding a separate alignment artefact (mappings)
# and an interaction pattern (expected output shape). The reasoner selects the
# active alignment for each partner, applies class/property/inverse-property
# mappings to produce each partner’s expected shape, and then emits “ready”
# roster views (:PartnerA_Roster, :PartnerB_Roster).
# In other words: local semantics first, interoperability later, and one dataset
# can be aligned to multiple consumers without changing the producer’s model.
#
# Inspired by: https://pietercolpaert.be/interoperability/2026/01/08/eventual-interoperability
# =============================================================================

@prefix my:    <http://example.org/my#>.
@prefix a:     <http://example.org/partnerA#>.
@prefix b:     <http://example.org/partnerB#>.
@prefix :      <http://example.org/demo#>.

@prefix log:   <http://www.w3.org/2000/10/swap/log#>.
@prefix owl:   <http://www.w3.org/2002/07/owl#>.
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.

# ----------------------------------------------------------
# 1) Rich source model (producer vocabulary only: my:*)
# ----------------------------------------------------------

my:Course_KG a my:Course ;
  my:courseCode "KG-101" ;
  my:title "Knowledge Graphs" .

my:Student_A a my:Student ;
  my:givenName  "Ava" ;
  my:familyName "Ng" ;
  my:displayName "Ava Ng" ;
  my:studentID  "S123" ;
  my:enrolledInCourse my:Course_KG ;
  my:enrollmentRole my:TeachingAssistant .

my:Student_B a my:Student ;
  my:givenName  "Bram" ;
  my:familyName "Peeters" ;
  my:displayName "Bram Peeters" ;
  my:studentID  "S124" ;
  my:enrolledInCourse my:Course_KG ;
  my:enrollmentRole my:Student .

# ----------------------------------------------------------
# 2) Interaction patterns (business cases) – enable/disable
# ----------------------------------------------------------

:RosterExportToPartnerA a :InteractionPattern ;
  :enabled true ;
  :usesAlignmentFamily :AlignFamily_PartnerA ;
  :inputShape  :MyRosterInputShape ;
  :outputShape :PartnerARosterShape .

:RosterExportToPartnerB a :InteractionPattern ;
  :enabled true ;
  :usesAlignmentFamily :AlignFamily_PartnerB ;
  :inputShape  :MyRosterInputShape ;
  :outputShape :PartnerBRosterShape .

# “Shapes” here are just named expectations (documented in comments + checked below)
:MyRosterInputShape a :Shape.
:PartnerARosterShape a :Shape.
:PartnerBRosterShape a :Shape.

# ----------------------------------------------------------
# 3) Alignment artefacts (separate from producer model)
#    Demonstrates incremental/versioned alignments.
# ----------------------------------------------------------

# --- Partner A alignment family (two versions, only one active) ---

:Align_A_v1 a :Alignment ; :active false ; :hasFormula {
  # Minimal mapping: only identifier and enrollment link (lossy / partial)
  my:studentID owl:equivalentProperty a:identifier .
  my:enrolledInCourse owl:inverseOf a:hasStudent .
  my:Student owl:equivalentClass a:Student .
  my:Course  owl:equivalentClass a:Course .
}.

:Align_A_v2 a :Alignment ; :active true ; :hasFormula {
  # More complete mapping (later, when the business case is clear)
  my:studentID   owl:equivalentProperty a:identifier .
  my:givenName   owl:equivalentProperty a:givenName .
  my:familyName  owl:equivalentProperty a:familyName .
  my:enrolledInCourse owl:inverseOf a:hasStudent .
  my:Student owl:equivalentClass a:Student .
  my:Course  owl:equivalentClass a:Course .
}.

:AlignFamily_PartnerA :hasMember :Align_A_v1, :Align_A_v2.

# --- Partner B alignment (different target shape) ---

:Align_B_v1 a :Alignment ; :active true ; :hasFormula {
  # Partner B wants a different shape:
  my:Student owl:equivalentClass b:Learner .
  my:studentID owl:equivalentProperty b:learnerId .
  my:displayName owl:equivalentProperty b:fullName .
  my:enrolledInCourse owl:inverseOf b:hasLearner .
  my:Course owl:equivalentClass b:Module .
  my:courseCode owl:equivalentProperty b:moduleCode .
}.

:AlignFamily_PartnerB :hasMember :Align_B_v1.

# ----------------------------------------------------------
# 4) Generic “eventual interoperability” engine
#    - pick the active alignment for the interaction pattern
#    - apply vocabulary-level alignments (equivalentClass/property/inverseOf)
# ----------------------------------------------------------

# Pick the active alignment for a pattern from its family
{
  ?pat a :InteractionPattern ;
       :enabled true ;
       :usesAlignmentFamily ?fam .
  ?fam :hasMember ?al .
  ?al :active true .
} => {
  ?pat :usesAlignment ?al .
}.

# Apply equivalentClass
{
  ?pat :usesAlignment ?al .
  ?al :hasFormula ?A.
  ?A log:includes { ?c1 owl:equivalentClass ?c2. }.
  ?x a ?c1.
} => {
  ?x a ?c2.
  ?x :alignedBy ?pat.
}.

# Apply equivalentProperty
{
  ?pat :usesAlignment ?al .
  ?al :hasFormula ?A.
  ?A log:includes { ?p1 owl:equivalentProperty ?p2. }.
  ?s ?p1 ?o.
} => {
  ?s ?p2 ?o.
  ?s :alignedBy ?pat.
}.

# Apply inverseOf (shape translation)
{
  ?pat :usesAlignment ?al .
  ?al :hasFormula ?A.
  ?A log:includes { ?p1 owl:inverseOf ?p2. }.
  ?s ?p1 ?o.
} => {
  ?o ?p2 ?s.
  ?o :alignedBy ?pat.
}.

# ----------------------------------------------------------
# 5) Interaction-pattern outputs + “shape checks”
#    (systems integrate against shapes/patterns, not single terms)
# ----------------------------------------------------------

# Partner A expects:
#   ?student a a:Student ;
#            a:identifier ?id ;
#            a:givenName ?gn ;
#            a:familyName ?fn .
#   ?course a a:Course ; a:hasStudent ?student .

{
  ?pat a :InteractionPattern ; :enabled true ; :outputShape :PartnerARosterShape .
  ?student a a:Student ;
           a:identifier ?id ;
           a:givenName ?gn ;
           a:familyName ?fn .
  ?course a a:Course ;
          a:hasStudent ?student .
  ?student :alignedBy ?pat.
} => {
  :PartnerA_Roster :fromPattern ?pat ;
                   :includesStudent ?student ;
                   :includesCourse ?course ;
                   :ready true .
}.

# Partner B expects a different shape:
#   ?learner a b:Learner ; b:learnerId ?id ; b:fullName ?name .
#   ?module  a b:Module ; b:moduleCode ?code ; b:hasLearner ?learner .

{
  ?pat a :InteractionPattern ; :enabled true ; :outputShape :PartnerBRosterShape .
  ?learner a b:Learner ;
           b:learnerId ?id ;
           b:fullName ?name .
  ?module a b:Module ;
          b:moduleCode ?code ;
          b:hasLearner ?learner .
  ?learner :alignedBy ?pat.
} => {
  :PartnerB_Roster :fromPattern ?pat ;
                   :includesLearner ?learner ;
                   :includesModule ?module ;
                   :ready true .
}.

