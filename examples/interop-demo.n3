# =================================================================
# Interop demo
# - Syntax: one common N3 representation
# - Semantics: mappings from AppA/AppB vocabularies -> shared model
# - Pragmatics: rule derives an actionable conclusion
# =================================================================

@prefix :     <https://example.org/demo#>.
@prefix a:    <https://example.org/appA#>.
@prefix b:    <https://example.org/appB#>.
@prefix c:    <https://example.org/appC#>.
@prefix ex:   <https://example.org/common#>.
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix log:  <http://www.w3.org/2000/10/swap/log#>.

# ---------------------------------------------
# 1) Three independent apps (different schemas)
# ---------------------------------------------

# App A (commerce)
:aliceA a a:Buyer;
        a:email "alice@example.com";
        a:spentEur "1200"^^xsd:decimal.

# App B (billing)
:aliceB a b:Client;
        b:email "alice@example.com";
        b:totalSpent "1200.00"^^xsd:decimal.

:invoice42 a b:Invoice;
           b:forClient :aliceB;
           b:amountDue "200"^^xsd:decimal.

# App C (CRM / marketing)
:aliceC a c:Contact;
        c:primaryEmail "alice@example.com";
        c:marketingOptIn "true"^^xsd:boolean;
        c:preferredChannel c:Email.

# -------------------------------------------------------------
# 2) Cross-app semantic interop (mappings -> shared vocabulary)
# -------------------------------------------------------------

# Map App A -> shared model
{ ?p a a:Buyer. ?p a:email ?e. }     => { ?p a ex:Customer. ?p ex:email ?e. }.
{ ?p a:spentEur ?s. }               => { ?p ex:lifetimeSpendEur ?s. }.

# Map App B -> shared model
{ ?p a b:Client. ?p b:email ?e. }   => { ?p a ex:Customer. ?p ex:email ?e. }.
{ ?p b:totalSpent ?s. }             => { ?p ex:lifetimeSpendEur ?s. }.
{ ?i a b:Invoice. ?i b:forClient ?p. } => { ?p ex:hasOpenInvoice ?i. }.
{ ?i a b:Invoice. ?i b:amountDue ?d. } => { ?i ex:amountDueEur ?d. }.

# Map App C -> shared model
{ ?p a c:Contact. ?p c:primaryEmail ?e. } => { ?p a ex:Customer. ?p ex:email ?e. }.
{ ?p c:marketingOptIn ?v. }              => { ?p ex:marketingOptIn ?v. }.
{ ?p c:preferredChannel ?ch. }           => { ?p ex:preferredChannel ?ch. }.

# Identity bridging across apps (same email -> same customer)
{ ?x a ex:Customer. ?x ex:email ?e.
  ?y a ex:Customer. ?y ex:email ?e. }
=>
{ ?x ex:sameCustomerAs ?y. }.

# Choose App A's identifier as canonical and pull facts from B and C onto it
{ ?canon a a:Buyer. ?canon ex:sameCustomerAs ?other.
  ?other ex:hasOpenInvoice ?inv. }
=>
{ ?canon ex:hasOpenInvoice ?inv. }.

{ ?canon a a:Buyer. ?canon ex:sameCustomerAs ?other.
  ?other ex:lifetimeSpendEur ?s. }
=>
{ ?canon ex:lifetimeSpendEur ?s. }.

{ ?canon a a:Buyer. ?canon ex:sameCustomerAs ?other.
  ?other ex:marketingOptIn ?v. }
=>
{ ?canon ex:marketingOptIn ?v. }.

{ ?canon a a:Buyer. ?canon ex:sameCustomerAs ?other.
  ?other ex:preferredChannel ?ch. }
=>
{ ?canon ex:preferredChannel ?ch. }.

# -----------------------------------------------------
# 3) Pragmatic interop: derive an actionable conclusion
# -----------------------------------------------------

# If lifetime spend > 1000 and there is an open invoice and marketing is allowed:
{ ?c a ex:Customer;
     ex:lifetimeSpendEur ?s;
     ex:hasOpenInvoice ?inv;
     ex:marketingOptIn "true"^^xsd:boolean.
  ?s math:greaterThan "1000"^^xsd:decimal.
}
=>
{
  ?c ex:eligibleFor ex:GoldDiscount.
  ?c ex:recommendedAction ex:ApplyGoldDiscountAndSendInvoiceReminder.

  # Optional ordered console output for eyeling
  "001" log:outputString "ACTION: apply GoldDiscount and send invoice reminder (opt-in confirmed).".
}.

